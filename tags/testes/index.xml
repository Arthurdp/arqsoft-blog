
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Testes on Arquitetura de Software</title>
   <link>https://joaoarthurbm.github.io/arqsoft-blog/tags/testes/</link>
   <description>Recent content in Testes on Arquitetura de Software</description>
   <generator>Hugo -- gohugo.io</generator>
   <copyright>Copyright &amp;copy; Turma de Arquitetura de Software UFCG</copyright>
   <lastBuildDate>Fri, 13 Aug 2021 00:00:00 -0300</lastBuildDate>
   
       <atom:link href="https://joaoarthurbm.github.io/arqsoft-blog/tags/testes/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Discussão sobre definições de arquitetura de software</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-intro-arquitetura/</link>
       <pubDate>Tue, 07 Sep 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-intro-arquitetura/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento utilizado como guia para discutir em sala de aula alguns conceitos sobre definições de
arquitetura de software que encontramos na literatura.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sarah&#34;&gt;Sarah&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;A. Jansen and J. Bosch, “Software architecture as a set of architectural design decisions,” in Proceedings of the 5th Working Conference on Software Architecture, pp. 109–120, IEEE, 2005.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O que é diferente na visão deles?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exemplos?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integridade conceitual&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O exemplo de colocar as decisões e os porquês. A ideia de que arquitetura é decisão difícil e dura.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;joão-antonio&#34;&gt;João Antonio&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Dilip Soni, Robert L. Nord, and Christine Hofmeister. 1995. Software architecture in industrial applications. In Proceedings of the 17th international conference on Software engineering (ICSE &#39;95). Association for Computing Machinery, New York, NY, USA, 196–207.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4 categorias: conceitual, módulo, execução e código&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Os autores observaram que a separação de preocupações usando diferentes tipos de arquitetura tem uma série de vantagens quando se desenvolve sistemas complexos.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Aqui tem um conceito interessante que é a evolução da teoria a partir da prática, né? estudos etnográficos, grounded theory etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Após a categorização e explicação dos tipos de arquitetura, os autores descreveram alguns dos sistemas observados e as vantagens em separar a arquitetura por categoria. Entre tais vantagens estão: diminuir a granularidade da arquitetura, diminuir a complexidade de implementação e melhorar a reutilização e reconfiguração dos sistemas. Os autores apresentaram exemplos para enfatizar os benefícios em dividir as estruturas através da observação de dois sistemas. Nesta análise, é possível verificar a separação das seguintes estruturas:
Separação da arquitetura conceitual e execução
Separação da arquitetura de módulo e execução.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Mais uma vez: tudo relacionado aos conceitos fundamentais de arquitetura. separação de preocupações, coesão etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Embora os autores observaram benefícios da separação da arquitetura em diferentes tipos, pouco se fala sobre o esforço necessário em separar e como separar os componentes. Comprometendo assim, a aplicabilidade dessas definições em sistemas reais.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Mas isso não veio da indústria?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Por exemplo, em uma pipeline executada no ambiente AWS com o propósito de executar uma análise OCR-Textract em arquivos após o upload em um bucket; o uso de uma abordagem combinada entre arquitetura conceitual e execução, parece ser mais interessante que separá-las.
&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Gostei dessa crítica. Fala mais um pouco sobre isso.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vinicius-brandao&#34;&gt;Vinicius Brandao&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;D. Garlan and D. E. Perry, “Introduction to the special issue on software architecture,” IEEE Trans. Softw. Eng., 1995.&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Desse modo, uma boa arquitetura ajuda na compreensão do código, facilita sua capacidade de reutilização, evolução e análise assim como sua capacidade de gerenciamento do software desenvolvido.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Foco em como a arquitetura é importante para o desenvolvimento também. A gente foca muito em outros requisitos não-funcionais.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Considerando que isso é definido pelos desenvolvedores que em predominantemente optam por arquiteturas informais, não analisáveis. Portanto, os pesquisadores vêm trabalhando em ferramentas  que auxilie esses desenvolvedores e facilite a aplicação de arquitetura para o software.
&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;O que quis dizer com isso?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A estrutura dos componentes de um programa / sistema, suas inter-relações, princípios e diretrizes que regem seu design e evolução ao longo do tempo&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;rodrigo&#34;&gt;Rodrigo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Perry, Dewayne E., and Alexander L. Wolf. &amp;quot;Foundations for the study of software architecture.&amp;quot; ACM SIGSOFT Software engineering notes 17.4 (1992): 40-52.&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Arquitetura de hardware de computação;&amp;rdquo;
- overlap de áreas&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;software architecture = { Elements, Forms, Rationale }, &amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Vamos entender esses 3 conceitos?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;O sistema é adaptado aos novos usuários e tende a mudar ao longo do tempo, essa necessidade se dá por dois problemas: erosão arquitetônica e deriva arquitetônica.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Foco na evolução arquitetural. Isso aqui é muito importante. Noção de que a arquitetura é rígida, mas não pode ser fixa.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A arquitetura de software não é algo que precise ser conceituado ou engessado, ele deve fluir conforme a solução necessite e atender a necessidade do software.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;valter&#34;&gt;Valter&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Gruner, Stefan. &amp;quot;On the historical semantics of the notion of software architecture.&amp;quot; TD: The Journal for Transdisciplinary Research in Southern Africa 10.1 (2014): 37-66.NBR 6023.&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A tese é de que existem duas principais linhas de pensamento quanto ao que é arquitetura de software. Uma linha está relacionada a conceitos de sistemas operacionais, dado que muitos artigos empregam conceitos emprestados de outras engenharias, e outra linha se relaciona mais à existência de diferentes entidades no software e como se relacionam.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;- discutir mais uma vez sobre a sobrecarga do termo arquitetura.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;yure&#34;&gt;Yure&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;M. Shaw and P. Clements, &amp;quot;The golden age of software architecture&amp;quot; in IEEE Software, vol. 23, no. 2, pp. 31-39, March-April 2006, doi: 10.1109/MS.2006.58.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trata-se de uma meta-pesquisa, certo?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;se basearam no modelo Redwine-Riddle (de maturação da tecnologia).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Não conhecia/lembrava. Pode falar um pouco mais.&lt;/li&gt;
&lt;li&gt;Pode ser algo que vocês queiram usar quando estiverem fazendo revisão sistemática, por exemplo &lt;a href=&#34;https://www.cs.utexas.edu/users/software/1998/pfleeger-19981203/sld005.htm&#34;&gt;link&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A figura mostra a maturação do campo de Arquitetura de Software, excluindo as obras fundamentais das décadas de 1960 a 1970.
&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Essa figura é um resumo bem apresentado do trabalho realizado no artigo. Vale a pena discutirmos em detalhes.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Por se tratar de uma análise realizada a quinze anos atrás, naturalmente não contempla o pós “era de ouro”, mas nela vê-se claramente os elementos inovadores que a caracterizaram e notadamente podemos desfrutar hoje de sua maturação. &amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;O que a gente consegue ver hoje que não é abordado?&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Discussão sobre erosão arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-erosao-design/</link>
       <pubDate>Tue, 07 Sep 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-erosao-design/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento utilizado como guia para discutir em sala de aula alguns artigos sobre erosão arquitetural.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vinícius-brandão-araújo&#34;&gt;Vinícius Brandão Araújo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Design erosion: problems and causes. Jilles van Gurp and Jan Bosch. Journal of systems and software 61.2, 2002.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fala mais um pouco sobre o caso do Mozilla.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;O artigo traz consigo as possíveis causas que levam ao problema de erosão de software. Desse modo, os autores elencam diversas causas que levam a esse problema, tais como o aumento do custo de manutenção para grandes sistemas, adição de novas funcionalidades não planejadas, métodos iterativos entre outros.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Vamos falar mais sobre essas causas.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;não importa o quão ambiciosas sejam as intenções dos arquitetos, as arquiteturas de software tendem a se desgastar com o tempo, a ponto de redesenhar do zero se tornar uma alternativa viável em comparação com o prolongamento da vida útil da arquitetura existente.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Comparação com um processo natural de evelhecimento.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Porém,Porem, acredito que mesmo com essa afirmação faltou um embasamento maior dos autores para um estudo de caso mais específico de projetos grandes da indústria, explanando com mais detalhe como ocorreu e consequentemente uma pesquisa com os desenvolvedores desses projetos para medir no aspecto de desenvolvimento o que levou ao problema de erosão. &amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Crítica à metodologia.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Por fim, a metodologia abordada de explicação através de um exemplo traz ao leitor uma visão interessante de como ocorre o problema de erosão, portanto, até leitores que não teve a experiência de participar de um desenvolvimento de software consegue ter domínio e identificar onde e como ocorre erosão de softwares.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Sobre didática do artigo. A tripla problema-causa-remédio.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;valter-vinícius-marinho-de-lucena&#34;&gt;Valter Vinícius Marinho de Lucena&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Assessing architectural drift in commercial software development: a case study. Jacek Rosik, Andre Le Gear, Jim Buckley, Muhammad Ali Babar e Dave Connolly, 2010.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot; A abordagem utilizada foi a Reflexion Modelling, e o estudo acompanhou um time durante a criação de um sistema de software comercial. &amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Vamos discutir um pouco mais essa abordagem.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Os resultados mostraram que a abordagem utilizada, ao contrário do que era esperado, oculta algumas das inconsistências que aconteceram durante o desenvolvimento. &amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Pode dar mais detalhes? Como a abordagem serviu para ocultar inconsistências?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Os autores propõem, também, checagens contínuas da arquitetura, assim como geração de alertas através da integração das checagens nas próprias IDEs utilizadas pelos desenvolvedores, uma vez que, quanto mais tempo um erro existe no código, mais complicado é resolvê-lo. &amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Importância da inclusão perene no processo de desenvolvimento. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;não existe uma solução única para o problema do desvio arquitetural.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- *No silver bullet.*
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;vinícius-de-medeiros-soares&#34;&gt;Vinícius de Medeiros Soares&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;VAN GURP, Jilles; BOSCH, Jan; BRINKKEMPER, Sjaak. Design erosion in evolving software products. In: ELISA workshop. 2003.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;O trabalho tem foco em entender a erosão arquitetural no contexto de grandes projetos, e as questões de pesquisa que são respondidas através dos estudos de caso podem servir como base para a evolução de qualquer empresa em relação a como identificar, resolver e prevenir a erosão.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Quais foram as questões de pesquisa?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Os autores concluíram antecipadamente que a erosão arquitetural é inevitável, por isso o estudo focou em como lidar com essa erosão, ao invés de como preveni-la.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- De novo, um processo &amp;quot;natural&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Outro aspecto apontado é que além de fatores técnicos, há fatores não técnicos que contribuem para a erosão arquitetural.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Quais?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Os autores destacam na conclusão que a habilidade de lidar com a erosão é mais importante que a prevenção.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Vamos discutir um pouco mais sobre isso.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;joão-antonio-leite-dos-santos-neto&#34;&gt;João Antonio Leite Dos Santos Neto&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Eick, Stephen G., et al. &amp;quot;Does code decay? assessing the evidence from change management data.&amp;quot; IEEE Transactions on Software Engineering 27.1 (2001): 1-12.NBR 6023&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;O presente artigo tem como objetivo avaliar como as mudanças em sistemas de larga escala impactam negativamente na qualidade do código.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Como foi feito?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;criaram um modelo conceitual para auxiliar na identificação de causas, sintomas e fatores de riscos para a decadência de código.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Mais uma vez essa perspectiva de problema-causa-ação/remédio.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Um código é considerado em decadência quando é mais difícil de mudar do que deveria ser, em três perspectivas: O custo (esforço) da mudança, que é efetivamente a quantidade de pessoas necessárias para implementar tais mudanças; O intervalo  para completar a mudança, ex:  o calendário/e horas necessárias para implementar as mudanças; Qualidade do software alterado.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A tripla: custo, tempo e qualidade. Sempre ela em Engenharia de Software.
- Como medir quão difícil?
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;yure-pereira-campos&#34;&gt;Yure Pereira Campos&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;C. Izurieta and J. M. Bieman, &amp;quot;How Software Designs Decay: A Pilot Study of Pattern Evolution&amp;quot; First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007), 2007, pp. 449-451, doi: 10.1109/ESEM.2007.55.&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;hipóteses&#34;&gt;Hipóteses&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;H1,0: Existem poucas violações estruturais das realizações de padrões de design.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;H2,0: O número de relacionamentos externos de uma realização de padrão de design permanece o mesmo ao longo do tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;H3,0: A organização do namespace dos componentes que compõem um padrão de design permanece a mesma ao longo do tempo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vamos discutir um pouco essas hipóteses.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;deterioração do design é uma consequência da evolução do software,&amp;rdquo;
- deterioração como consequência.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Discussão sobre visões arquiteturais</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-visoes-arquiteturais/</link>
       <pubDate>Tue, 07 Sep 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/discussao-visoes-arquiteturais/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento utilizado como guia para discutir em sala de aula alguns conceitos sobre visões arquiteturais.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vinicius-brandão&#34;&gt;Vinicius Brandão&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Baragry, Jason, and Karl Reed. &amp;quot;Why we need a different view of software architecture.&amp;quot; Proceedings Working IEEE/IFIP Conference on Software Architecture. IEEE, 2001.&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Por que a associação faz mal?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Construções físicas mudam menos.&lt;/li&gt;
&lt;li&gt;Cuidado com a falsa sensação de facilidade de mudanças no software. Não é apenas uma questão de mulher-homem/hora.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rodrigo-santos&#34;&gt;Rodrigo Santos&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Kruchten, Philippe B. &amp;quot;The 4+ 1 view model of architecture.&amp;quot; IEEE software 12.6 (1995): 42-50.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Visão Lógica: Descreve o modelo de objeto do projeto quando um método de projeto orientado a objeto é usado. Para projetar um aplicativo que é muito orientado a dados, você pode usar uma abordagem alternativa para desenvolver alguma outra forma de visão lógica, como um diagrama de entidade - relacionamento.&lt;/p&gt;
&lt;p&gt;Visão de Processo: Descreve os aspectos de simultaneidade e sincronização do projeto.&lt;/p&gt;
&lt;p&gt;Visão Física: Descreve o mapeamento do software no hardware e reflete seu aspecto distribuído.&lt;/p&gt;
&lt;p&gt;Visão de Desenvolvimento: descreve a organização estática do software em seu ambiente de desenvolvimento.
&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vamos discutir um pouco sobre cada visão proposta. Vamos debater essas com as que vimos em sala de aula. Essas visões são &amp;ldquo;atuais&amp;rdquo;? Como vemos o mundo de desenvolvimento de software hoje se encaixando nessas visões?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O conceito de +1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;A arquitetura por si só deve se tornar estável e não se deve encontrar novas abstrações, subsistemas, processos ou interfaces importantes após a construção inicial.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Isso significa que a arquitetura não deve evoluir?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;sarah-albuquerque&#34;&gt;Sarah Albuquerque&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Kruchten, Philippe B. &amp;quot;The 4+ 1 view model of architecture.&amp;quot; IEEE software 12.6 (1995): 42-50.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Pontos de destaque são que as diferentes arquiteturas não são completamente independentes; o processo proposto não é linear, requer algumas iterações para se estruturar a arquitetura; não é necessário usar as 05 perspectivas.
&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O que siginifica não ser linear?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;valter&#34;&gt;Valter&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Baragry, Jason, and Karl Reed. &amp;quot;Why we need a different view of software architecture.&amp;quot; Proceedings Working IEEE/IFIP Conference on Software Architecture. IEEE, 2001.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;O principal problema não é a falta de resposta para as questões que surgem, e sim a grande quantidade de respostas diferentes.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Relação com integridade conceitual na área.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Enquanto essas analogias facilitam a criação dos conceitos de desenvolvimento de software, elas falham em considerar adequadamente as diferenças entre desenvolvimento e outras disciplinas da área de Engenharia de Software.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Importância da escolha de metáforas. Ajudam, mas podem atrapalhar também. Qual é o caso aqui?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;A análise dessas falhas foi muito bem desenvolvida no artigo, desde a categorização até a discussão dos principais aspectos de cada uma. &amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vamos discutir um pouco mais esse tópico?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;joão-neto&#34;&gt;João Neto&lt;/h1&gt;
&lt;p&gt;&amp;ldquo;Os autores encontraram 3 categorias no qual a analogia falha, sendo elas: Diferenças entre software  sistemas projetados tradicionalmente,   diferenças entre o conteúdo abordado sobre visões arquiteturais nas respectivas disciplinas (software e engenharia tradicional) e as diferenças entre como essas visualizações são usadas no processo de desenvolvimento.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vamos detalhar essas categorias e discutir melhor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Por exemplo, quanto a diferença entre sistemas, os produzidos pela engenharia tradicional, tem forma física (ex: documentos) e tangibilidade que permite identificar sua arquitetura. Por outro lado, na engenharia de software você não consegue identificar a arquitetura olhando apenas para as linhas do código fonte do sistema. Portanto, sistemas de software não tem forma física análogo, logo não são tangíveis e  suas representações de nível, abstração e de design devem ser diferentes para aqueles produzidos pelo mesmo nível de design na engenharia tradicional. Além disso, o conteúdo das visões de arquitetura como ponto de vista de subconjuntos orientados do design ou implementação global não é apresentado em visualizações de arquitetura de software, uma vez que  em sistemas tradicionais não é abordado como o sistema vai operar, e sim como esse aspecto do sistema existirá como um artefato físico.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Importante destacar essa exemplificação.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;No entanto, acredito que é de grande importância o uso de analogias para os casos em que tal mecanismo pode ser aplicado. Uma vez que ajuda na didática e entendimento do sistema em uma perspectiva de mais alto nível. &amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interessante esse contraponto.&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do Apache Airflow</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/airflow/</link>
       <pubDate>Sun, 15 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/airflow/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Nesse documento será descrita a arquitetura do projeto &lt;a href=&#34;https://airflow.apache.org&#34;&gt;Apache Airflow&lt;/a&gt;, utilizando o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Débora Lêda de Lucena Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 119111051&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:debora.souza@ccc.ufcg.edu.br&#34;&gt;debora.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/apache/airflow&#34;&gt;https://github.com/apache/airflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---apache-airflow&#34;&gt;Descrição Arquitetural - Apache Airflow&lt;/h1&gt;
&lt;p&gt;Apache airflow é uma plataforma que permite programaticamente a criação, execução e monitoramento de scripts de processamento de dados. Um script de processamento de dados é a unidade básica de execução no Airflow e é denominado &lt;code&gt;Task&lt;/code&gt;. No Airflow, as &lt;code&gt;tasks&lt;/code&gt; são organizadas em uma estrutura de dados chamada &lt;code&gt;DAG&lt;/code&gt; (Directed Acyclic Graph).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DAG&lt;/code&gt; é o conceito central do sistema, essa estrutura armazena um conjunto de &lt;code&gt;tasks&lt;/code&gt; organizadas com suas dependências e relacionamentos que informam como e em qual ordem elas devem ser executadas.&lt;/p&gt;
&lt;p&gt;Abaixo segue um exemplo de &lt;code&gt;DAG&lt;/code&gt;&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;basic-dag.png&#34; style=&#34;width:40%&#34;&gt;
&lt;p&gt;No diagrama estão definidas 4 &lt;code&gt;tasks&lt;/code&gt;, A, B, C e D, as arestas informam a ordem em que devem ser executadas e as dependências entre elas.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DAG&lt;/code&gt; em si não se importa com qual é a responsabilidade de cada &lt;code&gt;task&lt;/code&gt;, trata-se apenas de como exectuá-las, a ordem de execução, frequência de execução, tempo limite para execução, etc. Em contrapartida, o corpo de uma &lt;code&gt;task&lt;/code&gt; descreve o que deve ser feito, seja buscar dados em um sistema externo, executar análises de dados, despertar ações em outros sistemas, etc.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-contexto.png&#34;
alt=&#34;diagrama contexto img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de contexto é apresentado como se dá a interação dos demais elementos com o Airflow.&lt;/p&gt;
&lt;p&gt;Primeiramente temos o usuário do sistema, ele é responsável por criar e cadastrar os &lt;code&gt;DAGs&lt;/code&gt; de seu interesse, além de agendar e monitorar a execução deles quando necessário. O Airlow disponibiliza diversas funcionalidades para que o usuário monitore a execução de &lt;code&gt;DAGs&lt;/code&gt;, sendo assim, é possível visualizar desde o código de cada &lt;code&gt;task&lt;/code&gt;, até o diagrama de Gantt com a duração do seu tempo de execução.&lt;/p&gt;
&lt;p&gt;Como é exibido no diagrama, o Aiflow também se comunica com o sistema de e-mail. Acontece que o usuário pode solicitar o recebimento de notificações a respeito das execuções dos seus &lt;code&gt;DAGs&lt;/code&gt; ou especificamente de uma &lt;code&gt;task&lt;/code&gt;, esses e-mails podem, por exemplo, ser enviados quando a execução de uma &lt;code&gt;task&lt;/code&gt; falha inúmeras vezes ou a execução de um &lt;code&gt;DAG&lt;/code&gt; por completo não foi bem sucedida.&lt;/p&gt;
&lt;p&gt;Por fim, existem os plugins para permitir a integração de funcionalidades ao Airflow. Desde &lt;code&gt;macros&lt;/code&gt; até &lt;code&gt;web views&lt;/code&gt; podem ser integrados e disponibilizados para o uso. Uma vez que o Airflow é um sistema muito generalista, utilizar plugins é uma maneira de personalizar e especificar as funcionalidades da ferramenta, além disso, ela possui vários componentes que podem ser reutilizados na construção de outros aplicativos.&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;O Airflow é uma plataforma gerenalista e por isso foi desenvolvida para se adequar aos diversos cenários de uso. Sendo assim, o Airflow pode ser executado de forma simples com seus módulos e configurações padrões, mas essa opção não proporciona todo o poder de processamento. No entanto, é possível utilizar configurações de maior complexidade para suportar subsistemas mais robustos, com maior capacidade de processamento e suporte a paralelismo.&lt;/p&gt;
&lt;p&gt;A documentação do sistema deixa explícito que o setup de execução deve depender das necessidades do usuário, mas também disponibiliza um setup default que entrega ao usuário todas as funcionalidades da ferramenta mas que ainda pode ser escalado se for necessário. Sendo assim, os containers do setup default serão explorados nesse post.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;diagrama-containers.png&#34; style=&#34;width:100%&#34;&gt;
&lt;p&gt;Como é possível visualizar no diagrama, o Airflow é composto por vários containers que executam de forma independente.&lt;/p&gt;
&lt;p&gt;O primeiro deles, é o &lt;code&gt;Web Server&lt;/code&gt;, construído em &lt;code&gt;Python&lt;/code&gt; utilizando o frameworker &lt;code&gt;Flask&lt;/code&gt; e o servidor web &lt;code&gt;Gunicorn&lt;/code&gt;. Esse container tem a responsabilidade de servir tanto as &lt;code&gt;views&lt;/code&gt; da interface web, como a &lt;code&gt;API&lt;/code&gt; que se comunica com o banco de dados.&lt;/p&gt;
&lt;p&gt;A interface web disponibiliza uma série de funcionalidades pra gerenciar as &lt;code&gt;tasks&lt;/code&gt;, solicitar dados do BD, monitorar e até iniciar a execução de &lt;code&gt;tasks&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As funcionalidades de monitoramento são atualizadas em tempo real de acordo com a execução das &lt;code&gt;tasks&lt;/code&gt;. A partir da interface é possível visualizar todos os &lt;code&gt;DAGs&lt;/code&gt; registrados, a representação em forma de árvore de um &lt;code&gt;DAG&lt;/code&gt; ao longo do tempo de execução, estado de execução atual de um &lt;code&gt;DAG&lt;/code&gt;, estatísticas do tempo de execução de uma &lt;code&gt;task&lt;/code&gt;, etc. Além disso, o usuário pode ativar o recebimento de notificações a respeito das execuções de &lt;code&gt;tasks&lt;/code&gt; por email, como dito no tópico Contexto.&lt;/p&gt;
&lt;p&gt;Algumas das principais operações que a API disponibiliza são:&lt;/p&gt;
&lt;p&gt;Recupera a lista de metadados das execuções de um &lt;code&gt;DAG&lt;/code&gt; específico&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /dags/&amp;lt;dag_id&amp;gt;/dag_runs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inicia a execução de um &lt;code&gt;DAG&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /dags/&amp;lt;dag_id&amp;gt;/dag_runs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Recupera um JSON com todas as variávies de uma task&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /dags/&amp;lt;dag_id&amp;gt;/tasks/&amp;lt;task_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Exclui todos os metadados do BD relacionados à um &lt;code&gt;DAG&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE /dags/&amp;lt;dag_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Scheduler&lt;/code&gt; é outro container presente no Airflow, tem como responsabilidade principal monitorar todas as &lt;code&gt;tasks&lt;/code&gt; e &lt;code&gt;DAGs&lt;/code&gt;, e enviá-las para a fila de execução quando suas dependências são concluídas. No setup padrão, também tem a responsabilidade de executar &lt;code&gt;tasks&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Mais especificamente, o &lt;code&gt;Scheduler&lt;/code&gt; é um processo multi-thread iniciado via CLI que monitora e permanece sincronizado com o BD, ou seja, periodicamente checa o BD e altera o estado daquelas tarefas que possuem suas dependências concluídas, essa mudança de estado informa que as tarefas estão prontas para serem executadas. O intervalo de checagem do BD é setado pelo usuário nas configurações de um &lt;code&gt;DAG&lt;/code&gt;, podendo ser completamente personalizado.&lt;/p&gt;
&lt;p&gt;Apesar do &lt;code&gt;Scheduler&lt;/code&gt; existir, o usuário também pode alterar o estado de uma tarefa via interface gráfica.&lt;/p&gt;
&lt;p&gt;Observe que o &lt;code&gt;Scheduler&lt;/code&gt; tem como responsabilidade principal apenas alocar as tarefas para serem executadas mas não por executá-las diretamente. No setup default do Aiflow, o módulo de execução de tarefas, chamado &lt;code&gt;Executor&lt;/code&gt;, é um subcomponente do &lt;code&gt;Scheduler&lt;/code&gt; e por isso ele e suas funcionalidades serão abordadas no tópico Componentes.&lt;/p&gt;
&lt;p&gt;Esses dois componentes, &lt;code&gt;Scheduler&lt;/code&gt; e &lt;code&gt;Executor&lt;/code&gt;, têm responsabilidades distintas e bem definidas, mas no setup default convivem no mesmo container como um único serviço apenas para simplificar o sistema. No entanto, em contextos mais complexos, o &lt;code&gt;Executor&lt;/code&gt; pode ser implantado como outro serviço.&lt;/p&gt;
&lt;p&gt;Por fim, existe o container &lt;code&gt;Database&lt;/code&gt;, ou como é chamado na documentação, &lt;code&gt;Metadata Database&lt;/code&gt;, é utilizado pelo &lt;code&gt;Web Server&lt;/code&gt; e &lt;code&gt;Scheduler&lt;/code&gt; para armazenar todos os metadados das &lt;code&gt;tasks&lt;/code&gt; e &lt;code&gt;DAGs&lt;/code&gt;. Como é exibido no diagrama, é um banco de dados relacional e além de armazenar metadados, também armazena dados dos usuários, variáveis de conexões e variáveis do sistema.&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;img class=&#34;center&#34; src=&#34;diagrama-componentes.png&#34; style=&#34;width:100%&#34;&gt;
&lt;p&gt;Como é possível visualizar no diagrama de componentes, cada container tem seus componentes com responsabilidades bem definidas.&lt;/p&gt;
&lt;p&gt;Começando com o container &lt;code&gt;Web Server&lt;/code&gt;, ele possui 7 componentes independentes que interagem entre si para fornecer suas funcionalidades ao usuário.&lt;/p&gt;
&lt;p&gt;O usuário interage diretamente com o componente &lt;code&gt;Web page API&lt;/code&gt;, que tem como responsabilidade servir as páginas da interface web.&lt;/p&gt;
&lt;p&gt;O Airflow é conhecido por possuir uma rica interface, com suporte a diversas visualizações gráficas de seus &lt;code&gt;DAGs&lt;/code&gt;, por isso, &lt;code&gt;Web Page API&lt;/code&gt; se comunica diretamente com o &lt;code&gt;Componente de charts&lt;/code&gt;, responsável por criar os gráficos que integram as páginas web, os gráficos são gerados utilizando a biblioteca nvD3.&lt;/p&gt;
&lt;p&gt;Além disso, para que a &lt;code&gt;Web Page API&lt;/code&gt; acesse o banco de dados, ele utiliza a &lt;code&gt;API Rest&lt;/code&gt;, que em conjunto com o &lt;code&gt;Controlador de dados&lt;/code&gt;, é responsável por buscar e criar dados a respeito das &lt;code&gt;tasks&lt;/code&gt; e &lt;code&gt;DAGs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Existe também o componente &lt;code&gt;Gerenciador de segurança&lt;/code&gt;, que em conjunto com &lt;code&gt;Gerenciador de usuário&lt;/code&gt;, é responsável por gerenciar todas as autenticações e autorizações da aplicação.&lt;/p&gt;
&lt;p&gt;Para finalizar, o &lt;code&gt;Gerenciador de plugins&lt;/code&gt; é responsável por adicionar novas funcionalidades à aplicação.&lt;/p&gt;
&lt;p&gt;O outro container, &lt;code&gt;Scheduler&lt;/code&gt;, possui 3 componentes. O principal deles, o &lt;code&gt;Escalonador de tasks&lt;/code&gt;, em conjunto com o &lt;code&gt;Controlador de dados&lt;/code&gt;, é responsável por monitorar o Banco de Dados e alterar o estado de &lt;code&gt;tasks&lt;/code&gt; quando elas estão prontas para serem executadas. Além disso, é responsabilidade desse componente enviar um sinal para que o &lt;code&gt;Executor&lt;/code&gt; inicie seu trabalho.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;Executor&lt;/code&gt; tem como responsabilidade executar &lt;code&gt;tasks&lt;/code&gt;. Esse componente, também utiliza o &lt;code&gt;Controlador de dados&lt;/code&gt;, pois é sua responsabilidade ao finalizar a execução de uma &lt;code&gt;task&lt;/code&gt; alterar o estado da mesma, seja este &lt;code&gt;failed&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt;, &lt;code&gt;retry&lt;/code&gt;, etc.&lt;/p&gt;
&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h2&gt;
&lt;p&gt;Como já foi abordado nesse post, o Airflow possui dois dados principais, &lt;code&gt;DAGs&lt;/code&gt; e &lt;code&gt;Tasks&lt;/code&gt;, nesse tópico será abordado o diagrama dinâmico de uma &lt;code&gt;task&lt;/code&gt;, uma vez que os estados de um &lt;code&gt;DAG&lt;/code&gt; gira em torno dos estados de suas &lt;code&gt;tasks&lt;/code&gt;.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;diagrama-info.png&#34; style=&#34;width:100%&#34;&gt;
&lt;p&gt;O diagrama ilustra os principais estados que uma &lt;code&gt;task&lt;/code&gt; pode atingir. Uma vez que tanto o &lt;code&gt;Web server&lt;/code&gt; como o &lt;code&gt;Scheduler&lt;/code&gt; podem alterar o estado de uma &lt;code&gt;task&lt;/code&gt;, é importante detalhar qual módulo é reponsável pela transição de cada estado.&lt;/p&gt;
&lt;p&gt;Ao ser criado um &lt;code&gt;DAG&lt;/code&gt;, o &lt;code&gt;Web server&lt;/code&gt; é responsável por alterar o estado de todas as suas &lt;code&gt;tasks&lt;/code&gt; para &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;Scheduler&lt;/code&gt; é responsável por alterar o estado das &lt;code&gt;tasks&lt;/code&gt; que estão prontas para serem executadas para &lt;code&gt;Scheduled&lt;/code&gt;. Além disso, ao enviá-las para fila de execução, realiza outra alteração para &lt;code&gt;Queued&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;Executor&lt;/code&gt; ao receber uma &lt;code&gt;task&lt;/code&gt; altera seu estado para &lt;code&gt;Running&lt;/code&gt; e finalmente, ao finalizar sua execução altera para &lt;code&gt;Success&lt;/code&gt; ou &lt;code&gt;Failed&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Existem outros estados a depender da configuração do usuário, é possível por exemplo, configurar que a execução de uma &lt;code&gt;task&lt;/code&gt; seja repetida em caso de falha, utilizando o estado &lt;code&gt;Retry&lt;/code&gt;, eles estão descritos na &lt;a href=&#34;https://airflow.apache.org/docs/apache-airflow/stable/index.html&#34;&gt;documentação&lt;/a&gt; do Airflow.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Essa descrição arquitetural não foi submetida ao Github do projeto devido ao idioma utilizado, pois a documentação do Airflow é feita em inglês.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do Mockito</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/mockito/</link>
       <pubDate>Fri, 13 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/mockito/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Luiz Bonfim Vieira Costa Neto&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 119210966&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:luiz.bonfim.neto@ccc.ufcg.edu.br&#34;&gt;luiz.bonfim.neto@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/mockito/mockito&#34;&gt;https://github.com/mockito/mockito&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----mockito&#34;&gt;Descrição Arquitetural &amp;ndash; Mockito&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;mockito-logo.png&#34; alt=&#34;Logo Mockito&#34;&gt;
Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/mockito/mockito&#34;&gt;Mockito&lt;/a&gt;. As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-mockito&#34;&gt;Descrição Geral sobre o Mockito&lt;/h2&gt;
&lt;p&gt;O Mockito é um framework bastante popular para a criação de mocks em testes de unidade de projetos  desenvolvidos em Java. O uso de mocks adiciona funcionalidades interessantes aos testes de unidade, por ser possível simular a execução de uma implementação de uma dependência externa, para vários cenários distintos e de forma dinâmica, mantendo assim os testes com a agilidade e modularidade de um teste de unidade.&lt;/p&gt;
&lt;h2 id=&#34;objetivo&#34;&gt;Objetivo&lt;/h2&gt;
&lt;p&gt;No desenvolvimento de softwares, os testes de unidade são fundamentais para indicar se pequenas seções de código são adequadas às necessidades, bem como tornar os sistemas mais manuteníveis e menos susceptíveis a inserção de bugs durante expansões ou refatorações. Em projetos Java, a unidade de código que buscamos testar é geralmente uma Classe.&lt;/p&gt;
&lt;p&gt;Em testes de unidade, é desejável validar a funcionalidade de um objeto em específico. Porém, na maioria dos casos esses objetos possuem dependência de outros objetos externos, e é neste ponto que os mocks são fundamentais. Com os mocks, podemos simular o comportamento das dependências segundo a regra de negócio do sistema, e testar se a classe em questão tem a funcionalidade adequada ao contexto na qual está inserida.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Por ser um framework de testes em Java, o Mockito é direcionado para o uso de desenvolvedores de software que trabalham nesta linguagem. O Mockito atua em cooperação com o JUnit, que é um dos frameworks para a construção de testes automatizados mais frequentemente utilizado em projetos Java.&lt;/p&gt;
&lt;p&gt;Com o JUnit, o desenvolvedor consegue construir os testes que visam verificar o funcionamento de um determinado escopo, e com o auxílio do Mockito é possível isolar o comportamento daquela classe de suas dependências, definindo de forma dinâmica como essas dependências externas se comportam em cenários de teste variados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Por se tratar de um framework que auxilia no desenvolvimento dos testes, o Mockito é adicionado como dependência na aplicação Java que está em construção. O desenvolvedor define na classe de teste o Runner de acordo com o framework de testes a ser utilizado (por exemplo, o JUnit) e, então, o módulo de integração irá realizar a configuração para integrar o Mockito ao framework de testes.&lt;/p&gt;
&lt;p&gt;Já no escopo dessa classe de testes, o desenvolvedor irá definir quais dependências da classe em questão terão seu comportamento simulado através do Mockito. Em geral, essa definição se dá através de anotações que se encontram no módulo core do Mockito. O Desenvolvedor também irá definir o comportamento em si dos métodos das dependências mockadas.&lt;/p&gt;
&lt;p&gt;Na execução do teste, o Core do mockito notifica o módulo de Invocation, que irá monitorar a invocação dos métodos das dependências mocadas, bem como irá executar os comportamentos pré-definidos pelo desenvolvedor na chamada desses métodos, ou, a depender do caso, executar o método real daquela dependência. Este módulo também é responsável por realizar a verificação dos argumentos e retornos dos métodos mocados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers-mockito.png&#34; alt=&#34;Diagrama de Containers&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Em termos de configuração, o módulo de integração com o JUnit possui basicamente o JUnitRunner, que configura o runner do mockito para se integrar ao JUnit, e o JUnitRuler, que define rules de atuação para o Mockito.&lt;/p&gt;
&lt;p&gt;No Mockito Core, podem-se definir basicamente se temos um Mock ou um Spy. Ambos são mocks implementados pelo Mockito, porém, diferem na invocação dos métodos. Para um Mock, todos os métodos utilizados pela unidade de teste devem ter seu comportamento descrito explicitamente. Já pra os Spys, caso este comportamento não seja definido explicitamente pelo desenvolvedor, será considerado a chamada do método real daquela classe. Em geral, definimos como Spy a classe foco dos testes, e todas as suas dependências são definidas como Mock. O componente responsável pela instanciação e criação dos mocks em tempo de execução é o Mock Creator.&lt;/p&gt;
&lt;p&gt;O Mockito core notifica o módulo de Invocation através de um Listener, que monitora a chamada dos métodos das dependências. Esse Listener faz uso de um Handler, que lida de fato com a chamada dos métodos, utilizando o componente Verifier para verificar se, logicamente, os argumentos e retornos dos métodos estão de acordo com o que está definido na classe, e invoca o componente de Stubbing, que de fato irá executar o comportamento pré-definido pelo desenvolvedor para os métodos, ou, em caso de ser um Spy, irá executar a implementação real daquele método.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;O Diagrama de informação abaixo demonstra o ciclo de vida de um Mock na execução de um teste. Primeiramente, esse mock é pré-configurado pelo desenvolvedor. Durante a execução dos testes, as dependências mocadas são isntanciadas e, no fluxo de execução do teste, têm seus métodos invocados. São verificados então se há Stubbings definidos para aqueles métodos, para realizar a execução simulada definida pelo desenvolvedor. Caso não haja um Stubbing definido para o método, existe a possibilidade de ser um Spy mock, e, dessa forma, realizar a execução real do método. Caso contrário, o mockito lançará uma exceção. Após a execução de todos os passos e verificação das assertivas, o teste é finalizado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;info.png&#34; alt=&#34;Máquina de estados do mock&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento Arquitetural do Asperathos</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/asperathos/</link>
       <pubDate>Fri, 13 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/asperathos/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Diego Alves Gama.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110223&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:diego.gama@ccc.ufcg.edu.br&#34;&gt;diego.gama@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ufcg-lsd/asperathos&#34;&gt;https://github.com/ufcg-lsd/asperathos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----asperathos&#34;&gt;Descrição Arquitetural &amp;ndash; Asperathos&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/ufcg-lsd/asperathos&#34;&gt;Asperathos&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-asperathos&#34;&gt;Descrição Geral sobre o Asperathos&lt;/h2&gt;
&lt;p&gt;O Asperathos é uma plataforma de controle e orquestração para aplicações replicáveis em ambientes de nuvem (como AKS, AWS ou GKE). A sua principal função é controlar a replicação de uma aplicação na infraestrutura de nuvem escolhida, de maneira a equilibrar métricas configuradas nele, sejam elas de &lt;em&gt;Quality of Service&lt;/em&gt; (QoS) geral ou específicas da aplicação.&lt;/p&gt;
&lt;p&gt;Por exemplo, para um software executando na AWS, e que analisa remessas de exames médicos com prazos, o Asperathos pode controlar as réplicas do software de forma a atender à demanda dentro do &lt;em&gt;deadline&lt;/em&gt;, mas também de maneira a minimizar o custo da infraestrutura.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Asperathos é imerso em um contexto naturalmente de nuvem. Seu objetivo é atender às necessidades de controle de pessoas que desejam que suas aplicações sejam controladas para garantia de QoS, e apenas para aplicações replicáveis. Isto é, aplicações que ou sejam &lt;em&gt;stateless&lt;/em&gt; ou cujo estado interno não atrapalhe replicação automática de si mesma.&lt;/p&gt;
&lt;p&gt;Assim, o Asperathos é usado por um cliente interessado através de algum software que o utilize, e que pode submeter um arquivo especificando o job e como ele acontecerá. Aqui, um job representa uma carga de trabalho a ser executada em &lt;strong&gt;batch&lt;/strong&gt; (uma carga por job, com &lt;em&gt;deadline&lt;/em&gt;) ou em &lt;strong&gt;streaming&lt;/strong&gt; (em sequência sob demanda do cliente, por tempo indefinido).&lt;/p&gt;
&lt;p&gt;Após isso, o Asperathos recebe o job, e começa a se comunicar com algum cluster Kubernetes acessível para controlar a replicação. O Kubrentes e aplicações auxiliares do Asperathos criadas nele enviam periódicas informações sobre o job e sobre a aplicação, e utilizando elas o Asperathos decide se deve haverá &lt;strong&gt;scale-up&lt;/strong&gt; (aumento de réplicas) ou &lt;strong&gt;scale-down&lt;/strong&gt; (diminuição de réplicas) de forma a gerir QoS e economia de recursos, e gerencia essas aplicações auxiliares.&lt;/p&gt;
&lt;p&gt;É também possível que o cliente utilize suas próprias implementações específicas para os componentes do Asperathos, mas esses detalhes são mais profundos e serão tratados em seguida. O diagrama abaixo ilustra essa interação entre os contextos&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto_asperathos.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Asperathos tem quatro principais containers que compõem a aplicação. Há o &lt;strong&gt;manager&lt;/strong&gt;, o &lt;strong&gt;controller&lt;/strong&gt;, o &lt;strong&gt;monitor&lt;/strong&gt; e por fim o &lt;strong&gt;visualizer&lt;/strong&gt; que é opcional e não é necessário para o funcionamento básico do Asperathos. Cada um deles é implementado em Python e containerizado em Docker, e todos se comunicam entre si através de suas respectivas API REST. Entraremos em detalhes neles abaixo.&lt;/p&gt;
&lt;p&gt;Além dos containers principais, há também três containers auxiliares que são criados no cluster Kubernetes onde a aplicação do usuário executará. Esses microsserviços são: um &lt;strong&gt;Banco de Dados de Série Temporal&lt;/strong&gt; (InfluxDB por padrão), uma &lt;strong&gt;Fila de Mensagens&lt;/strong&gt; (Redis por padrão), e um &lt;strong&gt;Dashboard Analítico&lt;/strong&gt; (opcional e Grafana por padrão).&lt;/p&gt;
&lt;p&gt;O objetivo do Banco de Dados é armazenar métricas sensíveis ao tempo; o da Fila de Mensagens é de organizar os itens de trabalho e seus status (prontos, em processamento e processados); e por fim o do Dashboard Analítico opcional é prover uma visualização conforme é alimentado pelo Visualizer.&lt;/p&gt;
&lt;p&gt;Esses containers são importantes para gerenciar dados e métricas que serão posteriormente utilizados pelos containers principais do Asperathos. O diagrama a seguir ilustra como os containers se relacionam.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers_asperathos.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;manager&#34;&gt;Manager&lt;/h4&gt;
&lt;p&gt;O manager é o container mais complexo, pois gerencia todos os outros. Ele é o único container que se comunica diretamente com o usuário, e delega tarefas para os outros containers a depender das rotas acessadas em sua API REST.&lt;/p&gt;
&lt;p&gt;Quando o manager recebe um Job por parte do cliente, ele utiliza a API do Kubernetes para acessar o cluster (cujas credenciais foram passadas na sua configuração) e lá inicia os microsserviços auxiliares, passa configurações relevantes para os outros containers e cria o KubeJob para a aplicação do usuário. O Job Kubernetes ou KubeJob é um tipo de recurso Kubernetes que permite que a aplicação do usuário só termine quando finalize toda a carga de trabalho. Assim, o Job executa e o Asperathos pode controlar seu escalonamento.&lt;/p&gt;
&lt;p&gt;Os endpoints do manager são estes abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/submissions&lt;/code&gt;, &lt;strong&gt;POST&lt;/strong&gt; com JSON do Job e que retorna o id do Job.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/submissions/:id/stop&lt;/code&gt;, &lt;strong&gt;PUT&lt;/strong&gt; para parar o Job com aquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/submissions&lt;/code&gt;, &lt;strong&gt;GET&lt;/strong&gt; que lista todos os Job já submetidos.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/submissions/:id&lt;/code&gt;, &lt;strong&gt;GET&lt;/strong&gt; que retorna status do Job com aquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/submissions/:id/log&lt;/code&gt;, &lt;strong&gt;GET&lt;/strong&gt; que retorna os logs daquele Job.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;monitor&#34;&gt;Monitor&lt;/h4&gt;
&lt;p&gt;O monitor é um container que observa o progresso do Job conforme a aplicação lê, processa e conclui itens de trabalho. Através dessas métricas de progresso ele gera outras métricas, as quais ele armazena no Banco de Dados de Série Temporal.&lt;/p&gt;
&lt;p&gt;Os endpoints do monitor são estes abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/monitoring/:app_id&lt;/code&gt;, &lt;strong&gt;POST&lt;/strong&gt; com JSON de configurações para monitorar o Job daquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/monitoring/:app_id/stop&lt;/code&gt;, &lt;strong&gt;PUT&lt;/strong&gt; para parar o Job com aquele id.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;
&lt;p&gt;O controller é um container que lê métricas do Banco de Dados periodicamente e as utiliza para decidir se deve atuar ou não. Ele atua se comunicando com o Kubernetes para aumentar ou diminuir uma certa quantidade de réplicas da aplicação.&lt;/p&gt;
&lt;p&gt;Os endpoints do controller são estes abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/setup&lt;/code&gt;, &lt;strong&gt;POST&lt;/strong&gt; com JSON contendo as restrições de recursos que as réplicas da aplicação do cliente podem usar.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/scailing/:app_id&lt;/code&gt;, &lt;strong&gt;POST&lt;/strong&gt; com JSON de configurações para que o controller atue no Job com aquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/scailing/:app_id/stop&lt;/code&gt;, &lt;strong&gt;PUT&lt;/strong&gt; para que o controller pare de atuar naquele Job com aquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/scaling&lt;/code&gt;, &lt;strong&gt;GET&lt;/strong&gt; que retorna o status atual detalhado do controller.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;visualizer&#34;&gt;Visualizer&lt;/h4&gt;
&lt;p&gt;O visualizer é um container que gerencia o Dashboard Analítico, e que lê periodicamente o Banco de Dados para alimentar o Dashboard com as métricas. Ele é opcional.&lt;/p&gt;
&lt;p&gt;Os endpoints do visualizer são estes abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/visualizing&lt;/code&gt;, &lt;strong&gt;POST&lt;/strong&gt; com JSON contendo configurações para que o visualizer inicie a visualização de um Job.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/visualizing/:id/stop&lt;/code&gt;, &lt;strong&gt;PUT&lt;/strong&gt; para que o visualizer pare a visualização no Job com aquele id.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/visualizing/:id&lt;/code&gt;, &lt;strong&gt;GET&lt;/strong&gt; que retorna a URL do Dashboard.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Todos os containers do Asperathos seguem uma arquitetura de plugin. A maior implicação disso, é que não há detalhes muito minunciosos de implementação para cada um, visto que são feitos para comportar diversas possibilidades de plugin. Eles, entretanto, devem seguir responsabilidades bem definidas, como falamos na seção anterior, mas que separaremos aqui componente a componente de cada container.&lt;/p&gt;
&lt;p&gt;Cada container tem dois componentes em comum: a &lt;strong&gt;API REST&lt;/strong&gt; (como discutimos) e o &lt;strong&gt;gerente de plugins&lt;/strong&gt;. O gerente de plugins é o responsável por instalar as opcões de plugin e decidir qual usar de acordo com a configuração do Job. Abaixo, estão os componentes diferenciais de cada um.&lt;/p&gt;
&lt;h4 id=&#34;manager-1&#34;&gt;Manager&lt;/h4&gt;
&lt;p&gt;Como vimos, o Manager coordena os outros containers e também o Job. Ele consegue fazer isso dividindo suas responsabilidades entre três componentes: o &lt;strong&gt;executor de Job&lt;/strong&gt;, o &lt;strong&gt;gerente&lt;/strong&gt; e o &lt;strong&gt;componente de persistência&lt;/strong&gt;. Cada componente desses é um plugin.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;executor de Job&lt;/strong&gt; é o responsável por se comunicar com a API da infraestrutura (e.g. Kubernetes) para poder criar e configurar as aplicações auxiliares e a aplicação do cliente no cluster, bem como inicializar a carga de trabalho na Fila de Mensagens para que o Job possa começar.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;gerente&lt;/strong&gt; é o responsável por gerenciar os outros containers em si. Ele repassa as configurações do Job que são específicas a cada um, e os atualiza sempre que um Job novo é inciado e também quando é terminado. Ele faz isso se comunicando com a API REST de cada um.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;componente de persistência&lt;/strong&gt; não tem um nome específico, mas é responsável por persistir dados do Job em um banco local SQLite. Dessa maneira além de salvar dados sobre o Job atual, o Manager consegue manter histórico dos Jobs anteriores.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componente_manager_asperathos.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;monitor-1&#34;&gt;Monitor&lt;/h4&gt;
&lt;p&gt;Já o Monitor tem responsabilidade de coletar as métricas e publicá-las no BD. Entretanto, o Monitor não possui diversos plugins nele, apenas um. A lógica de como o Monitor lida com tudo pode variar bastante de acordo com a implementação de plugin dele, mas é indicado que além de coletar e publicar ele faça um processamento das métricas. Isso é útil para converter, por exemplo, a contagem de itens de trabalho processados em um fluxo de processamento em itens por segundo.&lt;/p&gt;
&lt;p&gt;Assim, nós teríamos três componentes, os quais devem fazer parte do mesmo plugin.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;coletor&lt;/strong&gt; é responsável pela coleta. Não só pegar as métricas, como também decidir de onde elas vêm. Por padrão utilizamos apenas a Fila de Mensagens, mas outras fontes podem ser utilizadas. Por exemplo: uso de CPU/RAM dos nós do cluster, coletados através da API do Kubernetes.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;processador&lt;/strong&gt; utiliza as métricas para produzir novas ou refiná-las. Enquanto o coletor lê a quantidade de itens produzida, o processador é o responsável por utilizar isso e produzir a métrica de fluxo de itens por segundo. Ele pode também deduzir as distâncias de tempo entre cada item.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;publicador&lt;/strong&gt; utiliza as métricas refinadas do processador para publicá-las no Banco de Dados de Série Temporal. Essa função é simples, e só precisa ser reimplementada quando o Banco de Dados é diferente. Por padrão, é o InfluxDB.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componente_monitor_asperathos.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;controller-1&#34;&gt;Controller&lt;/h4&gt;
&lt;p&gt;O Controller é responsável por decidir quando, como e com qual intensidade atuar no escalonamento das réplicas, baseado em métrias lidas no BD, e também aplicar a decisão. Ele divide essas tarefas em três componentes: o &lt;strong&gt;controlador&lt;/strong&gt;, o &lt;strong&gt;atuador&lt;/strong&gt; e o &lt;strong&gt;coletor&lt;/strong&gt;. Cada um deles é um plugin.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;controlador&lt;/strong&gt; é o componente de inteligência, e é responsável por decidir baseado nas métricas. Esse é o plugin de maior impacto do container e talvez da aplicação, pois afeta diretamente o progresso do job.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;atuador&lt;/strong&gt; é responsável por se conectar com a interface da estrutura (i.e. API do Kubernetes) e aplicar as decisões do controlador. Essa função é simples, e só precisa ser reimplementada quando a Infraestrutura é diferente.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;coletor&lt;/strong&gt; é quem lê as métricas do Banco de Dados de Série Temporal. Essa função é simples, e só precisa ser reimplementada quando o Banco de Dados é diferente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componente_controller_asperathos.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;visualizer-1&#34;&gt;Visualizer&lt;/h4&gt;
&lt;p&gt;O Visualizer, sendo responsável por gerir o Dashboard Analítico, é bem separado da lógica normal. Ele não possui componentes bem definidos e também possui apenas um plugin, que é o responsável por tudo.&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O Asperathos tem consigo diversas informações que trafegam. Desde as configurações iniciais em JSON, até as métricas lidas pelos componentes. O essencial de se entender para um usuário do sistema, entretanto, é sobre o processamento do Job.&lt;/p&gt;
&lt;p&gt;Uma vez que o Job é submetido, a carga de trabalho é preparada na Fila de Mensagens. Nesse componente estão três filas: fila &lt;em&gt;main&lt;/em&gt;, &lt;em&gt;processing&lt;/em&gt; e &lt;em&gt;results&lt;/em&gt;. Essas filas representam os estados de cada item alocado nela, explicremos mais adiante.&lt;/p&gt;
&lt;p&gt;Inicialmente, se o Job for do modo &lt;em&gt;batch&lt;/em&gt; toda a carga é submetida para a fila &lt;em&gt;main&lt;/em&gt; de uma única vez. Caso o Job seja do tipo &lt;em&gt;streaming&lt;/em&gt;, o software cliente é quem tem responsabilidade de enviar os itens de trabalho à Fila de Mensagens, e então a fila &lt;em&gt;main&lt;/em&gt; recebe itens indefinidamente enquanto o Job não for finalizado.&lt;/p&gt;
&lt;p&gt;Assim que o Job inicia e a aplicação do cliente está pronta para processar itens, ela começa a ler itens da fila &lt;em&gt;main&lt;/em&gt;. O item é lido e passado para a fila &lt;em&gt;processing&lt;/em&gt;, onde ficará até ser finalizado. Uma vez que o item é finalizado, ele é removido, e o output do processamento é salvo na fila &lt;em&gt;results&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Após se passar um tempo, determinado pelo cliente, com um item parado na fila &lt;em&gt;processing&lt;/em&gt; ocorre um timeout. É então considerado que essa réplica da aplicação do cliente bloqueou em alguma das suas tarefas. O item é então retornado para o começo da fila &lt;em&gt;main&lt;/em&gt;, e quando o cliente bloqueado finalizar ele não será capaz de publicar seus resultados à fila &lt;em&gt;results&lt;/em&gt;, sendo forçado a passar para um próximo item na fila &lt;em&gt;main&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O diagrama de informação abaixo ilustra essa mudança de estado de um item conforme ele muda de fila.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao_asperathos.png&#34; alt=&#34;fig6&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Foi feito um PR contendo os diagramas de contexto, container e informação. Como o repositório já possui documentação, a adição foi pouca para que os diagramas coubessem de maneira a agregar informação. Além disso, visto que a documentação foi produzida em Inglês no repositório, os diagramas tiveram de ser traduzidos.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ufcg-lsd/asperathos/pull/11&#34;&gt;https://github.com/ufcg-lsd/asperathos/pull/11&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do JupyterLab</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jupyter-lab/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jupyter-lab/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Helena Mylena Cunha Dantas.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210323&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:helena.dantas@ccc.ufcg.edu.br&#34;&gt;helena.dantas@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/jupyterlab/jupyterlab&#34;&gt;https://github.com/jupyterlab/jupyterlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----ambiente-extensível-do-jupyter-notebook-para-computador&#34;&gt;Descrição Arquitetural &amp;ndash; Ambiente extensível do Jupyter Notebook para computador.&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido na disciplina de Arquitetura de Software da UFCG e descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/jupyterlab/jupyterlab&#34;&gt;JupyterLab&lt;/a&gt;. A descrição é baseada no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-jupyterlab&#34;&gt;Descrição Geral sobre o JupyterLab&lt;/h2&gt;
&lt;p&gt;O JupyterLab é a uma interface de usuário para o Project Jupyter, que oferece todos os blocos de construção familiares do Notebook Jupyter clássico (notebook, terminal, editor de texto, navegador de arquivos, saídas ricas, etc.) em uma interface de usuário flexível e poderosa.&lt;/p&gt;
&lt;h2 id=&#34;o-ambiente-extensível-do-jupyter-notebook-para-computador&#34;&gt;O ambiente extensível do Jupyter Notebook para computador&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O objetivo desse projeto é implementar uma interface para computador que permita ao usuário trabalhar de forma flexível, integrada e extensível com documentos, blocos de notas Jupyter , editores de texto, terminais e componentes.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O JupyterLab permitirá que vários documentos e atividades sejam organizados um ao lado do outro na área de trabalho fazendo uso de guias e divisores. Além disso, permitirá novos fluxos de trabalho interativos.
Também será oferecido um modelo unificado para visualizar e manipular formatos de dados e, com isso, serão compreendidos muitos formatos de arquivo, podendo também exibir uma rica saída de kernel nesses formatos.
O usuário poderá personalizar sua experiência através de atalhos de teclados personalizáveis e com as extensões do JupyterLab para aprimorar qualquer parte do JupyterLab, incluindo novos temas, editores de arquivo e componentes personalizados.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O JupyterLab é composto de duas partes principais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Código base: Um package npm que possui a maior parte do código base do projeto.&lt;/li&gt;
&lt;li&gt;Jupyterlab: compreende o código Python para o projeto, incluindo a extensão do servidor de notebook, interface de linha de comando do JupyterLab, pontos de entrada e testes Python. Possui os recursos JavaScript finais construídos que são distribuídos com o pacote Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O package npm contém vários subpacotes em TypeScript que são inclusos no package em Python. É nele que está grande parte do código fonte.
Já o packagem em Python contém o servidor e distribui o código TypeScript.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O JupyterLab possui os seguintes sistemas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Aplications&lt;/li&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;li&gt;Kernel&lt;/li&gt;
&lt;li&gt;Servers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O processo inicia quando o usuário abre um notebook no Jupyterlab. A aplicação envia uma requisição ao servidor, se comunica com a API. A API irá enviar uma mensagem ao Kernel para que ocorra a interpretação do código e retornará a mensagem para a API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Há três principais componentes na aplicação do jupyterlab:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jupyter_console: é o terminal da aplicação jupyter&lt;/li&gt;
&lt;li&gt;qtconsole: é um aplicativo Qt para computação interativa com saída rica&lt;/li&gt;
&lt;li&gt;notebook&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;Como já visto antes, o jupyterlab permite que você trabalhe com documentos e atividades como blocos de notas Jupyter , editores de texto, terminais e componentes personalizados de maneira flexível, integrada e extensível.&lt;/p&gt;
&lt;p&gt;As etapas para criar um documento no jupyterlab são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iniciar o jupyterlab;&lt;/li&gt;
&lt;li&gt;Escolher o kernel;&lt;/li&gt;
&lt;li&gt;Instalar bibliotecas;&lt;/li&gt;
&lt;li&gt;Inserir código/texto;&lt;/li&gt;
&lt;li&gt;Executar o arquivo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do pdf-box</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/pdfbox/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/pdfbox/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Marcelo Gabriel dos Santos Queiroz Vitorino.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116211290&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:marcelo.vitorino@ccc.ufcg.edu.br&#34;&gt;marcelo.vitorino@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/apache/pdfbox&#34;&gt;https://github.com/apache/pdfbox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---pdf-box&#34;&gt;Descrição Arquitetural - pdf-box&lt;/h1&gt;
&lt;p&gt;Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-pdf-box&#34;&gt;Descrição geral sobre o pdf-box&lt;/h2&gt;
&lt;p&gt;O pdf-box é uma biblioteca java para trabalhar com documentos PDF. O Projeto permite a criação de novos PDF documentos e a manipulação de documentos existentes.&lt;/p&gt;
&lt;h2 id=&#34;o-módulo-apache-pdfbox---printpdf&#34;&gt;O módulo Apache PDFBox - PrintPDF&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Essa descrição se propõe em apresentar uma especificação da manipulação de arquivos PDF através da opção de imprimir um PDF com o PDFBox.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é apresentado o diagrama de contexto do sistema. Nele, é possível analisar a interação entre o (&lt;a href=&#34;https://picocli.info/apidocs/picocli/CommandLine.html&#34;&gt;Picocli&lt;/a&gt;, &lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/awt/print/PrinterJob.html&#34;&gt;JavaPrint&lt;/a&gt;) e o programa de linha de comando para impressão em pdf.&lt;/p&gt;
&lt;p&gt;Após a interação, o programa imprime o pdf no sistema de arquivos ou na impressora setada pelo usuário padrão.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;Diagrama de contexto - PDFBox&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a aplicação Signal:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;conteiners.png&#34; alt=&#34;Diagrama de container - PDFBox&#34;&gt;&lt;/p&gt;
&lt;p&gt;É possível identificar a utilização do terminal para permitir a inserção dos dados pelo usuário e realizar as requisições de sistema para a api.&lt;/p&gt;
&lt;p&gt;Todas as informações de parâmetros de impressão são armazenadas em memória.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;Diagrama de componentes - PDFBox&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama, tem-se alguns dos principais componentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;AccessPermission:&lt;/em&gt; Responsável por descriptografar os arquivos pdf e permitir privilégios de acesso;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;PrintJob:&lt;/em&gt; Responsável por gerenciar as ações de impressão de arquivos;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;PDFPageable:&lt;/em&gt; Responsável por setar as propriedades de impressão, tais como nome de impressora e rotação da página;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui é possível observar as interações que a in-memory representação do PDF document faz. Apresentando que este pode ter uma impressão associada, tem exatamente uma PDFPageable configurada e pelo menos uma permissão de acesso.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Diagrama ER - PDFBox&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição Arquitetural Animavita</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/animavita/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/animavita/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Arthur Stevam de Azevêdo Costa&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 119210939&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:arthur.stevam.costa@ccc.ufcg.edu.br&#34;&gt;arthur.stevam.costa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/animavita/animavita&#34;&gt;https://github.com/animavita/animavita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquiterual---animavita&#34;&gt;Descrição Arquiterual - Animavita&lt;/h1&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-animavita&#34;&gt;Descrição Geral Sobre o Animavita&lt;/h2&gt;
&lt;p&gt;O Animavita é um aplicativo mobile, criado com o objetivo de ajudar seus usuários
a adotarem um pet. O aplicativo permite o cadastro de animais para adoção, especificando
nome, raça, porte, dentre outras características que ajudem na escolha do pet pelos
usuários que desejarem adotar.&lt;/p&gt;
&lt;h2 id=&#34;o-aplicativo-animavita&#34;&gt;O Aplicativo Animavita&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Desenvolver um aplicativo que facilite a adoção de animais, permitindo que pessoas cadastrem
animais para adoção e que procurem por animais para adotar.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Proporcionando facilidade de encontrar e de escolher um animal para adoção, o Animavita
centraliza informações úteis na hora da adoção em um único aplicativo, permitindo que o
usuário possa visualizar o animal a ser adotado e que saiba informações adicionais como
nome, idade, sexo e porte. Além disso, o aplicativo auxilia com que animais de rua encontrem um lar para viver.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Buscando facilitar o ato de adoção de animais em um único aplicativo, o Animavita permite que os Usuários realizem login, cadastrem animais para adoção, busquem por um animal para adotar ou até mesmo entrem em contato para combinar a adoção.&lt;/p&gt;
&lt;p&gt;O animavita utiliza de um serviço externo fornecido pelo &lt;strong&gt;Facebook&lt;/strong&gt; para realização da autenticação dos seus usuários.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;animavita-contexto.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O &lt;strong&gt;Animavita&lt;/strong&gt; é composto por diversos containers, nosso módulo principal foi criado utilizando o expo, para desenvolvimento mobile utilizando React Native, esse módulo roda diretamente no dispositivo do usuário e para sua construção faz uso de outros módulos.&lt;/p&gt;
&lt;p&gt;Um dos módulos utilizados pelo core do aplicativo Animavita é o &lt;strong&gt;i18n&lt;/strong&gt;, módulo responsável por realizar toda configuração de linguagem escolhida pelo usuário. E dois módulos que auxiliam na montagem e estilização das telas, que são os módulos de &lt;strong&gt;UI&lt;/strong&gt; e &lt;strong&gt;Theme&lt;/strong&gt;, que interagem entre sí e fornecem rescursos para o core.&lt;/p&gt;
&lt;p&gt;Entrando nos módulos que rodam nos servidores do Animavita, temos o nosso &lt;strong&gt;Banco de Dados&lt;/strong&gt;, que é feito com &lt;strong&gt;MongoDB&lt;/strong&gt; e tem seus dados acessados e fornecidos ao core do Animavita por meio de uma &lt;strong&gt;API GraphQL&lt;/strong&gt;, produzida em TypeScript.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;animavita-containers.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Vamos demonstrar um pouco melhor como funciona a arquitetura do módulo GraphQL do Animavita. Para começar, o &lt;strong&gt;Usuário&lt;/strong&gt; se comunica com o aplicativo &lt;strong&gt;Animavita&lt;/strong&gt; e acessa suas funcionalidades. O frontend do Animavita é reponsável por fazer chamadas ao módulo GraphQL para assim acessar e escrever dados do &lt;strong&gt;Banco de Dados&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;No GraphQL temos dois principais módulos que se comunicam com o Banco de Dados para escrever e ler seus dados, um deles é o &lt;strong&gt;Gerenciador de Usuário&lt;/strong&gt;, onde são realizadas atividades como guardar um perfil de usuário, pegar informações sobre um determinado usuário, atualizar e até mesmo autenticar um usuário. Como segundo módulo, temos o &lt;strong&gt;Gerenciador de Adoção&lt;/strong&gt;, esse módulo se responsabiliza por atividades de criação e resgate de adoções.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;animavita-components.png&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Demonstraremos a seguir o fluxo de informação no momento em que é requisitada uma lista de Adoções realizada pelo usuário. No primeiro momento por segurança é realizada a autenticação do usuário, autenticado o fluxo segue para o resgate de usuário, onde pegamos um usuário e suas informações, para a partir daí pegar as listas de adoções referentes apenas ao usuário específico.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;animavita-informacoes.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição Arquitetural do Locust</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/locust/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/locust/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Guilherme de Melo Carneiro.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118210938&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:guilherme.carneiro@ccc.ufcg.edu.br&#34;&gt;guilherme.carneiro@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/locustio/locust&#34;&gt;https://github.com/locustio/locust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----locust&#34;&gt;Descrição Arquitetural &amp;ndash; Locust&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/locustio/locust&#34;&gt;Locust&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-locust&#34;&gt;Descrição Geral sobre Locust&lt;/h2&gt;
&lt;p&gt;O &lt;a href=&#34;https://locust.io&#34;&gt;Locust&lt;/a&gt; é uma solução open-source para testes de performance de aplicações. Com ele é possível estressar sistemas através da implementação(em python) de comportamento de &amp;ldquo;usuários-fantasmas&amp;rdquo;, que interagem com a aplicação levando-a ao limite, extraindo assim suas métricas de desempenho.&lt;/p&gt;
&lt;h2 id=&#34;testes-de-carga-utilizando-locust&#34;&gt;Testes de Carga utilizando Locust&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Possibilitar a testagem de requisitos de performance fora de ambiente de produção, para que os requisitos não-funcionais relacionados a desempenho sejam garantidos.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O Locust tem como objetivo permitir a extração de métricas de performance de uma API(ou serviço) nos mais diversos cenários. Cenários estes que podem ser programados via script e executados até o limite, com intuito de extrair informações importantes de desempenho sobre cada endpoint, por exemplo, aumentando a confiança na estabilidade do sistema. Algumas das métricas obtidas são os tempos mínimo e máximo de resposta obtidos sobre uma determinada carga, e também o número de requisições falhas sobre a mesma carga.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Locust é utilizado por profissionais da área de desenvolvimento, infraestrutura ou QA para testar a performance de uma aplicação quanto a carga que ela suporta até se tornar instável, isto é, até quantos usuários simultâneos executando requisições sucessivas ela atende, admitindo certo limite de falhas. Sabendo disso, é possível compreender o papel das três entidades do diagrama de contexto: o Programador é aquele que deseja testar a performance da aplicação e visualizar os resultados; A biblioteca Locust é aquela que interage com a aplicação, carregando-a de acordo com a rotina definida; A Aplicação é o objeto a ser testado, que responde às interações(requisições) feitas pelo Locust.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como o Locust se trata de uma biblioteca, considerou-se um Container como sendo uma entidade de objetivo bem-definido e sentido completo dentro do contexto interno.&lt;/p&gt;
&lt;p&gt;Aqui se descreve o objetivo de cada container, assim como as tecnologias utilizadas por eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Locustfile&lt;/strong&gt;: é implementado pelo utilizador para definir a rotina da unidade de teste que será executada nos testes de carga. Se trata de um script Python que utiliza tratativas específicas da biblioteca do Locust.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segue uma amostra de como se programa uma rotina de teste que será executada pelo Locust:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; locust &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; HttpUser, task, between

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QuickstartUser&lt;/span&gt;(HttpUser):
    wait_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; between(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@task&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hello_world&lt;/span&gt;(self):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;)
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/world&amp;#34;&lt;/span&gt;)

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@task&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;view_items&lt;/span&gt;(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item_id &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;):
            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/item?id={item_id}&amp;#34;&lt;/span&gt;, name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/item&amp;#34;&lt;/span&gt;)
            time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;on_start&lt;/span&gt;(self):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;post(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/login&amp;#34;&lt;/span&gt;, json&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Locust-plugins&lt;/strong&gt;: é uma biblioteca secundária do ecossistema do Locust que pode ser utilizada como Helper para acelerar o desenvolvimento da rotina da unidade de teste. O uso dela é opcional. É implementada em Python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web App&lt;/strong&gt;: se trata do servidor Web local levantado pelo Locust junto com a execução dos testes de carga. Ele serve para o utilizador visualizar o andamento dos testes em tempo real e ajustar parâmetros de cenário de teste. Usa Flask para subir o servidor Web, e retorna páginas HTML estáticas, com Javascript e CSS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLI&lt;/strong&gt;: é a interface de linha de comando que pode ser utilizada pelo utilizador. Possui funções semelhantes ao Web App, mas sem o servidor Web e visualização gráfica. Também desenvolvida em Python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment&lt;/strong&gt;: cérebro do Locust. Responsável por criar todo o ambiente de testagem e carregar as requisições para o serviço especificado, de acordo com o locustfile e parâmetros de cenário de teste.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;É importante considerar o meio de comunicação entre esses Containers, que acontece principalmente via API de Sockets, utilizando a biblioteca Python &lt;em&gt;gevent&lt;/em&gt; e seu conceito de &lt;em&gt;Greenlet&lt;/em&gt;, que é orientada à programação assíncrona, comunicando-se via eventos.&lt;/p&gt;
&lt;p&gt;As requisições feitas ao objeto de teste geralmente utilizam o protocolo HTTP, mas podem ser utilizado outros, a depender do tipo de serviço em questão.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;Diagrama de Containers&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Seguindo a ordem do mais geral ao mais específico, zoom é dado no Container Environment.&lt;/p&gt;
&lt;p&gt;Esse Container é considerado o cérebro do Locust, pois executa as requisições ao objeto de teste de maneira controlada. Como componentes dele, tem-se:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Runner&lt;/strong&gt;: responsável por orquestrar os testes de acordo com o perfil dos usuários configurados. Faz o balanceamento desses perfis para distribuir as requisições que devem feitas por eles. Consome a rotina definida pelo usuário no Locustfile e tem seus parâmetros de cenário de teste controlados pelo Web App ou pelo CLI.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stats&lt;/strong&gt;: responsável por receber informações do Runner sobre os testes sendo executados e calcular as métricas de performance desejadas. Essas métricas são consumidas pelo Web App e/ou pelo CLI para que sejam visualizadas pelo utilizador.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dispatcher&lt;/strong&gt;: utilizado pelo Runner para organizar as requisições e dispará-las de maneira parametrizada em relação a carga, como quantidade de requisições por usuário, e também por espaço de tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da Informação&lt;/h3&gt;
&lt;p&gt;O Locust inicia seu fluxo de informação recebendo do utilizador o arquivo locustfile.py devidamente implementado com a rotina de teste que será carregada no sistema objeto de teste. Após isso, os parâmetros relacionados ao cenário dos testes de carga, como quantidade de requisições por usuário, são definidos, podendo ser alterados pelo utilizador via Web App ou CLI antes ou durante a execução. Com os testes acontecendo, é possível acompanhar os resultados obtidos em tempo real, e também ter acesso aos resultados finais, com o fim da bateria de testes. Essas métricas, a medida que vão sendo obtidas, são transmitidas para o canal desejado pelo utilizador, seja o terminal ou a aplicação Web.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Diagrama de Informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Deno</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/deno/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/deno/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Flávio Roberto Pires Quirino Farias.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117111444&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:farias.farias@ccc.ufcg.edu.br&#34;&gt;farias.farias@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/denoland/deno/&#34;&gt;https://github.com/denoland/deno/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----deno&#34;&gt;Descrição Arquitetural &amp;ndash; Deno&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/denoland/deno/&#34;&gt;Deno&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-deno&#34;&gt;Descrição Geral sobre o Deno&lt;/h2&gt;
&lt;p&gt;Deno é um simples, moderno e seguro runtime para JavaScript e TypeScript que funciona em V8 Chromium Engine e é feito na linguagem de programação Rust. As funcionalidades do Deno são projetadas para aprimorar as funcionalidades do Node.js.&lt;/p&gt;
&lt;h2 id=&#34;deno&#34;&gt;Deno&lt;/h2&gt;
&lt;h3 id=&#34;principais-funcionalidades-e-recursos-do-deno-são&#34;&gt;Principais funcionalidades e recursos do Deno são:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Seguro por padrão. O Deno requer permissões explicitas para acessar arquivos, rede ou ambiente.&lt;/li&gt;
&lt;li&gt;Tem suporte ao Typescript;&lt;/li&gt;
&lt;li&gt;Tem um conjunto de modulos padrão, chamados de standard modules ou STD, que tem funcionalidade garantida com o Deno.&lt;/li&gt;
&lt;li&gt;Tem funcionalidades internas como um verificador de dependencias (deno info) e um formatador de código (demo fmt).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O Deno visa ser um ambiente de script produtivo e seguro para o programador moderno.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Gerar apenas um único executável (deno).&lt;/li&gt;
&lt;li&gt;Fornecer padrões de segurança:
Sem permissões específicas, os scripts não podem acessar arquivos, o ambiente, ou a rede.&lt;/li&gt;
&lt;li&gt;Compatibilidade com o navegador: O subconjunto de programas Deno que são escritos completamente em Javascript e não usam o namespace global do Deno, deve ser capaz de ser executado sem alterações em um navegador moderno.&lt;/li&gt;
&lt;li&gt;Fornecer ferramentas integradas como testes de unidade, formatação de código e linting para melhorar a experiência de desenvolvimento&lt;/li&gt;
&lt;li&gt;Ser capaz de servir HTTP eficientemente.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;O Deno é um ambiente de execução de Javascript (TS)/Typescript (TS) que utiliza o V8 engine para executar os códigos JS. Porém o V8 não suporta código TS, então todo código TS precisa ser convertido em JS para ser carregado e executado pelo V8. No entanto, Deno é escrito em Rust e o V8 em C++. Para que eles possam trabalhar juntos, é utilizado o rusty_v8, uma biblioteca que permite que o rust interaja com a API em C++ do V8.&lt;/p&gt;
&lt;p&gt;Outra característica do Deno é que sua biblioteca padrão (standard library ou STD) oferece funcionalidades completamente assíncronas. Isso é possível porque Deno utiliza Tokio, um ambiente de execução assíncrono para Rust, usado para criar e lidar com eventos. Ele permite que o Deno crie tarefas em um pool de threads interno e receba notificações para processar a saída após a conclusão de cada tarefa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deno_context.png&#34; alt=&#34;asd&#34;&gt;&lt;/p&gt;
&lt;p&gt;Mais detalhadamente, no diagrama de contexto, vemos o Deno, que é o sistema abordado nesse documento, e suas três principais dependencias externas, além de um usuário comum que interage com o Deno.&lt;/p&gt;
&lt;h3 id=&#34;tokio&#34;&gt;Tokio&lt;/h3&gt;
&lt;p&gt;Tokio é parte fundamental do Deno. Deno tenta evitar callbacks sempre que possível. Para isso, é necessário a ajuda do Tokio no uso de funções assíncronas equivalentes para funções síncronas usadas comumente. Por exemplo, Tokio envolve uma chamada de sistema OS em uma função assíncrona.&lt;/p&gt;
&lt;h3 id=&#34;v8-engine&#34;&gt;V8 engine&lt;/h3&gt;
&lt;p&gt;Apesar da grande importância do Tokio, V8 é a biblioteca mais importante do Deno. V8 é onde o código Javascript é executado. Sem isso, o Deno não funcionaria.&lt;/p&gt;
&lt;p&gt;V8 é um JavaScript e WebAssembly engine de código aberto de alto desempenho do Google, escrito em C ++, que analisa e executa códigos de script. Também fornece regras sobre como a memória é acessada, como o programa pode interagir com o sistema operacional do computador e sobre a sintaxe do programa. O V8 pode ser executado de forma autônoma ou pode ser incorporado a qualquer aplicativo C ++.&lt;/p&gt;
&lt;h3 id=&#34;rusty_v8&#34;&gt;Rusty_V8&lt;/h3&gt;
&lt;p&gt;Rusty_v8 é uma parte do projeto Deno, mas não está localizado dentro do repositório principal. Sendo assim considerado um componente de terceiros. Como dito anteriormente, Deno é escrito em Rust, equanto V8 é escrito em C++. Para fazê-los interagir, rusty_v8 foi criado. O principal objetivo da biblioteca rusty_v8 é fornecer uma interface em Rust para a API em C++ do V8.&lt;/p&gt;
&lt;h2 id=&#34;c0ntainer&#34;&gt;C0ntainer&lt;/h2&gt;
&lt;p&gt;Quando observamos os containers que formam o Deno. Podemos dividi-los em 4 partes principais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frontend: Formado pelo V8 que executa os códigos JS/TS. É a parte não previligiada, ou seja, não tem acesso a rede, ao sistema de arquivos, nem nada fora do sandbox do Deno.&lt;/li&gt;
&lt;li&gt;Backend: Formado pelo próprio Deno em Rust;&lt;/li&gt;
&lt;li&gt;Rusty_V8: Funciona como interface entre o Rust e a API do V8 em C++.&lt;/li&gt;
&lt;li&gt;IO Assíncrono: A parte assíncrona do Deno que é gerenciada através do Tokio.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A seguir, o diagrama de Container do Deno.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deno_container.png&#34; alt=&#34;asd&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componente&#34;&gt;Componente&lt;/h2&gt;
&lt;p&gt;Vamos começar com a arquitetura de alto nível do Deno. Podemos dizer que o Deno consiste de dois tipos de componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Componentes próprios: Esses componentes fazem parte do projeto do Deno, ou seja, estão presentes em seu principal &lt;a href=&#34;https://github.com/denoland/deno&#34;&gt;repositório no Github&lt;/a&gt;. Com exceção do STD (biblioteca padrão ou standard library), que é versionada de forma indepente do Deno, mas isso mudará uma vez que a biblioteca esteja estabilizada. A maioria desses componentes são escritos em Rust e Javascript/Typescript.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Componentes de terceiros: Partes imprecindíveis do Deno, como Tokio e V8 engine. Sem esses componentes o Deno não funcionaria.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para o diagrama de componentes, vamos focar no Deno e abordar apenas os componentes próprios.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deno_component.png&#34; alt=&#34;asd&#34;&gt;&lt;/p&gt;
&lt;p&gt;A seguir uma breve descrição das principais partes formam Deno.&lt;/p&gt;
&lt;h3 id=&#34;cli&#34;&gt;CLI&lt;/h3&gt;
&lt;p&gt;CLI implementa a maioria das funcionalidades do Deno que são voltadas para o usuário, sendo também uma das maiores partes do Deno. Também funciona como uma ligação entre as outras partes. ClI é uma espécie de orquestrador e executor. Ele orquestra a execução de programas TS/JS com a ajuda de serviços próprios e de todos serviços das outras partes do Deno.&lt;/p&gt;
&lt;h3 id=&#34;core&#34;&gt;Core&lt;/h3&gt;
&lt;p&gt;O Core fornece serviços importantes para a CLI como a interface para V8 API mencionada anteriormente, modulos, JsRuntime, etc. Também oferece serviços que podem ser chamados tanto em Rust como em JavaScript.&lt;/p&gt;
&lt;h3 id=&#34;runtime&#34;&gt;Runtime&lt;/h3&gt;
&lt;p&gt;Runtime é o ambiente de execução do Deno que consiste das principais funcionalidades do Deno escrito em JavaScipt puro.
O Runtime fornece a maior parte da API da Deno que pode ser chamada do programa do usuário. O tempo de execução também implementa os ops de baixo nível do Rust.&lt;/p&gt;
&lt;h3 id=&#34;std&#34;&gt;STD&lt;/h3&gt;
&lt;p&gt;É a biblioteca padrão do Deno implementada em TypeScript. Ela consiste de modulos que não têm depêndencias externas e que são revisados pela equipe do Deno. O objetivo é ter um conjunto padrão de alta qualidade de código que possa ser usado em todos os projetos do Deno sem preocupações.&lt;/p&gt;
&lt;h1 id=&#34;referências&#34;&gt;Referências&lt;/h1&gt;
&lt;p&gt;Language Bindings&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Language_binding#:~:text=Binding%20generally%20refers%20to%20a,be%20used%20in%20another%20language.&#34;&gt;Wiki Language Bindings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;V8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/apps-script/guides/v8-runtime&#34;&gt;V8 Runtime Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://v8.dev/&#34;&gt;what is v8?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deno&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://deno.land/manual@v1.0.0/introduction&#34;&gt;Deno Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://choubey.gitbook.io/internals-of-deno/architecture/chapter-cover-page&#34;&gt;Deno Internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/deno-the-complete-reference/the-internals-of-deno-5bdc1f074792&#34;&gt;The internals of Deno&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.syncfusion.com/succinctly-free-ebooks/deno-succinctly/introducing-deno&#34;&gt;Introducing Deno&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://denolib.gitbook.io/guide/&#34;&gt;A guide to Deno core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/deno-tutorial/deno-architecture-8551fb3be80e&#34;&gt;What happens in the backstage of Deno?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codegram.com/blog/first-thoughts-about-deno/&#34;&gt;First Thoughts About Deno&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/denoland/deno&#34;&gt;Deno Repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=AOvg_GbnsbA&amp;amp;t=2113s&#34;&gt;Deno internals - how modern JS/TS runtime is built&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C4 Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://c4model.com/&#34;&gt;C4 Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=x2-rSnhpw0g&#34;&gt;Visualising software architecture with the C4 model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Elasticsearch</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/elasticsearch/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/elasticsearch/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Túlio Araújo Cunha.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118210965&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:tulio.cunha@ccc.ufcg.edu.br&#34;&gt;tulio.cunha@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/elastic/elasticsearch&#34;&gt;https://github.com/elastic/elasticsearch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-análise-do-elasticsearch&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de análise do Elasticsearch&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/elastic/elasticsearch&#34;&gt;Elasticsearch&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-elasticsearch&#34;&gt;Descrição Geral sobre o Elasticsearch&lt;/h2&gt;
&lt;p&gt;O Elasticsearch é uma ferramenta para realização de buscas e análise de dados construída para trabalhar com grandes volumes de dados, permitindo indexar documentos e realizar buscas nesses documentos em quase tempo real. Com ele é possível trabalhar com dados de variados tipos, como textuais, numéricos, geoespaciais, estruturados e não estruturados. Além disso, é o componente central do Elastic Stack, que é um conjunto de ferramentas para ingestão, enriquecimento, armazenamento, análise e visualização de dados.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O Elasticsearch é uma ferramenta de código aberto de análise e pesquisa de &lt;em&gt;full-text&lt;/em&gt;. Para isso, dados são guardados como documentos (como o MongoDB) que são constituídos de campos que armazenam basicamente qualquer tipo de informação.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Costumeiramente utiliza-se o Elasticsearch para campos de pesquisa em aplicativos, que dá suporte a diversas funcionalidades como preenchimento automático, correção de erros de digitação, destaque de correspondências, entre outros. Além disso, é possível realizar consultas que agregam dados para construção de gráficos, analisar logs de aplicações ou métricas do sistema no caso de um APM (&lt;em&gt;Application Performance Management&lt;/em&gt;). Outra maneira de fazer uso da ferramenta é com envio de eventos, como vendas, cliques em um site, ligações, e-mails.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Elasticsearch se apresenta como o coração da Elastic Stack, sendo um motor distribuído de pesquisa e análise dos dados. O Logstash e Beats facilitam a coleta, agregação e incrementam os dados para armazená-los no Elasticsearch, porém não são essenciais, sendo possível consumir a API do Elasticsearch direto do sua aplicação. Também não essencial, mas altamente recomendado, o Kibana se apresenta como uma plataforma de análise e visualização gráfica dos dados contidos no Elasticsearch, economizando um tempo precioso se utilizada.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Elasticsearch utiliza-se de uma &lt;em&gt;RESTful API&lt;/em&gt; para sua comunicação com serviços externos, como a aplicação criada ou outros componentes da Elastic Stack (Logstash, Beats ou Kibana). Essa conversa também pode ser facilitada por diversas bibliotecas (&lt;em&gt;clients&lt;/em&gt;) disponibilizadas nas linguagens de programação mais utilizadas (Java, Javascript, Python, entre outras).
O serviço externo utiliza essa API para se comunicar com o &lt;em&gt;Cluster&lt;/em&gt; que tem o papel de agrupar e realizar a comunicação entre um ou mais &lt;em&gt;Nodes&lt;/em&gt;, que por sua vez, são quem executam uma instância do Elasticsearch e utilizam a camada de transporte para se comunicarem - assim, todos os &lt;em&gt;Nodes&lt;/em&gt; se conhecessem em um &lt;em&gt;Cluster&lt;/em&gt; e podem encaminhar uma requisição de um cliente para o &lt;em&gt;Node&lt;/em&gt; apropriado - e deixam a camada HTTP para os clientes &lt;em&gt;REST&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;Diagrama de Container&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Olhando mais afundo o &lt;em&gt;Node&lt;/em&gt;, podemos observar que dentro dele, são implementados &lt;em&gt;Indices&lt;/em&gt;, que funcionam de maneira semelhante à tabela em um banco de dados relacional. Dentro de cada &lt;em&gt;Index&lt;/em&gt;, armazena-se &lt;em&gt;Documents&lt;/em&gt; que salvam a informação do banco em um padrão &lt;em&gt;json&lt;/em&gt;. Por sua vez, esses &lt;em&gt;Documents&lt;/em&gt; podem ser agrupados em diversos &lt;em&gt;Shards&lt;/em&gt; dentro da cada &lt;em&gt;Index&lt;/em&gt;, sendo o &lt;em&gt;Shard&lt;/em&gt; uma implementação do &lt;em&gt;Lucene Index&lt;/em&gt; que internamente possuem segmentos, que funcionam como mini índices, e dentro dos segmentos outras estruturas de dados, como &lt;em&gt;inverted index&lt;/em&gt; e os campos com seus valores.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Levando em conta a principal funcionalidade do Elasticsearch, vamos simular uma pesquisa de um texto. Inicialmente, o texto passa por um processo para extrair as palavras relevantes da entrada, removendo artigos, acentuação, letras maiúsculas, criando assim &lt;em&gt;tokens&lt;/em&gt; que podem ser aproveitados pelo &lt;em&gt;inverted index&lt;/em&gt; utilizado pelo &lt;em&gt;Lucene Index&lt;/em&gt;. Nessa pesquisa, o Elasticsearch pesquisa por todos os &lt;em&gt;shards&lt;/em&gt; em busca de documentos que encaixem com os &lt;em&gt;tokens&lt;/em&gt; criados logo antes. Após a obtenção desses documentos, extraem-se informações como a &lt;strong&gt;frequência do termo&lt;/strong&gt; (TF) e a &lt;strong&gt;frequência do documento&lt;/strong&gt; (DF), que são, respectivamente, a frequência do termo em um dado documento e a frequência do termo em todos os documentos. Com esses valores, pode-se calcular a relevância de um documento para o texto de entrada, por meio do cálculo &lt;code&gt;TF / DF&lt;/code&gt;. Por fim, ordena-se os documentos pela relevância de cada um e é finalizada a pesquisa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Diagrama de Informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Kubernetes</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/kubernetes/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/kubernetes/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Wesley Henrique Araújo Monte.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110739&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:wesley.monte@ccc.ufcg.edu.br&#34;&gt;wesley.monte@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----kubernetes&#34;&gt;Descrição Arquitetural &amp;ndash; Kubernetes&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;Kubernetes&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-kubernetes&#34;&gt;Descrição Geral sobre o Kubernetes&lt;/h2&gt;
&lt;p&gt;O Kubernetes é uma plataforma portátil, extensível e de código aberto para o gerenciamento de cargas de trabalho e serviços em contêineres, que facilita a configuração declarativa e a automação. Tem um grande ecossistema de crescimento rápido. Os serviços, suporte e ferramentas do Kubernetes estão amplamente disponíveis.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementação de um orquestrador de containers capaz de oferecer alta disponibilidade e escalabilidade de serviços, permitindo que aplicativos sejam implantados e atualizados sem tempo de inatividade e suportam cargas de trabalho variáveis.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Oferecer uma estrutura para executar sistemas distribuídos organizados em múltiplos contêineres de forma resiliente e de configuração declarativa. Nesse contexto, o Kubernetes deve constantemente trabalhar para manter o estado desejado dos serviços dada sua configuração. Como por exemplo: manter a quantidade de réplicas desejadas, disponibilizar capacidade de armazenamento, acesso externo à aplicação, dentre diversos outros pontos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Para o Kubernetes existe um Gerente que irá declarar as configurações e aplicações que são desejadas no cluster. O Kubernetes está trabalhando para que chegue ao estado desejado. Uma vez que o cluster K8s está no estado desejado, o usuário é capaz de usar as aplicações implantadas no sistema.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O administrador do cluster envia requisições para o Kubernetes por meio da sua API REST ou por Linha de comando. Todas as requisições são enviadas ao Master Node, que é o Node o qual tem implantado o &amp;ldquo;cérebro&amp;rdquo; do cluster. O &amp;ldquo;cérebro&amp;rdquo; do cluster são os componentes do &amp;ldquo;Control Plane&amp;rdquo;, que tomam decisões globais sobre o cluster.
Além disso, o Master Node tem função de gerenciar e orquestrar os Worker Nodes, que são os Nodes onde os contêineres das aplicações são implantados e executados.
Uma vez tendo serviços implantados em um Worker Node, o usuário é capaz de acessar a aplicação.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O &lt;strong&gt;kube-apiserver&lt;/strong&gt; é o componente da camada de gerenciamento do Kubernetes que expõe a API do Kubernetes. Esse componente é o ponto de acesso para o gerenciamento do cluster.
Além disso, o kube-apiserver usa o &lt;strong&gt;etcd&lt;/strong&gt; para armazenar todos os dados do cluster e ele é o único componente que interage com o etcd.&lt;/p&gt;
&lt;p&gt;O scheduler é componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los. Para realizar essa função, o scheduler se comunica via HTTPS com o Api Server, o qual possui as informações sobre os pods.&lt;/p&gt;
&lt;p&gt;O controller manager é o componente da camada de gerenciamento que obtém o estado desejado do servidor API. Ele verifica o estado atual dos Nodes, determina se há diferenças e as resolve, se houver. Já o cloud controller manager incorpora a mesma lógica do controller manager mas para recursos específicos da nuvem.&lt;/p&gt;
&lt;p&gt;Agora falando sobre os componentes que são executados nos Workers. Temos o &lt;strong&gt;kubelet&lt;/strong&gt; que é executado em todos os nós do cluster. Ele observa as tarefas enviadas pelo &lt;strong&gt;kube-apiserver&lt;/strong&gt;, executa a tarefa e informa o Master Node. Ele também monitora os pods e informa ao &lt;strong&gt;kube-apiserver&lt;/strong&gt; se um pod não estiver totalmente funcional. Com base nessas informações, o Master pode então decidir como alocar tarefas e recursos para atingir o estado desejado.&lt;/p&gt;
&lt;p&gt;Quando o kubelet deseja criar ou interromper um container, ele manda a ordem para o &lt;strong&gt;container runtime&lt;/strong&gt;, que é um software ou plug-in de terceiros, como o Docker, que executa essa função.&lt;/p&gt;
&lt;p&gt;O kube-proxy é o componente que garante que cada nó obtenha seu endereço IP, implementa iptables locais e regras para lidar com o roteamento e balanceamento de carga de tráfego.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;component.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do Express</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/express/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/express/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Arthur de Lima Ferrão.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110318&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:arthur.ferrao@ccc.ufcg.edu.br&#34;&gt;arthur.ferrao@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/expressjs/express&#34;&gt;https://github.com/expressjs/express&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----express&#34;&gt;Descrição Arquitetural &amp;ndash; Express&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/expressjs/express&#34;&gt;Express&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-express&#34;&gt;Descrição Geral sobre o Express&lt;/h2&gt;
&lt;p&gt;O Express é um framework de código aberto, utilizado em conjunto com o Node.js, tem objetivo de prover o ferramental necessário para a criação de servidores web, de maneira simples e robusta.&lt;/p&gt;
&lt;h2 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h2&gt;
&lt;p&gt;Oferecer um ferramental robusto, em conjunto do Node.js, para desenvolvimento de aplicações back-end de forma simples, permitindo a criação de rotas para comunição via requisições HTTP.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;O Express é responsável por criar as rotas e gerenciar as requisições feitas para o sistema back-end, ele vai permitir que sistemas externos possam fazer requisições HTTP para a API. Além disso o Express é usado em conjunto com o Node.js, que vai ser responsável pela codificação do sistema back-end.&lt;/p&gt;
&lt;p&gt;Também é possivel integrar middlewares que irão ser utilizados pelo Express para adicionar funcionalidades e facilitar o desenvolvimento da aplicação back-end. Podemos encontrar alguns middlewares desenvolvidos pela própria equipe do Express na organização &lt;a href=&#34;https://github.com/expressjs&#34;&gt;expressjs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Abaixo podemos ver o diagrama de contexto que ilustra a comunicação dessas entidades com o Express.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-contexto.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Como o Express é um framework utilizado para implementar uma aplicação back-end ele não pode ser dividido em diferentes sistemas de software e, por ser um sistema único, é representado apenas por um container.&lt;/p&gt;
&lt;p&gt;Algumas das funcionalidades do Express podem ser vistas abaixo:&lt;/p&gt;
&lt;h4 id=&#34;configurando-o-express&#34;&gt;Configurando o Express&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;express&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;express&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;métodos-de-roteamento&#34;&gt;Métodos de Roteamento&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// GET method route
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET request&amp;#39;&lt;/span&gt;)
})

&lt;span style=&#34;color:#75715e&#34;&gt;// POST method route
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;post&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST request&amp;#39;&lt;/span&gt;)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;adicionando-função-middleware&#34;&gt;Adicionando função middleware&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;) {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Do something&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;()
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Para mais detalhes sobre as funcionalidades do Express leia a &lt;a href=&#34;https://expressjs.com/en/guide/routing.html&#34;&gt;documentação&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Podemos dividir o Express em dois componentes:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Router Controller&lt;/strong&gt;: permite criar rotas e gerenciar as requisições HTTP rescebidas pela API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Middleware Controller&lt;/strong&gt;: permite adicionar funções que podem ter acesso aos objetos de responde e request das requisições recebidas pela API.&lt;/p&gt;
&lt;p&gt;Abaixo podemos ver o diagrama que ilustra a distribuição desses componentes no Express.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Para essa etapa vamos focar em demonstrar desde a chegada de uma request na API até ela ser respondida por meio do Express.&lt;/p&gt;
&lt;p&gt;Abaixo podemos ver o diagrama que ilustra os estados de uma request.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;maquina-de-estados.png&#34; alt=&#34;Máquina de Estados&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h2&gt;
&lt;p&gt;É necessário traduzir esta documentação para inglês e por esse motivo ainda não foram abertas PRs para o repositório do Express.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento Arquitetural do Flutter</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/flutter/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/flutter/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Henrique Castro Arriel.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117111910&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:henrique.arriel@ccc.ufcg.edu.br&#34;&gt;henrique.arriel@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/flutter/flutter&#34;&gt;https://github.com/flutter/flutter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----flutter&#34;&gt;Descrição Arquitetural &amp;ndash; Flutter&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/flutter/flutter&#34;&gt;Flutter&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-flutter&#34;&gt;Descrição Geral sobre o Flutter&lt;/h2&gt;
&lt;p&gt;O Flutter é um SDK do Google para criar aplicações mobile, web e desktop de maneira rápida e elegante utilizando apenas um código, sem necessidade de codificar para diversos sistemas. Ele promete desenvolvimento rápido utilizando o Stateful Hot Reload e diversos widgets totalmente customizaveis, além de performance nativa utilizando os &lt;a href=&#34;https://dart.dev/overview#platform&#34;&gt;compiladores nativos do Dart&lt;/a&gt; e interfaces expressivas e flexíveis.&lt;/p&gt;
&lt;p&gt;Diversas empresas fizeram algumas aplicações utilizando o Flutter, como por exemplo: Nubank, Ebay e BMW.&lt;/p&gt;
&lt;p&gt;Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://flutter.dev/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;flutter&#34;&gt;Flutter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Facilitar o desenvolvimento de aplicações multi-plataformas com alta possíbilidade de customização, elegantes e com performance nativa.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Ser uma ferramenta poderosa e produtiva no desenvolvimento de aplicações, expressiva e com alta performance de maneira que as aplicações aparentem ser naturais em diferentes plataformas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Flutter é um framework que permite ao usuário desenvolver aplicações para diferentes sistemas operacionais, seja android, iOS, e até mesmo Web. O framework pode ter novas funcionalidades através da adição de pacotes de terceiros, criados por pessoas que queiram fazer adições válidas ao framework.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;É através do Framework, feito em Dart, que o desenvolvedor realmente interage, é essa parte que fornece uma interface moderna e reativa. Inclui diversas funcionalidades que permite com que as aplicações sejam mostradas ao usuário final, como por exemplo a parte de animação, pintura do canvas e até mesmo gestos. Também é nela que são criados os Widgets, que são os componentes do Flutter que permitem reuso e combinação de classes.&lt;/p&gt;
&lt;p&gt;O Framework envolve a Engine feita em C/C++, que expõe a parte de baixo-nível do Flutter, como classes que envolvam entrada, gráficos, e renderização de texto, sendo o núcleo do Flutter, contendo tudo necessário para dar suporte à aplicação. A Engine usa de Embedders específicos à plataforma de desenvolvimento para as aplicações serem fornecidas como qualquer outra aplicação nativa da plataforma. O Embedder funciona como ponto de entrada junto ao sistema operacional para acessar diversos serviços essenciais à aplicação.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Component.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Flutter é uma aplicação muito grande, portanto não são todos os componentes que estão mostrados na imagem, apenas alguns interessantes de se mostrar e bastante essenciais.&lt;/p&gt;
&lt;p&gt;No Framework, o componente mais interessante é o Widget, é a chave de como o Flutter funciona, é ele que permite a reutilização e combinações de classes no código, permitindo que diversos pontos da aplicação possam ser feitos de maneira padronizada e responsiva. Além dele, também há o componente de renderização da aplicação, de animação e de gestos.&lt;/p&gt;
&lt;p&gt;O componente de gestos interage também com a Engine, que possui componentes como Agendamento e Pipeline de quadros, que lida, com alta performance, como os frames serão gerenciados e apresentados na aplicação.  É na Engine também que há os canais de plataforma, que interagem com o Embedder de forma a comunicar o código em Dar com o código específico do sistema-alvo.&lt;/p&gt;
&lt;p&gt;O Embedder possui componentes como o Loop de Eventos e Empacotamento do App. O componente de empacotamento gerencia como a aplicação será utilizada pelo sistema operacional alvo de forma a ser utilizada como qualquer outra aplicação nativa, enquanto o loop de eventos gerencia os eventos que a aplicação espera.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Estado.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;Os widgets do flutter são inspiradaos em React. Eles descrevem como devem ser apresentados ao usuário de acordo com suas configurações e estados. Quando o estado muda, ele reescreve sua descrição e o framework capta essa mudança e determina as mudanças mínimas necessárias na renderização para alterar o widget. Caso não seja necessário, o canvas não é atualizado.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Ainda não foram feitas contribuições ao projeto do Flutter.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>jsonwebtoken - Documentação arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jsonwebtoken/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jsonwebtoken/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jonathan Allisson De Lima Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110926&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jonathan.allisson.silva@ccc.ufcg.edu.br&#34;&gt;jonathan.allisson.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/auth0/node-jsonwebtoken&#34;&gt;https://github.com/auth0/node-jsonwebtoken&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----jsonwebtoken&#34;&gt;Descrição Arquitetural &amp;ndash; jsonwebtoken&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/auth0/node-jsonwebtoken&#34;&gt;jsonwebtoken&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;JSON Web Token é uma estrutura de dados no formato json, compacto, seguro e pode trafegar na URL sem prejudicar seu conteúdo. Seu conteúdo é composto por claims. As Claims são um conjunto de chave/valor. Fornecem ao client ou API informações sobre o usuário que está consumindo seus serviços. Ele comumente utilizado para transferir dados através do protocolo HTTP.&lt;/p&gt;
&lt;h2 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h2&gt;
&lt;p&gt;Oferecer uma forma simples e compacta de transportar dados sigilosos entre aplicações com restrição de espaço como de headers de autorização HTTP e parâmetros de consulta URI. Exemplos de utilização seriam em aplicações com sistemas de autorização e trocas de informações com segurança.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;jsonwebtoken é uma biblioteca onde os desenvolvedores de software a importam em seus projetos para que possam utilizar suas funcionalidades. Ela é muito utilizada em web APIs REST para fins de autenticação e trocas de dados.
Seus dados transportados vão estar codificados em base64 onde será necessário ter um SECRET para ter acesso ao conteúdo completo do arquivo, além de saber caso alguém tenha tentado fraudar o conteúdo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context-diagram.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Por se tratar de uma biblioteca e não de um software, ele não possui armazenamento de dados local e basicamente possui apenas um container que oferece seus recursos utilizáveis.&lt;/p&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;p&gt;Pode ser instalado através de algum gerenciador de pacotes(como yarn ou npm) ou por CDN, no caso dessa biblioteca específica, ela é compatível com projetos node.
O diagrama ilustra apenas um simples caso de troca de dados via requisição HTTP entre projetos, os quais podem estar no navegador ou em um servidor.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deployment-diagram.png&#34; alt=&#34;Diagrama de Implantação&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Jsonwebtoken possui os seguintes componentes, para fins de compreensão, quando me referir a biblioteca, chamarei de jsonwebtoken e quando for o token em si, de jwt:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jsonwebtoken&lt;/strong&gt;: Fornece uma instância com todas as funcionalidade da biblioteca.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sign&lt;/strong&gt;: Responsável pela montagem do jwt com as dados do header, payload, signature e o secret.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verify&lt;/strong&gt;: Responsável pela verificação se o jwt, apontando qualquer falha ou se já foi expirado.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Com o intuito de descrever informações importantes que são manipuladas, coletadas, armazenadas e destribuídas pelo sistema, descrevi com o gráfico abaixo, como é realizada a criação de um token jwt com os dados fornecidos e as ferramentas da biblioteca.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;states-diagram.png&#34; alt=&#34;Diagrama de Máquina de Estados&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Yoroi Wallet - Documentação arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/yoroi-frontend/</link>
       <pubDate>Mon, 02 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/yoroi-frontend/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lourival Gonçalves Prata Netto.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 119111236&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lourival.netto@ccc.ufcg.edu.br&#34;&gt;lourival.netto@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Emurgo/yoroi-frontend&#34;&gt;https://github.com/Emurgo/yoroi-frontend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/Emurgo/yoroi-frontend&#34;&gt;Yoroi Wallet&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-a-yoroi-wallet&#34;&gt;Descrição Geral sobre a Yoroi Wallet&lt;/h2&gt;
&lt;p&gt;A Yoroi Wallet é uma carteira para armazenar criptomoedas da blockchain &lt;strong&gt;Cardano&lt;/strong&gt;. É simples, rápida e segura. Yoroi é um produto da Emurgo, desenvolvido pela IOHK. E segue as melhores práticas para software na indústria, incluindo a auditoria de segurança abrangente.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;yoroi-frontend-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;A yoroi-frontend wallet é uma carteira leve e rápida da rede de blockchain cardano, estando ela disponível como uma extensão de navegadores. Fornecendo através de uma interface amigável diversas funcionalidades da rede, como criação ou restauração de carteiras, informações sobre as próprias carteiras, envio ou recebimento de tokens, informações sobre stakepools e a possibilidade de delegar os seus tokens. A yoroi-frontend também se destaca por ser mais leve que outras carteiras, visto que não tem a necessidade de sincronizar toda a rede de blockchain no aparelho do usuário, já que ela recorre a um cardano-node já sincronizado em servidores da empresa parceira EMURGO.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;yoroi-frontend-container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;A yoroi-frontend processa todas as informações no aparelho do usuario, já para poder realizar interações com a rede de blockchain é feita requisições a API do cardano-node que está sendo executado no servidor da EMURGO.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;yoroi-frontend-componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;Por ser um sistema mais leve e simples, é possível trazer os componentes comumente mais utilizados, sendo eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Criação/Restauração de wallets: Responsável pela geração ou verificação das passphrases e a geração de senhas de pagamento&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ledger: Responsável pela conexão de carteiras digitais com uma carteira física através do bluetooth, funcionando assim como uma camada a mais de segurança.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dashboard: Componente responsável por reunir informações sobre a carteira e os tokens delegados na stakepool, assim como quais as suas recompensas a ser resgatada.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Send: Componente responsável por realizar verificação e envios de tokens para outros endereços de carteira.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Receive: Componente responsável pelo armazenamento, geração de novos endereços associado a carteira e QR Codes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delegate: Componente responsável por reunir informações sobre stakepools disponíveis na rede, e permitindo também selecionar qual delas o usuário gostaria de delegar seus tokens.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;yoroi-frontend-mde.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;A maquina de estados acima representa os estados decorridos ao tentar criar ou restaurar wallets.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição arquitetural do OpenVidu</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/openvidu/</link>
       <pubDate>Sun, 01 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/openvidu/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Wellisson Gomes Pereira Bezerra Cacho.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118210873&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:wellisson.cacho@ccc.ufcg.edu.br&#34;&gt;wellisson.cacho@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/OpenVidu/openvidu&#34;&gt;https://github.com/OpenVidu/openvidu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/OpenVidu/openvidu&#34;&gt;OpenVidu&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-openvidu&#34;&gt;Descrição Geral sobre o OpenVidu&lt;/h2&gt;
&lt;p&gt;É uma plataforma para facilitar a adição de videochamadas em seu aplicativo web ou mobile. Ele fornece um conjunto completo de tecnologias muito fáceis de integrar em sua aplicação.&lt;/p&gt;
&lt;h2 id=&#34;a-plataforma-do-openvidu&#34;&gt;A plataforma do OpenVidu&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Permitir que os desenvolvedores e desenvolvedoras adicionem comunicações em tempo real a seus aplicativos de forma muito rápida e com baixo impacto em seu código.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Criar video chamadas totalmente customizadas sem se preocupar com as operações de baixo nível. O OpenVidu fornece uma API simples, eficaz e fácil de usar para você poder esquecer o WebRTC e as coisas complicadas relacionadas a mídia.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O OpenVidu é utilizado por uma aplicação web (no cliente ou server side) que permite que os desenvolvedores adicionem comunicações em tempo real aos seus aplicativos de maneira rápida e fácil. O mesmo utiliza o Kurento para facilitar detalhes de baixo nível. Além disso, o OpenVidu pode ser utilizado tanto no client side (como o mobile, mas não expandiremos até esse ponto) como no server side.&lt;/p&gt;
&lt;p&gt;Kurento é um servidor de mídia WebRTC (comunicação em tempo real da Web) e um conjunto de APIs que simplifica o desenvolvimento de aplicativos de vídeo avançados para plataformas web e smartphones. Os recursos do servidor de mídia Kurento incluem comunicações em grupo, transcodificação, gravação, mixagem, transmissão e roteamento de fluxos audiovisuais.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./openvidu-contexto.jpeg&#34; alt=&#34;Contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para o OpenVidu:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./openvidu-container.jpeg&#34; alt=&#34;Containers&#34;&gt;&lt;/p&gt;
&lt;p&gt;Como já havia sido dito, é possível utilizar o OpenVidu em diversos módulos de um único sistema. Daremos foco em dois containers: openvidu-browser e openvidu-server.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openvidu-browser:&lt;/strong&gt; Nesse container, são executadas funções solicitadas pelo usuário. Isto é, renderiza determinados componentes que, juntos, constroem todo o arcabouço para chamadas de vídeo. Comunica-se com a API usando WebRTC.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openvidu-server:&lt;/strong&gt; Container que engloba toda a parte do servidor da aplicação e gerencia o Kurento. É responsável por definir todas as entidades do domínio, criar uma sessão de vídeo, conectar usuários a uma determinada sessão, etc. Como já foi dito acima, é fornecido uma API WebRTC para o &lt;em&gt;openvidu-client&lt;/em&gt; poder utilizar, mas também é fornecido uma API REST para que sistemas externos também possam fazer uso.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo é possível observar o diagrama dos componentes mais importantes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./openvidu-component.jpeg&#34; alt=&#34;Componentes&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openvidu-browser&lt;/strong&gt; tem diversos componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Session&lt;/strong&gt; é o responsável por iniciar/terminar a sessão com o server. Além disso, contém todas as informações de uma chamada de vídeo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; permite inscrever-se ou cancelar a inscrição de um stream de áudio e vídeo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Publisher&lt;/strong&gt; permite publicar ou despublicar o stream de audio e vídeo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StreamManager&lt;/strong&gt; permite criar, atualizar e remover os vídeos de determinado stream. Além disso, o uso do StreamManager é particularmente útil quando você não precisa diferenciar entre streams do Publisher ou do Subscriber, ou apenas deseja gerenciar diretamente seus próprios elementos de vídeo (até mais de um elemento de vídeo por stream). Este cenário é bastante comum em frameworks de front-end declarativos MVC, como Angular, React ou Vue.js&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OpenVidu&lt;/strong&gt; é o ponto de entrada da biblioteca. É nele onde são chamadas as funções do &lt;em&gt;StreamManager&lt;/em&gt;. Logo, é onde fica responsável a lógica para gerenciar os publishers e subscribers.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openvidu-server&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SessionManager&lt;/strong&gt; responsável por gerenciar todas as sessões. Isto é, juntar um usuário a uma sessão, publicar/despublicar um vídeo, enviar uma mensagem (chat), reconectar, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session&lt;/strong&gt; contém todas as informações de uma chamada de vídeo, ou seja, os publishers, os participantes, o estado de que é uma chamada privada ou não, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TokenRegister&lt;/strong&gt; responsável por registrar um token para cada sessão ativa.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MediaOptions&lt;/strong&gt; contém todos os atributos de uma chamada, isto é, se há áudio, video, o tipo do vídeo e as dimensões do vídeo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Participant&lt;/strong&gt; um usuário que está participando de uma chamada. Note que o estado pode ser &lt;em&gt;pending&lt;/em&gt; ou &lt;em&gt;active&lt;/em&gt;. Quando não é chamado o Session.publish no cliente side, o status é pendente. Do contrário, o status fica ativo e uma conexão WebSocket é estabelecida. Além disso, há todas as informações, como o timestamp de quando a conexão foi estabelecida, o tipo da plataforma que ele está, o token, o status, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui estão todos os possíveis estados de mídia dentro do OpenVidu.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;iniciando:&lt;/strong&gt; a sessão está sendo iniciada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;falhou:&lt;/strong&gt; a tentativa de iniciar uma sessão falhou.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rodando:&lt;/strong&gt; a sessão está ativa e rodando. Novos participantes podem entrar enquanto esse estado estiver ativo. Pode ser alcançado pelos estados &lt;em&gt;iniciando&lt;/em&gt; e &lt;em&gt;esperando-terminar&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;esperando-terminar:&lt;/strong&gt; é possível uma sessão ficar em modo de espera para terminar quando ela é fechada. Uma vez que isso acontece, irá automaticamente entrar no estado &lt;em&gt;terminando&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;terminando:&lt;/strong&gt; quando uma sessão está sendo fechada. Esse estado pode ser alcançado pelos estados &lt;em&gt;rodando&lt;/em&gt; e &lt;em&gt;esperando-terminar&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;terminou:&lt;/strong&gt; quando uma sessão é fechada. Esse estado pode ser alcançado pelo estado &lt;em&gt;terminando&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;./openvidu-information.jpeg&#34; alt=&#34;Informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural da funcionalidade Single-Sing On(SSO) da Aplicação Keycloak</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/keycloak/</link>
       <pubDate>Sun, 01 Aug 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/keycloak/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Autor&lt;/strong&gt;: Anderson Vidal&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Matricula&lt;/strong&gt;: 117110162&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contato&lt;/strong&gt;: &lt;a href=&#34;mailto:anderson.vidal@ccc.ufcg.edu.br&#34;&gt;anderson.vidal@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Projeto a ser documentado&lt;/strong&gt;: &lt;a href=&#34;https://github.com/keycloak/keycloak&#34;&gt;Keycloak&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---keycloak&#34;&gt;Descrição Arquitetural - Keycloak&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/keycloak/keycloak&#34;&gt;Keycloak&lt;/a&gt; baseado no padrão do &lt;a href=&#34;https://c4model.com/&#34;&gt;modelo C4&lt;/a&gt;, focando especialmente na sua funcionalidade principal de Single-Sign On (SSO) para aplicações cadastradas.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-keycloak&#34;&gt;Descrição Geral sobre o Keycloak&lt;/h2&gt;
&lt;p&gt;Keycloak é uma aplicação OpenSource para gerenciamento de identidades e acesso para aplicações e serviços modernos. Com ele, não é necessário se preocupar com o armazenamento de credenciais de usuários nem com o desenvolvimento de serviços de autenticação. Além disso, ele fornece outras ferramentas para lidar com a segurança no acesso a aplicações.
Para mais detalhes sobre a aplicação, visitar o &lt;a href=&#34;https://www.keycloak.org/&#34;&gt;site oficial&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;keycloak---single-sign-on-sso&#34;&gt;Keycloak - Single-Sign On (SSO)&lt;/h2&gt;
&lt;h3 id=&#34;sobre-o-serviço-sso&#34;&gt;Sobre o serviço SSO&lt;/h3&gt;
&lt;p&gt;O objetivo da funcionalidade Single-Sign On (SSO) é possibilitar que o usuário faça login apenas uma vez para acessar todos os sistemas que estejam configurados no keycloak,
com um único serviço de autenticação para permitir que os usuários façam login em outros serviços, sem fornecer uma senha para o serviço que está sendo conectado.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto da funcionalidade SSO compreende os seguintes sistemas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Client genérico&lt;/strong&gt;: é um meio no qual uma aplicação genérica está executando e é o objetivo de acesso do usuário comum. Por exemplo um browser executando uma aplicação web.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aplicações terceiras&lt;/strong&gt;: são aplicações que a aplicação genérica principal acessa de alguma forma, como por exemplo, redes sociais.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Keycloak&lt;/strong&gt;: é a aplicação que realiza o login do usuário comum e, quando autenticado, envia um token de acesso que é utilizado pelo client para acesso as demais aplicações terceiras&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No diagrama de contexto abaixo, podemos observar como se dá a comunicação entre as entidades mensionadas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;O &lt;em&gt;usuário comum&lt;/em&gt; requisita acesso ao cliente genérico&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;cliente genérico&lt;/em&gt; redireciona essa requisição para o &lt;em&gt;Keycloak&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Keycloak&lt;/em&gt; então responde ao usuário com uma pagina de login&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;usuário comum&lt;/em&gt; envia suas credenciais&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Keycloak&lt;/em&gt; verifica estas credenciais de acesso e, caso válidas, devolve um token de acesso ao cliente&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;cliente genérico&lt;/em&gt; em posse do token agora pode acessar as aplicações terceiras com o token que dá acesso as contas do &lt;em&gt;usuário comum&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Neste fluxo podemos observar que não foi necessário realizar requisições de login para as aplicações A, B e C, apenas o login no Keycloak, caracterizando a funcionalidade SSO.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A integração do &lt;strong&gt;Keycloak&lt;/strong&gt; é feita em um servidor pessoal ou empresarial, utilizando a tecnologia &lt;em&gt;Docker&lt;/em&gt; para os containers que iram executar as aplicações secundárias &lt;strong&gt;Keycloak Security Proxy&lt;/strong&gt;, que realiza o gerenciamento e redirecionamento das requisições para os &lt;em&gt;Keycloak Servers&lt;/em&gt;, e o &lt;strong&gt;Keycloak Server&lt;/strong&gt;, que executa as logica de negócio da aplicação. Além disso, também é utilizado uma base de dados utilizando a tecnologia &lt;em&gt;Postgres&lt;/em&gt; que irá armazenar os dados referente aos usuários e aplicações cadastradas para acesso, além de informações da aplicação em si.&lt;/p&gt;
&lt;p&gt;No diagrama abaixo, podemos observar os relacionamentos entre as entidades do sistema e os containers de execução do &lt;strong&gt;Keycloak&lt;/strong&gt;, destacando os seguintes relacionamentos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;O usuário genérico realiza uma requisição &lt;em&gt;HTTP&lt;/em&gt; para autenticação de login no &lt;strong&gt;Keycloak&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Keycloak Security Proxy&lt;/em&gt; busca pelo &lt;em&gt;Keycloak Server Container&lt;/em&gt; de destino (as empresas/aplicações podem configurar mais de uma instancias/servides do Keycloak) e redireciona a requisição.&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Keycloak Server&lt;/em&gt; verifica as credenciais do usuário em uma aplicação LDAP externa ou na base de dados no proprio servidor dependendo do tipo de aplicações que serão autenticadas.&lt;/li&gt;
&lt;li&gt;Quando todos os passos anteriores forem satisfeitos, uma resposta contendo o token de acesso é encaminhada do &lt;em&gt;Keycloak Server&lt;/em&gt; para o &lt;em&gt;Keycloak Security Proxy&lt;/em&gt; que o encaminha para a aplicação cliente.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;c4container.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;
&lt;p&gt;Os principais componentes envolvidos na lógica da funcionalidade de Single-Sign On (SSO) são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Realm&lt;/strong&gt;: É o componente responsável por gerenciar um conjunto de usuários, credenciais, funções e grupos. Podem existir varios realms e eles são isolados uns dos outros, podendo somente gerenciar e autenticar os usuários que controlam.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Events&lt;/strong&gt;: É o componente responsável por receber todas os eventos que acontecem dentro do sistema para um realm específico, criando um histórico de acontecimentos que podem ser consultados posteriormente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Identity Brokering&lt;/strong&gt;: serviço intermediário que conecta vários provedores de serviços com diferentes provedores de identidade. Como um serviço intermediário, o &lt;em&gt;Identity Brokering&lt;/em&gt; é responsável por criar uma relação de confiança com um provedor de identidade (Identity Provider) externo para usar suas identidades para acessar serviços internos expostos por provedores de serviço. Estes provedores podem ser redes sociais, serviços de nuvem ou serviços parceiros.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Federation&lt;/strong&gt;: é o serviço intermediário para gerenciamento de acesso a sistemas baseados em LDAP ou Active Directories que são freqüentemente utilizados por empresas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama abaixo mostra como cada componente se relaciona. Os relacionamentos de dão da seguinte forma:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;O usuário genérico realiza uma requisição &lt;em&gt;HTTP&lt;/em&gt; para autenticação de login no &lt;strong&gt;Keycloak&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;A aplicação reconhece o &lt;em&gt;Realm&lt;/em&gt; responsavél para aquele acesso e realiza uma busca das aplicações cadastradas na base, relacionadas a este usuário, para serem autenticadas. Em seguida envia os dados de usuário para o &lt;em&gt;Identity Brokering&lt;/em&gt; e/ou &lt;em&gt;User Federation&lt;/em&gt; para realizar as verificações e autenticações necessárias.&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Identity Brokering&lt;/em&gt; realiza uma requisição de autenticação para os &lt;em&gt;Identity providers&lt;/em&gt;, que são as aplicações a serem autenticadas.&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;User Federation&lt;/em&gt; realiza chamadas LDAP para verificar as credenciais de usuário para aplicações LDAP e serviços de diretório.&lt;/li&gt;
&lt;li&gt;Quanto todas as autenticações forem verificadas o &lt;em&gt;Identity Brokering&lt;/em&gt; e/ou &lt;em&gt;User Federation&lt;/em&gt; retornam o usuário com os tokens de acesso para o &lt;em&gt;Realm&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;O &lt;em&gt;Realm&lt;/em&gt; constroi uma resposta a autenticação contendo o token de acesso a para o &lt;em&gt;cliente genérico&lt;/em&gt; e garante acesso ao &lt;em&gt;usuário comum&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;c4component.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;Abaixo podemos ver um diagrama de linha de vida, mostrando o caminho percorrido pela informação desde o login do usuário até o feedback de acesso para ele, como explicitado no fluxo de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação da arquitetura do aplicativo para Android Signal</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/signal-android/</link>
       <pubDate>Fri, 30 Jul 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/signal-android/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Ezequias de Oliveira Rocha.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110753&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:ezequias.rocha@ccc.ufcg.edu.br&#34;&gt;ezequias.rocha@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/signalapp/Signal-Android&#34;&gt;https://github.com/signalapp/Signal-Android&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----signal-android&#34;&gt;Descrição Arquitetural &amp;ndash; Signal Android&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do aplicativo para android &lt;a href=&#34;https://github.com/signalapp/Signal-Android&#34;&gt;Signal&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-aplicativo-signal&#34;&gt;Descrição Geral sobre o aplicativo Signal&lt;/h2&gt;
&lt;p&gt;Signal é um aplicativo de mensagens para comunicação privada simples com amigos.&lt;/p&gt;
&lt;p&gt;O Signal usa a conexão de dados do seu telefone (WiFi/3G/4G) para se comunicar com segurança, opcionalmente suporta SMS/MMS simples para funcionar como um mensageiro unificado e também pode criptografar as mensagens armazenadas no seu telefone.&lt;/p&gt;
&lt;h2 id=&#34;o-aplicativo-para-android-signal&#34;&gt;O aplicativo para Android Signal&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um aplicativo de comunicação instantânea com vídeo chamada e chamada de voz criptografadas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema. Nele, temos como base a aplicação Android, na qual o usuário pode interagir, e dois sistemas de pagamento (&lt;a href=&#34;https://donorbox.org/br&#34;&gt;DonorBox&lt;/a&gt; e &lt;a href=&#34;https://www.thegivingblock.com/&#34;&gt;The Giving Block&lt;/a&gt;) para os usuários que desejam realizar doações.&lt;/p&gt;
&lt;p&gt;Ademais, a aplicação se conecta ao Signal-Server, que gerencia o registro de novas contas, armazena e distribui as chaves públicas dos clientes, transmite as mensagens criptogradas e que, entre outras funcionalidades, utiliza o &lt;em&gt;Firebase Cloud Messaging&lt;/em&gt; para fazer envio de notificações para aplicativos instalados em dispositivos que utilizam o sistema operacional Android.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;Diagrama de contexto - Signal-Android&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a aplicação Signal:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;Diagrama de container - Signal-Android&#34;&gt;&lt;/p&gt;
&lt;p&gt;O meio de acesso ao Signal é feito a partir de um aplicativo móvel que acessa todas as suas funcionalidades. O aplicativo móvel faz conecção com um servidor do Signal através de uma API implementada pelo Signal-Service.&lt;/p&gt;
&lt;p&gt;Além disso, todas as mensagens enviadas pelo Signal são armazenadas localmente no dispositivo do usuário em um banco de dados SQLite.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;Diagrama de componentes - Signal-Android&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama, tem-se alguns dos principais compoentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Payments:&lt;/em&gt; Responsável por se conectar com os dois sistemas externo utilizados pelos usuários para realizar doações, o &lt;em&gt;DonorBox&lt;/em&gt; e o &lt;em&gt;The Giving Block&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Storage:&lt;/em&gt; Responsável por gerenciar o armazenamento de mensagens e arquivos de mídia;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Messages:&lt;/em&gt; Responsável por enviar, receber e processar as mensagens e arquivos de mídia;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Notifications:&lt;/em&gt; Responsável por gerenciar as notificações recebidas, conecções com os canais de notificação e as funcionalidades permitidas a partir delas;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Crypto:&lt;/em&gt; Responsável por criptografar e descriptografar todas as informações enviadas, recebidas e armazenadas.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;A conversa é primeiramente aberta pelo usuário. Em seguida, o usuário poderá escrever uma mensagem, que será criptografada, e enviá-la para outro usuário.&lt;/p&gt;
&lt;p&gt;Após a conversa ser aberta, o usuário também pode selecionar uma mensagem, o que lhe dará algumas opções: encaminhar, responder e apagar a mensagem. Por fim, o usuário pode fechar a conversa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Máquina de estados - Signal-Android&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural - Biblioteca Gson</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/gson/</link>
       <pubDate>Thu, 29 Jul 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/gson/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jerônimo Jairo Silva de Araújo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Matrícula&lt;/strong&gt;: 117211387&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contato&lt;/strong&gt;: &lt;a href=&#34;mailto:jeronimo.araujo@ccc.ufcg.edu.br&#34;&gt;jeronimo.araujo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Projeto documentado&lt;/strong&gt;: &lt;a href=&#34;https://github.com/google/gson&#34;&gt;https://github.com/google/gson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;O &lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt; é uma biblioteca Java que é usada para &lt;em&gt;serializar&lt;/em&gt; objetos Java em suas representações JSON e para &lt;em&gt;deserializar&lt;/em&gt; uma string JSON em um equivalente objeto Java.&lt;/p&gt;
&lt;h2 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Prover uma interface simples, onde o usuário consiga serializar/deserializar objetos em JSON (e vice-versa), facilmente, sem a necessidade de anotações (pois quando não se tem acesso ao código se torna um problema).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;objetivos-específicos&#34;&gt;Objetivos específicos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Prover uma interface simples para realizar a serialização de objetos e deserialização de strings JSON através dos métodos toJson() e fromJson(), respectivamente.&lt;/li&gt;
&lt;li&gt;Trabalhar com objetos que não se tem acesso ao código.&lt;/li&gt;
&lt;li&gt;Permitir que objetos não modificáveis sejam serializáveis e deserializáveis.&lt;/li&gt;
&lt;li&gt;Dar suporte à Java Generics e objetos arbitrariamente complexos (que contém alto nível de herança e uso extensivo de Generics Types).&lt;/li&gt;
&lt;li&gt;Permitir representações customizáveis de objetos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora será dada uma visão do projeto utilizando o modelo C4.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;O Gson é uma biblioteca Java, que é comente utilizado em programas que tem necessidade de fazer conversões de objetos para JSON, ou vice-versa.&lt;/p&gt;
&lt;p&gt;Um das suas principais utilizações (e onde tive contato), são em aplicações RESTApi que recebem e enviam JSON em seus endpoints. Assim, é comum fazer a deserialização de um JSON que chega na requisição e, posteriormente, uma serialização para a criação de um JSON que será enviado como resposta.&lt;/p&gt;
&lt;p&gt;Abaixo, um simples exemplo de contexto que pode ser encontrado o Gson:&lt;/p&gt;
&lt;center&gt;
  &lt;img src=&#34;gson-context.png&#34; alt=&#34;Diagrama de contexto do Gson&#34; style=&#34;width:65%;&#34;&gt;
&lt;/center&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Para essa parte, serão considerados como obtemos um objeto Gson para realizar as chamadas toJson e fromJson. Para isso, temos dois métodos de criação de um objeto Gson:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Através da &lt;strong&gt;instanciação direta&lt;/strong&gt; de um objeto Gson, que tem as configurações padrões de um objeto Gson. A sua instanciação é feita da seguinte forma:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Gson gson &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Gson&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;Através de um &lt;strong&gt;GsonBuilder&lt;/strong&gt;, que ajuda a fazer uma criação customizável do objeto Gson, configurando coisas como: versionamento, impressão bonita e customizáveis dos JsonSerializers, JsonDeserializers e InstancesCreators. A criação através do builder pode ser feita da seguinte maneira:
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Gson gson &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; GsonBuilder&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;registerTypeAdapter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Id&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IdTypeAdapter&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;enableComplexMapKeySerialization&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;serializeNulls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setDateFormat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;DateFormat&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LONG&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setFieldNamingPolicy&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;FieldNamingPolicy&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;UPPER_CAMEL_CASE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setPrettyPrinting&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setVersion&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
   &lt;span style=&#34;color:#75715e&#34;&gt;// creates a Gson instance with the configurations 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// set into the GsonBuilder
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assim, podemos ter dois &amp;ldquo;containers&amp;rdquo;, que dão acesso a criação de Gson e sua utilização futura:&lt;/p&gt;
&lt;center&gt;
  &lt;img src=&#34;gson-containers.png&#34; alt=&#34;Diagrama de containers do Gson&#34; style=&#34;width:65%;&#34;&gt;
&lt;/center&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Agora, o container que será &amp;ldquo;aberto&amp;rdquo; é do Gson. Nele que há todas as chamadas que fazer acontecer as serializações e deserializações, respectivamente, através dos métodos toJson e fromJson.&lt;/p&gt;
&lt;p&gt;A seguir, uma exemplo de como um serialização/deserialização pode ser feita:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Também pode ser utilizado new GsonBuilder().create();
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Gson gson &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Gson&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// O objeto que será serializado
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;MyType target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MyType&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// Serializa o target para um Json
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;String json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gson&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;toJson&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;target&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// Deserializa o Json para um objeto do tipo passado
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;MyType target2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gson&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fromJson&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;json&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; MyType&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A partir do objeto MyType, é feita a serialização chamando o método toJson do Gson, que ao final returna uma JSON string. Depois é o processo contrário, pois iremos deserializar a string JSON de volta para um objeto do tipo MyType. Para isso, é chamado o método fromJson com a string JSON e o tipo que se espera que o JSON seja. Ao final, será retornado um objeto do tipo MyType.&lt;/p&gt;
&lt;p&gt;Dentro do Gson são feitas várias coisas quando chamamos cada um desses métodos, e abaixo temos uma representação disso:&lt;/p&gt;
&lt;center&gt;
  &lt;img src=&#34;gson-component.png&#34; alt=&#34;Diagrama de componentes do Gson&#34;/&gt;
&lt;/center&gt;
&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h2&gt;
&lt;p&gt;A seguir, será apresentado como acontece a serialização (toJson) de um objeto, para uma string Json. Será apresentado, desde a criação de um objeto Gson, até o retorno de uma string Json.&lt;/p&gt;
&lt;center&gt;
  &lt;img src=&#34;gson-information.png&#34; alt=&#34;Diagrama de informação do Gson&#34;&gt;
&lt;/center&gt;</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Ceph</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/ceph/</link>
       <pubDate>Wed, 28 Jul 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/ceph/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento explica aspectos da arquitetura do sistema de arquivos Ceph. O Ceph é um sistema que armazena seus arquivos em um cluster distribuído.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Luis Eduardo Barroso Mafra.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110175&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:luis.mafra@ccc.ufcg.edu.br&#34;&gt;luis.mafra@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ceph/ceph&#34;&gt;https://github.com/ceph/ceph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---ceph&#34;&gt;Descrição Arquitetural - Ceph&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do Ceph. Essa descrição foi baseada principalmente no modelo C4. O foco principal é descrever como esse software realiza o armazenamento de dados e o acesso à eles.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-ceph&#34;&gt;Descrição Geral sobre o Ceph&lt;/h2&gt;
&lt;p&gt;O Ceph é um software que armazena os dados em blocos e os distribui em um cluster escalonável de armazenamento, composto por Object Storage Daemons (OSD). O Ceph possui também um monitor com acesso à informações do cluster, e pode ter um servidor de metadados (MDS) para intermediar o acesso a inodes e diretórios no CephFS.&lt;/p&gt;
&lt;p&gt;Mais detalhes podem ser vistos &lt;a href=&#34;https://docs.ceph.com/en/latest/&#34;&gt;nesse link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;ceph&#34;&gt;Ceph&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um sistema de arquivos distribuídos que permite leitura e escrita de arquivos de forma eficiente.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O Ceph é um software que tem como objetivo criar um cluster de armazenamento de arquivos escalonável, garantindo replicação e tolerância a falhas, assim como um acesso eficiente aos dados armazenados nesse cluster.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema.
&lt;img src=&#34;context.png&#34; alt=&#34;context&#34;&gt;&lt;/p&gt;
&lt;p&gt;Quando o cluster for criado, o cliente poderá acessar o diretório em que o ceph foi montado, e armazenar os arquivos. Esses arquivos serão dividos em objetos e armazenados de forma balanceada entre os vários servidores de armazenamento que compõem o cluster. Também é possível adquirir informações sobre arquivos e diretórios com comandos básicos (&lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;,&lt;code&gt;stat&lt;/code&gt;, etc), que irá pegar isso do cluster de metadadados caso o tipo de cliente seja CephFS.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para o Ceph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;p&gt;Vamos detalhar cada container e sua função no sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Monitor&lt;/strong&gt;: Esse é o container que guarda uma mapa do estado do cluster, que inclui o mapa do &lt;strong&gt;Manager&lt;/strong&gt;, o mapa do &lt;strong&gt;OSD&lt;/strong&gt;, o mapa do próprio &lt;strong&gt;Monitor&lt;/strong&gt;, e o CRUSH Map. Esses mapas possuem informações necessárias para que os daemons do Ceph se comuniquem entre si. Ele também é responsável por gerenciar a autenticação entre o cliente e os daemons, através de uma chave secreta.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Manager&lt;/strong&gt;: Esse é o container responsável por manter métricas em tempo de execução do cluster, incluindo espaço utilizado e métricas de desempenho. Ele também possui módulos em python para exibir informações do cluster em uma plataforma web através de um Dashboard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object Storage Daemon(OSD)&lt;/strong&gt;: Esse é o container responsável por armazenar os dados dos arquivos, lidar com replicação e rebalanceamento desses dados entre os nodes, e fornece informações de monitoramente para o &lt;strong&gt;Monitor&lt;/strong&gt; e o &lt;strong&gt;Manager&lt;/strong&gt;. É possível(e esperado) ter vários OSDs para garantir uma maior segurança e eficiência.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;component.png&#34; alt=&#34;component&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nos componentes, temos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data Striping&lt;/strong&gt;: Responsável por dividir os dados do arquivo em vários objetos menores para que o arquivo fique espalhado em diferentes OSDs. Dessa forma, o Ceph garante uma maior eficiência na leitura de dados, podendo ler o arquivo de várias OSDs ao mesmo tempo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Algoritmo CRUSH&lt;/strong&gt;: O Algoritmo CRUSH mapeia objetos em Placement Groups(PG), e PGs em OSDs dinamicamente utilizando uma função hash pseudo-aleatória para que os objetos sejam distribuídos de forma uniforme. Essas informações são armazenadas no CRUSH Map para posterior utilização.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replication&lt;/strong&gt;: A OSD usa o algoritmo CRUSH para calcular onde as réplicas dos objetos devem ser armazenadas. Quando um objeto é criado, ele é armazenado na OSD primária, e a OSD recupera o número de réplicas esperada por arquivos, e utiliza o CRUSH Map para armazenar nas OSDs secundárias.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rebalancing&lt;/strong&gt;: Responsável por atualizar o Cluster Map quando uma OSD for adicionada ou removida do cluster, migrando alguns Placement Groups para garantir que os objetos continuem distribuidos uniformemente entre as OSDs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Heartbeat&lt;/strong&gt;: Responsável por verificar o &amp;ldquo;batimento cardíaco&amp;rdquo; de outras OSDs, e reportar ao monitor se verificar que umas das OSDs tenha caído.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Temos um fluxo de estados bem simples, onde o arquivo é criado, e será dividido em vários pedaços pelo Data Striping. Em seguida, ele é enviado ao Algoritmo CRUSH para ser mapeado em algum Placement Group, e replicado em várias das OSDs, onde ele chegará ao seu estado final.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Docker - Documentação arquitetural usando o modelo C4</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/docker/</link>
       <pubDate>Tue, 27 Jul 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/docker/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;hamburg-3021820.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;imagem-de-julius-silverhttpspixabaycomptusersjulius_silver-4371822utm_sourcelink-attributionamputm_mediumreferralamputm_campaignimageamputm_content3021820-por-pixabayhttpspixabaycomptutm_sourcelink-attributionamputm_mediumreferralamputm_campaignimageamputm_content3021820&#34;&gt;Imagem de &lt;a href=&#34;https://pixabay.com/pt/users/julius_silver-4371822/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3021820&#34;&gt;Julius Silver&lt;/a&gt; por &lt;a href=&#34;https://pixabay.com/pt/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3021820&#34;&gt;Pixabay&lt;/a&gt;&lt;/h6&gt;
&lt;!-- Imagem de &lt;a href=&#34;https://pixabay.com/pt/users/julius_silver-4371822/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3021820&#34;&gt;Julius Silver&lt;/a&gt; por &lt;a href=&#34;https://pixabay.com/pt/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3021820&#34;&gt; &lt;/a&gt; --&gt;
&lt;p&gt;&lt;strong&gt;TLDR:&lt;/strong&gt; Este documento apresenta uma sugestão para a documentação arquitetural do sistema de
conteinerização Docker usando o modelo C4.
Entender bem como funciona esse sistema é importante, visto que os conceitos de containers linux
podem ser muito úteis para pessoas que trabalham com desenvolvimento de software.
É importante destacar que esse documento não descreve todos os detalhes da arquitetura do Docker.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;autor&#34;&gt;Autor&lt;/h2&gt;
&lt;p&gt;Este documento foi produzido por Vinicius Barbosa da Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210708&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:vinicius.barbosa.silva@ccc.ufcg.edu.br&#34;&gt;vinicius.barbosa.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/docker/docker-ce&#34;&gt;https://github.com/docker/docker-ce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;o-que-é-o-docker&#34;&gt;O que é o Docker?&lt;/h2&gt;
&lt;p&gt;Docker é um sistema de conteinerização que utiliza recursos do linux como namespaces e cgroups
para criar pacotes de software que são leves, isolados e que agrupam código, bibliotecas e
arquivos de configuração. A aplicação que roda em um container tem a impressão que o sistema
está sendo usado apenas por ela e, dessa forma, não consegue acessar os recursos e processos
de outros containers. Esse isolamento existe graças a funcionalidade de namespaces do linux.&lt;/p&gt;
&lt;p&gt;O modelo de conteinerização pode ser muito eficaz para executar aplicações que não requerem uso exclusivo
dos servidores, já que são executados pelo mesmo kernel de um sistema operacional,sendo uma
ótima alternativa a virtualização tradicional com máquinas virtuais que levantam o SO inteiro
e acabam desperdiçando recursos.&lt;/p&gt;
&lt;p&gt;Os containers são inicializados através de uma &lt;a href=&#34;https://searchitoperations.techtarget.com/definition/Docker-image&#34;&gt;Imagem&lt;/a&gt; base que pode vir de registros privados ou públicos
como o &lt;a href=&#34;https://hub.docker.com/&#34;&gt;docker hub&lt;/a&gt;, por exemplo. As imagens são construídas por camadas e podem vir
pre-configuradas com um software de interesse da aplicação que rodará no container. Exemplos de imagens: mysql, ubuntu, alpine, nginx, apache, etc.
Mais detalhes sobre o projeto Docker e sobre containers podem ser vistos &lt;a href=&#34;https://www.docker.com/resources/what-container&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;docker-filesystems-multilayer.png&#34; alt=&#34;docker-multilayer&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;imagem-retirada-de-3httpsraginmediumcomdocker-what-it-is-how-images-are-structured-docker-vs-vm-and-some-tips-part-1-d9686303590f-nela-podemos-ver-que-o-container-roda-em-cima-de-uma-imagem-composta-por-diversas-camadas-onde-cada-uma-possui-um-software-específico-é-importante-mencionar-que-na-base-existe-um-mini-sistema-operacional-que-no-caso-desse-exemplo-é-o-alpine-linux&#34;&gt;Imagem retirada de [&lt;a href=&#34;https://ragin.medium.com/docker-what-it-is-how-images-are-structured-docker-vs-vm-and-some-tips-part-1-d9686303590f&#34;&gt;3&lt;/a&gt;]. Nela, podemos ver que o container roda em cima de uma imagem composta por diversas camadas, onde cada uma possui um software específico. É importante mencionar que na base existe um &amp;ldquo;mini sistema operacional&amp;rdquo;, que no caso desse exemplo é o alpine linux&lt;/h6&gt;
&lt;h2 id=&#34;diagrama-de-contexto&#34;&gt;Diagrama de Contexto&lt;/h2&gt;
&lt;p&gt;No centro temos o sistema principal, o Docker, que prove serviços para criar, executar, atualizar, gerenciar containers linux.&lt;/p&gt;
&lt;p&gt;O Docker pode ser usado de duas maneiras: via CLI ou usando a API diretamente. Ambas as formas produzem o mesmo resultado, apenas a forma de fazer que muda.
Isso permite que sistemas externos como o &lt;a href=&#34;https://kubernetes.io/pt-br/&#34;&gt;Kubernetes&lt;/a&gt; usem o Docker com facilidade.&lt;/p&gt;
&lt;p&gt;O sistema Docker utiliza um serviço externo de registro de imagens, que pode ser público (como o &lt;a href=&#34;https://hub.docker.com/&#34;&gt;Dockerhub&lt;/a&gt;) ou um registro privado de uma empresa particular&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-contexto.png&#34; alt=&#34;context_diagram&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;diagrama-de-containers&#34;&gt;Diagrama de Containers&lt;/h2&gt;
&lt;p&gt;Os componentes internos do Docker incluem a &lt;strong&gt;CLI&lt;/strong&gt;, &lt;strong&gt;API application&lt;/strong&gt; e o &lt;strong&gt;Docker storage directory&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;CLI&lt;/strong&gt; é implementada em golang e &lt;a href=&#34;https://github.com/docker/cli/blob/master/cli/cobra.go&#34;&gt;usa a biblioteca Cobra&lt;/a&gt;(&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;ver library&lt;/a&gt;) para se comunicar com a RESTful API application.&lt;/p&gt;
&lt;p&gt;A RESTful &lt;strong&gt;API application&lt;/strong&gt; fornece seus serviços por meio do protocolo HTTP (&lt;a href=&#34;https://docs.docker.com/engine/api/&#34;&gt;ver mais&lt;/a&gt;). Essa api faz a conexão entre a CLI ou aplicação que usa a api diretamente com o deamon do Docker (chamado &lt;a href=&#34;https://docs.docker.com/engine/api/v1.41/#&#34;&gt;Docker Engine API&lt;/a&gt;), que é o core do Docker e que será melhor descrito no diagrama de componentes.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Docker storage directory&lt;/strong&gt; é responsável por armazenar os dados dos containers (o filesystem e seus volumes) e as imagens que foram baixadas do registro. Por default, o repositório se encontra em &lt;code&gt;/var/lib/docker&lt;/code&gt;, mas pode ser trocado para qualquer outro diretório
do sistema de arquivos, por exemplo, em um disco externo: &lt;code&gt;/mnt/disk3/docker&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-container.png&#34; alt=&#34;container_diagram&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;diagrama-de-componentes&#34;&gt;Diagrama de Componentes&lt;/h2&gt;
&lt;p&gt;Os componentes internos da &lt;strong&gt;API Application&lt;/strong&gt; foram representados por: &lt;strong&gt;Docker Daemon&lt;/strong&gt;, &lt;strong&gt;Kernel Component&lt;/strong&gt;, &lt;strong&gt;Container Component&lt;/strong&gt; e &lt;strong&gt;Image Component&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Docker Component&lt;/strong&gt; é responsável por receber as requisições da API e utilizar os demais componentes internos (Kernel, Image, Container component) para entregar resultado para o cliente, isto é, criar e gerenciar os containers.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Kernel Component&lt;/strong&gt; existe para lidar com o sistema operacional linux e pedir recursos para a criação de containers como namespaces e cgroups.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Container Component&lt;/strong&gt; lida com o gerenciamento dos containers.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Image Component&lt;/strong&gt; lida com o gerenciamento, criação de imagens e download/envio de imagens para o registro.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.png&#34; alt=&#34;components_diagram&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;diagrama-da-visão-de-informação&#34;&gt;Diagrama da Visão de Informação&lt;/h2&gt;
&lt;h3 id=&#34;ciclo-de-vida-de-um-container&#34;&gt;Ciclo de vida de um container&lt;/h3&gt;
&lt;p&gt;Os containers docker possuem 5 estados principais: &lt;code&gt;CREATED&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;PAUSED&lt;/code&gt;, &lt;code&gt;STOPPED&lt;/code&gt; e &lt;code&gt;DELETED&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O primeiro estado, &lt;strong&gt;CREATED&lt;/strong&gt;, é atingido através do comando &lt;em&gt;docker create&lt;/em&gt;, estando pronto para seguir para um dos proximos estados: &lt;strong&gt;RUNNING&lt;/strong&gt; (via &lt;em&gt;docker start&lt;/em&gt;) ou &lt;strong&gt;DELETED&lt;/strong&gt; (via &lt;em&gt;docker rm&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;O container quando está no estado &lt;strong&gt;RUNNING&lt;/strong&gt;, pode ter diversos caminhos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ser pausado e passar para o estado &lt;strong&gt;PAUSED&lt;/strong&gt; (via &lt;em&gt;docker pause&lt;/em&gt;) e possivelmente voltar para o estado &lt;strong&gt;RUNNING&lt;/strong&gt; (via &lt;em&gt;docker unpause&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ser reiniciado via &lt;em&gt;docker restart&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ser parado e passar para o estado &lt;strong&gt;STOPPED&lt;/strong&gt; (via &lt;em&gt;docker kill&lt;/em&gt; ou &lt;em&gt;docker stop&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E por fim, temos o estado &lt;strong&gt;DELETED&lt;/strong&gt;, que é atingido ao usarmos o comando &lt;em&gt;docker rm&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;event_state.png&#34; alt=&#34;components_diagram&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;diagrama-do-ciclo-de-vida-dos-containers-feito-por-docker-saigonhttpdocker-saigongithubiopostdocker-internals-2&#34;&gt;Diagrama do ciclo de vida dos containers feito por &lt;a href=&#34;http://docker-saigon.github.io/post/Docker-Internals&#34;&gt;Docker Saigon&lt;/a&gt; [2]&lt;/h6&gt;
&lt;h2 id=&#34;referencias&#34;&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/products/container-runtime&#34;&gt;https://www.docker.com/products/container-runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docker-saigon.github.io/post/Docker-Internals&#34;&gt;http://docker-saigon.github.io/post/Docker-Internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ragin.medium.com/docker-what-it-is-how-images-are-structured-docker-vs-vm-and-some-tips-part-1-d9686303590f&#34;&gt;https://ragin.medium.com/docker-what-it-is-how-images-are-structured-docker-vs-vm-and-some-tips-part-1-d9686303590f&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
     </item>
   
     <item>
       <title>Website de e-commerce com Django</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/ecommerce/</link>
       <pubDate>Tue, 27 Jul 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/ecommerce/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Esta é uma documentação arquitetural de um site de e-commerce chamado Fashe desenvolvido com o framework web Django. Django foi desenvolvido para permitir a construção de aplicativos web rapidamente e de maneira muito fácil, com foco no backend. Este é um site de demonstração, não um site real. O objetivo do projeto é mostrar o que se é possível fazer usando um framework tão simples e eficiente como Django. O site tem todas as funcionalidades esperadas de um e-commerce moderno, como contas de usuários que mantém carrinhos e fecham compras, por exemplo. Link para o site: &lt;a href=&#34;https://colorlib.com/etc/fashe/index.html&#34;&gt;https://colorlib.com/etc/fashe/index.html&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Vinícius Abner Pereira de Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110384&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:vinicius.souza@ccc.ufcg.edu.br&#34;&gt;vinicius.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/zinmyoswe/Django-Ecommerce&#34;&gt;https://github.com/zinmyoswe/Django-Ecommerce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---site-fashe-feito-com-framework-django&#34;&gt;Descrição Arquitetural - Site Fashe feito com framework Django&lt;/h1&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um website demonstrativo que usa o framework web Django.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Apresentar um website de e-commerce que contém todas as funcionalidades esperadas num e-commerce moderno, como carrinho de compras, operação de pagamentos online, um blog, etc. Por se tratar de uma demonstração, obviamente algumas funcionalidades não estão completamente implementadas, como o fechamento real de compras, por exemplo. Este documento objetiva mostrar como um website  construído com Django é relativamente arquiteturalmente simples.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema do Fashe é bem simples até contextualmente. Basicamente, só há três entidades envolvidas: os usuários (sejam eles clientes com conta ou não), o próprio sistema e o banco de dados. Os usuários visualizam os produtos nas páginas, adicionam ou removem produtos do carrinho, fecham compras, realizam pagamentos, e pedem reembolso. O sistema Fashe faz o serviço esperado de e-commerce. E o banco de dados é o banco de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como toda aplicação web, o Fashe pode ser dividido em dois containers: de frontend e backend, respectivamente. O frontend do Fashe apresenta as páginas com os produtos organizados em categorias, e também oferece uma interface  para as operações do usuário (atualizar carrinho e fechar compra, por exemplo)  por meio de formulários Django. Já o backend é responsável por realizar as operações que o usuário fez nas páginas, que envolvem (quase) sempre modificações ou consultas ao banco de dados. Também controla a renderização de páginas e roteamento.
&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O frontend pode ser subdivido em duas partes principais: as páginas HTML (o container TEMPLATES) e os scripts CSS e JavaScript (o container SCRIPTS). Há outros componentes adicionais e acessórios, como arquivos de imagens, fontes, etc&amp;hellip; que, pela simplicidade, foram contidos num container chamados OUTROS.&lt;/p&gt;
&lt;p&gt;Já o backend é mais complexo. Há um componente de roteamento, que neste documento foi chamado de Controlador de Redirecionamento que serve como ponte entre o frontend e o backend. Esse componente mapeia urls em views, que por sua vez, realizam alguma operação requisitada pelo usuário e/ou requisita um redirecionamento ao componente de redirecionamento. Há também um componente para lidar com as operações pertinentes ao carrinho (controlador de carrinho), um para lidar com renderização de páginas (Renderizador de páginas), um para a realização de pagamentos (controlador de pagamentos), aplicação de cupons (controlador de cupons), e fechamento de compras (controlador de checkout). Por fim, há um componente que serve como interface para que os controladores possam acessar e/ou modificar dados do banco.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;p&gt;O código do frontend pode ser resumido a páginas HTML e scripts JavaScript e CSS. Também há outros códigos que são dos componentes acessórios descritos na seção anterior.
&lt;img src=&#34;code_frontend.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;Em projetos Django, o controlador de roteamento fica todo num arquivo chamado urls.py. Dá pra se notar que em todos os componentes além do controlador de roteamento aparece o mesmo arquivo views.py. Isso se dá porque é bastante comum num projeto Django todas as views  estarem  no mesmo arquivo. Daria para organizador o código dos controladores em arquivos específicos, sim, mas a decisão do arquiteto desse projeto foi manter a tradição. O arquivo forms.py é onde estão reunidos todos os formulários que o usuário utiliza no frontend. Em Django, os formulários podem ser definidos em python para facilitar a manipulação dos dados deles no backend. A interface com o banco de dados é feita no arquivo models.py. O framework Django permite definir tabelas do banco como classes, de maneira a ser possível os controladores acessarem dados da tabela como se acessaria um objeto qualquer num program OO.  Mais uma vez, é muito comum todas as tabelas (ou modelos) serem definidas num só arquivo, como foi feito aqui.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;code_backend.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;p&gt;Arquivos adicionais para o funcionamento do Django foram contidos no container ARQUIVOS DJANGO.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>CompCult Mobile - Documentação arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/whitelabel-compcult-mobile/</link>
       <pubDate>Sat, 01 May 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/whitelabel-compcult-mobile/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento tem por finalidade descrever a plataforma &lt;em&gt;CompCult Mobile&lt;/em&gt; sob diversos níveis (visões) arquiteturais. Em verdade, a &lt;em&gt;CompCult Mobile&lt;/em&gt; descreve uma &lt;em&gt;White Label&lt;/em&gt;, um arcabouço para o desenvolvimento das aplicações móveis produzidas pelo laboratório CompCult - UFCG.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lucas Christopher de Souza Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210934&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lucas.christopher.silva@ccc.ufcg.edu.br&#34;&gt;lucas.christopher.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/CompCult/compcult-mobile&#34;&gt;https://github.com/CompCult/compcult-mobile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/CompCult/compcult-mobile&#34;&gt;CompCult Mobile&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-compcult-mobile&#34;&gt;Descrição Geral sobre o CompCult Mobile&lt;/h2&gt;
&lt;p&gt;A CompCult Mobile é uma &lt;em&gt;white label app&lt;/em&gt; que tem como objetivo oferecer um arcabouço para o desenvolvimento das aplicações híbridas produzidas pelo laboratório CompCult - UFCG. Através dessa aplicação, podemos dar forma às metodologias frisadas pelo &lt;a href=&#34;https://www.scitepress.org/Papers/2018/66911/66911.pdf&#34;&gt;ReadAct&lt;/a&gt;, dando forma ao conceito interno do laboratório chamado GSDK (Gaming Software Development Kit), que, em suma, trata-se de uma implementação de realidade alternativa em aplicações socioeducativas.&lt;/p&gt;
&lt;h2 id=&#34;o-arcabouço-para-aplicações-socioeducativas-desenvolvidas-pelo-compcult-atelier&#34;&gt;O Arcabouço para aplicações socioeducativas desenvolvidas pelo CompCult Atelier&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um arcabouço para padronizar as aplicações socioeducativas desenvolvidas pelo CompCult Atelier a fim de proporcionar uma arquitetura limpa, com fácil manutenção e que siga as metodologias frisadas pelo &lt;a href=&#34;https://www.scitepress.org/Papers/2018/66911/66911.pdf&#34;&gt;ReadAct&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos propor ao CompCult uma forma de desenvolver aplicações de uma maneira mais facilitada. Com esta missão em vista, escolhemos o uso do Flutter (SDK do Google) para desenvolver o sistema, já que com ele, temos a vantagem de utilizar uma única base de código para oferecer a aplicação aos sistemas operacionais Android e iOS, de uma forma que a performance seja semelhante a de aplicações nativas.&lt;/p&gt;
&lt;p&gt;Visto que os projetos que chegam ao laboratório são de cunho exclusivamente educacional, a ideia é propor uma interface para acelerar o desenvolvimento de nossos produtos de uma forma que não impacte na qualidade dos mesmos. Além disso, a maturação da ideia deste arcabouço levará a possíveis negociações com empresas de viés educacional que buscam melhorar a interação aluno-professor.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema se resume a uma aplicação mobile híbrida que aproxima a interação aluno-professor utilizando-se de realidade alternativa. Com isso, disponibilizamos aos clientes do CompCult uma interface personalizável e distribuída ao qual eles podem trazer a aplicação, &amp;ldquo;sua própria cara&amp;rdquo; (com suas cores e temas de preferência). Imagine que você tenha uma forma de bolo em sua casa. Nela, você pode fazer bolos de diferentes sabores, porém, todos esses bolos terão o mesmo formato. Em suma, é basicamente isso: o usuário consome uma aplicação que é uma implementação do CompCult Mobile.&lt;/p&gt;
&lt;p&gt;O arcabouço é composto basicamente por:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sistema de log in/sign up: podemos cadastrar usuários e entrar/sair da aplicação com os mesmos;&lt;/li&gt;
&lt;li&gt;missões/quizzes: a aplicação possui quizzes na forma perguntas/respostas, e missões, que podem proporcionar uma ideia de realidade alternativa, no qual os usuários (geralmente, alunos) da aplicação podem solucionar suas missões dispondo de respostas através de geolocalização, imagens, vídeos e arquivos de áudio;&lt;/li&gt;
&lt;li&gt;sistema de rancking/recompensa: a cada missão/quiz resolvido, os usuários recebem pontuações e  recompensas na aplicação (moedas virtuais na aplicação que possibilitam uso na loja);&lt;/li&gt;
&lt;li&gt;loja: uma miniloja com itens no qual os usuários podem comprar/vender itens utilizando-se de suas moedas virtuais, itens como livros e novas missões.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;context-diagram.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A arquitetura do CompCult Mobile foi pensada no padrão de projeto MVVM (Model-View-ViewModel), que visa estabelecer uma clara separação em camadas de responsabilidades e tornar a aplicação mais manutenível e testável. A grosso modo, temos uma divisão em três containers:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VIEW&lt;/strong&gt;: Aqui temos toda a parte de visualização onde o usuário iterage com a aplicação. Nela estão todas as telas com seus respectivos layouts, componentes (botões, inputs, menus e etc), temas, imagens e etc.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BUSINESS LOGIC&lt;/strong&gt;: Por outro lado, nesta camada temos os intermediadores e os responsáveis por ditarem as regras de negócio da aplicação.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATABASE&lt;/strong&gt;: Camada responsável pelo armazenamento dos dados da aplicação, localmente e remotamente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers-diagram.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Expandindo os containers do &lt;em&gt;white label&lt;/em&gt;, podemos enxergar os principais componentes da aplicação com seus relacionamentos e responsabilidades descritas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VIEWS&lt;/strong&gt;: Aqui reunimos todas as telas da aplicação. Podemos enxergar por exemplo, a &amp;ldquo;LoginScreen&amp;rdquo; que é a tela no qual o usuário poderá inserir seus dados e entrar na aplicação; também, a &amp;ldquo;MissionsScreen&amp;rdquo; e a &amp;ldquo;QuizzesScreen&amp;rdquo; que reúnem, respectivamente, a listagem de missões e quizzes disponíveis para os usuários, além das opções de inserir códigos para missões/quizzes secretos e tudo mais.&lt;/p&gt;
&lt;p&gt;Expandindo o container &amp;ldquo;Business Logic&amp;rdquo;, podemos encontrar:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VIEWMODELS&lt;/strong&gt;: Buscam prover para as &lt;em&gt;views&lt;/em&gt; a lógica de apresentação, implementando propriedades e comandos para que as &lt;em&gt;views&lt;/em&gt; possa preencher seus controles, notificando as mesmas, em caso de mudança de estado, através de eventos ou notificação de mudança. Os &lt;em&gt;viewmodels&lt;/em&gt; funcionam como controladores das ações que os usuários fazem nas &lt;em&gt;views&lt;/em&gt;. Podemos citar por exemplo, o &amp;ldquo;StoresViewModel&amp;rdquo;, que lida com todo controle de ações nos usuários com a loja, como por exemplo, a pesquisa, a venda e a compra de itens na loja da aplicação, e o &amp;ldquo;GamesViewModel&amp;rdquo; que lida com as iterações do usuário referente aos minijogos na aplicação, controlando a pontuação e regras dos minijogos.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MODELS&lt;/strong&gt;: Esse componente engloba a manipulação dos dados. Podemos ver os &lt;em&gt;models&lt;/em&gt; que são as abstrações para as entidades da aplicação (usuário, missão, quiz, itens da loja e etc), os &lt;em&gt;repositories&lt;/em&gt; que controlam as ações de armazenamento no dispositivo do usuário e os &lt;em&gt;services&lt;/em&gt; que listam as chamadas para a &lt;em&gt;CompCult API&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Em suma, as &lt;em&gt;views&lt;/em&gt; enviam suas ações para os &lt;em&gt;viewmodels&lt;/em&gt;. Estes, por sua vez, podemos ver que ocupam a posição central, enviando e recebendo os dados dos &lt;em&gt;models&lt;/em&gt; e fornecendo os dados para as &lt;em&gt;views&lt;/em&gt;, sem conhecer o que há nelas. Também observam as mudanças de dados que ocorreram nas &lt;em&gt;views&lt;/em&gt; e respondem de acordo com o modelo para a vista.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;As informações mais importantes para o funcionamento do CompCult Mobile se dá pela personalização do cliente nos arquivos de configuração:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lib/config.dart: configurações gerais do aplicativo (cores, nome, url da api, etc);&lt;/li&gt;
&lt;li&gt;pubspec.yaml: configuração das imagens e fontes utilizadas na aplicação;&lt;/li&gt;
&lt;li&gt;android/app/src/main/AndroidManifest.xml: configuração do &lt;em&gt;package name&lt;/em&gt; utilizado nas lojas de aplicações;&lt;/li&gt;
&lt;li&gt;android/app/external: configura as chaves e certificados para aplicação.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feita essas configurações, o cliente poderá executar a aplicação e o &lt;em&gt;white label&lt;/em&gt; gerará uma nova aplicação com as configurações aplicadas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;information-view.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Apesar do Flutter deixar livre para a comunidade como estruturar o projeto, o CompCult Mobile foi iniciado de uma forma confusa, com um MVC mal implementado e uma estruturação de pastas nada agradável. Com isso, em meados de junho de 2020 foi proposta uma refatoração total na arquitetura e nos componentes da aplicação, para adotarmos o que mais tem sido utilizado na comunidade:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pub.dev/packages/slidy&#34;&gt;Slidy&lt;/a&gt; para estruturação e divisão de pastas do projeto;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pub.dev/packages/flutter_modular&#34;&gt;Flutter Modular&lt;/a&gt; para a navegação e rotas da aplicação;&lt;/li&gt;
&lt;li&gt;Padrão arquitetural MVVM, que é o mais utilizado em aplicações móveis e recomendado pelo Google;&lt;/li&gt;
&lt;li&gt;MobX para o controle e gerência de estados da aplicação.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segue abaixo os Pull Request com contribuições para o projeto:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CompCult/compcult-mobile/pull/10&#34;&gt;Jogo da memória implementado no GSDK (ReadAct)&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CompCult/compcult-mobile/pull/11&#34;&gt;Funcionalidade de missões aceitarem arquivos de áudio como respostas&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CompCult/compcult-mobile/pull/12&#34;&gt;Refatoração no layout e na lógica de negócio das telas de login e cadastro de usuários&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segue o link dos commits na branch com a nova reestruturação proposta até o final de 2021:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CompCult/compcult-mobile/commits/support/migracao-mobx&#34;&gt;Reestruturação do projeto com o uso do padrão arquitetural MVVM, MobX e Flutter Modular&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Perfil Político</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/perfil-politico/</link>
       <pubDate>Fri, 30 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/perfil-politico/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Marcella Medeiros Siqueira Coutinho de Almeida.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110492&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:marcella.almeida@ccc.ufcg.edu.br&#34;&gt;marcella.almeida@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/okfn-brasil/perfil-politico&#34;&gt;https://github.com/okfn-brasil/perfil-politico&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto Perfil Político da Open Knowledge Brasil, sendo essa descrição baseada principalmente no modelo C4.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do Perfil Político, dado que existem features que, apesar de já estarem no repositório, ainda não se encontram na versão final do projeto, a exemplo da função de apresentar os tweets dos candidatos.&lt;/p&gt;
&lt;p&gt;Também é válido ressaltar que a interface do projeto, feita em JavaScript, HTML e CSS se encontra em outro &lt;a href=&#34;https://github.com/okfn-brasil/perfil-politico-frontend/&#34;&gt;repositório&lt;/a&gt; e não entra diretamente na descrição arquitetural (apesar de ser citada).&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-e-objetivos&#34;&gt;Descrição Geral e Objetivos&lt;/h2&gt;
&lt;p&gt;Perfil Político é uma plataforma criada para comparar e conhecer o histórico dos candidatos às eleições, nos cargos de: Deputado Federal, Deputado Estadual, Deputado Distrital, Senador, Governador e Presidente. O perfil de cada candidato traz informações de idade, sexo, escolaridade e ocupação, como também de histórico partidário e patrimônio declarado.&lt;/p&gt;
&lt;p&gt;O objetivo é de trazer à sociedade civil uma maneira acessível de se visualizar informações dos candidatos às eleições e permitir uma maior transparência, dado que o Portal do TSE disponibiliza esses dados de forma bruta. Para mais informações a respeito do projeto, clique neste &lt;a href=&#34;https://perfilpolitico.serenata.ai/sobre.html&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Considerando o objetivo do projeto, tem-se então como usuário a própria sociedade civil — cidadãos brasileiros buscando informações sobre os candidatos às eleições do país.&lt;/p&gt;
&lt;p&gt;Para tornar essas informações fáceis de visualizar ao usuário, o sistema do Perfil Político coleta os dados disponibilizados através da plataforma &lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.io&lt;/a&gt;, o qual reúne dados públicos de diferentes portais do país na forma de datasets. Para esse processamento, os dados foram coletados do repositório do Portal do TSE, com as informações ainda brutas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;Para a seção de Containers, é importante considerarmos 3 (três) para a arquitetura do Perfil Político: sua API, o Banco de Dados e o Pré-processador de Dados. O primeiro é um conjunto de rotinas e padrões de programação para acessar a base de dados, desenvolvido em Python através do framework Django.&lt;/p&gt;
&lt;p&gt;A API tem os seguintes endpoints:&lt;/p&gt;
&lt;h4 id=&#34;get-apicandidateyearstatepost&#34;&gt;&lt;code&gt;GET /api/candidate/&amp;lt;year&amp;gt;/&amp;lt;state&amp;gt;/&amp;lt;post&amp;gt;/&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Lista todos os candidatos de um determinado estado para um posto específico.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;get-apicandidatepk&#34;&gt;&lt;code&gt;GET /api/candidate/&amp;lt;pk&amp;gt;/&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Retorna os detalhes de um determinado candidato.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;get-apistatsyearpostcharacteristic&#34;&gt;&lt;code&gt;GET /api/stats/&amp;lt;year&amp;gt;/&amp;lt;post&amp;gt;/&amp;lt;characteristic&amp;gt;/&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Apresenta as estatísticas nacionais para uma determinada característica num posto selecionado.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;get-apistatsstateyearpostcharacteristic&#34;&gt;&lt;code&gt;GET /api/stats/&amp;lt;state&amp;gt;/&amp;lt;year&amp;gt;/&amp;lt;post&amp;gt;/&amp;lt;characteristic&amp;gt;/&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;O mesmo que o anterior, mas agrega por estado.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O Pré-processador de Dados é o que possibilita que os dados estejam limpos e organizados de maneira compreensível, que permita a construção dos gráficos. Para que esse pré-processamento ocorra, faz-se uso de Python e do Jupyter. Por fim, o Banco de Dados foi implementado em PostgreSQL e tem por objetivo armazenar todas as informações coletadas da plataforma do Brasil.io já pré-processadas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Dos containers apresentados, agora faz-se necessário destacar os componentes neles presentes.&lt;/p&gt;
&lt;p&gt;Para o container relacionado ao pré-processamento, temos os componentes do Tratamento de Dados e do Coletor de Dados. Este último é o responsável por, utilizando Django, realizar a coleta dos dados disponibilizados através de datasets na plataforma do Brasil.io, enquanto o componente do Tratamento de Dados é o componente que utiliza o Jupyter para limpar e organizar os dados da maneira que devem ser apresentados na plataforma.&lt;/p&gt;
&lt;p&gt;Conforme mencionado anteriormente, a interface do Perfil Político encontra-se em um repositório separado, mas para a análise dos componentes ela deve ser citada, pois representa o que aqui foi chamado de Interface de Acesso. Este componente é o contato do usuário com a API e é através da Interface de Acesso que se passa para o componente seguinte da API do projeto, o Buscador de Dados. Implementado em Python, ele recupera os dados solicitados no Banco de Dados para que, na interface, eles sejam apresentados da maneira adequada (as visualizações são realizadas utilizando D3).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visão-da-informação&#34;&gt;Visão da Informação&lt;/h2&gt;
&lt;p&gt;Nessa seção é importante relembrar que o percurso dos dados no Perfil Político é encurtado pela coleta das informações em formato acessível fornecidas pelo Brasil.io. Dessa forma, o projeto não tem de lidar com a etapa inicial de raspagem dos dados brutos do Portal do TSE, tendo eles já disponibilizados na forma de datasets.&lt;/p&gt;
&lt;p&gt;Assim, o fluxo de informações se dá a partir da disponibilização dos dados no Brasil.io e da recuperação destes por parte do Perfil Político, que logo em seguida trata esses datasets recuperados, deixando-os devidamente limpos e organizados para a futura geração dos gráficos. Desse ponto, esses dados são armazenados no banco de dados e repassados assim que solicitados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fluxoinformacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Grafana</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/grafana/</link>
       <pubDate>Fri, 30 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/grafana/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Áxel Crispim e Medeiros.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117111889&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:axel.medeiros@ccc.ufcg.edu.br&#34;&gt;axel.medeiros@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/grafana/grafana&#34;&gt;https://github.com/grafana/grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----grafana&#34;&gt;Descrição Arquitetural &amp;ndash; Grafana&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/grafana/grafana&#34;&gt;Grafana&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do Grafana. O foco aqui é a descrição de um serviço específico de análise do Grafana(Dashboard), que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-grafana&#34;&gt;Descrição Geral sobre o Grafana&lt;/h2&gt;
&lt;p&gt;O Grafana é um projeto que tem como objetivo ser uma plataforma para visualização e monitoramento de dados, possibilitando com a construção de &amp;ldquo;dashboards&amp;rdquo; dinâmicos e reutilizáveis. Portanto, a ferramenta possui integração os principais bancos de dados disponíveis no mercado, como descrito &lt;a href=&#34;https://grafana.com/docs/grafana/latest/datasources/&#34;&gt;neste link&lt;/a&gt;, além disso, é possível adicionar múltiplos “datasources” para o mesmo “dashboard”.&lt;/p&gt;
&lt;h2 id=&#34;objetivo&#34;&gt;Objetivo&lt;/h2&gt;
&lt;p&gt;Ser uma plataforma open-source para visualização e monitoramento de dados, atuando em CLI, plugins e outras ferramentas para o suporte para os usuários.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Como o Grafana se trata de uma plataforma, os usuários finais devem ser o mais diversos possíveis, sendo esses divididos em: administradores e comuns. Para os administradores, é necessário um conhecimento da &lt;strong&gt;linguagem de consulta&lt;/strong&gt; da sua fonte de dados, e os comuns, apenas acesso a um navegador Web moderno.&lt;/p&gt;
&lt;p&gt;A comunicação com a fonte pode ser local ou externa, geralmente, utilizando o protocolo TCP e uma porta para o acesso, com o SGBD previamente configurado para o acesso remoto. Sendo essa consulta diferenciada para cada banco de dados.&lt;/p&gt;
&lt;p&gt;O diagrama de contexto abaixo ilustra quais entidades interagem com o Grafana.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;A plataforma Grafana é dividida em três grandes containers, sendo eles: Frontend, GrafaInfra e Backend. Apesar que o Backend não sendo o foco dessa documentação.&lt;/p&gt;
&lt;p&gt;O Frontend é a parte visual do projeto, com CoreModule responsável pelo inicialização do AngularJS e serviços básicos, como cards, forms e configurações globais. Tornando o domínio das  funcionalidades responsáveis por todas as Features do projeto, como adição de Datasource, Dashboard, painéis, etc. Com a utilização do Redux a principal comunicação no proejto.&lt;/p&gt;
&lt;p&gt;O GrafanaInfra(ou pacotes)possui o mesmo objetivo da infra do &lt;strong&gt;Clean Architecture&lt;/strong&gt;, cujo objetivo é isolar o projeto de bibliotecas externas. Além dos containers mencionados abaixo, possui também  umresponsável por testes end-to-end e uma CLI para criação de plugins, facilitando o desenvolvimento da plataforma.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;Diagrama de Containers&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;A maioria das funcionalidade dos sistema estão presentes no pacote &lt;code&gt;features&lt;/code&gt;, com esssas funções seguindo a padronização definida no &lt;a href=&#34;https://github.com/grafana/grafana/blob/master/contribute/style-guides/frontend.md&#34;&gt;style-guide&lt;/a&gt;. Assim, os componentes do sistema seguem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;feature/state&lt;/code&gt;: todo código responsável pela lógica de domínio e estado da funcionalidade. Seguindo a arquitetura Redux, com stores, actions e reducers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feature/containers/ExamplePage.tsx&lt;/code&gt;: Página ou componente central da sua funcionalidade, onde vai carregar todos os componentes presentes na feature.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feature/componets&lt;/code&gt;: todos os componentes React que estão compondo sua funcionalidade, geralmente, divididos por pastas por componente, sendo essas pastas possuindo a lógica, estilização e testes de componentes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para a utilização de bibliotecas externas, é necessário adicionar código no GrafaInfra, sendo esses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@grafana/ui&lt;/code&gt;: para componentes e tipos relacionados a UI.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@grafana/data&lt;/code&gt;: para modelo de dados e utilitários utilizados.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@grafana/runtime&lt;/code&gt;: para acesso a serviços da plataforma Grafana.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segue um diagrama contendo apenas a parte da layout dos componenes&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;Diagrama de Containers&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural - Anki</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/anki/</link>
       <pubDate>Thu, 29 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/anki/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Igor Seabra.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210304&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:igor.seabra@ccc.ufcg.edu.br&#34;&gt;igor.seabra@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ankitects/anki&#34;&gt;https://github.com/ankitects/anki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----anki&#34;&gt;Descrição arquitetural &amp;ndash; Anki&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;anki_icon.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;(Imagem: Alex Fraser/Anki)&lt;/p&gt;
&lt;p&gt;Este documento descreve a arquitetura do aplicativo &lt;a href=&#34;https://github.com/ankitects/anki&#34;&gt;Anki&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-o-anki&#34;&gt;Sobre o Anki&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.ankiweb.net/&#34;&gt;Anki&lt;/a&gt; é um serviço open source e gratuito para auxiliar na memorização de conteúdos de forma eficiente, automática e customizável.&lt;/p&gt;
&lt;p&gt;Ele permite ao usuário estudar cartões (compostos geralmente por uma pergunta na frente e sua resposta no verso) através de um sistema de repetição espaçada, ou seja, mostrando os cartões novamente em intervalos de tempo baseados no quão bem o usuário sabe o conteúdo daquele cartão. Os cartões podem possuir texto, imagens, áudio e vídeo, permitindo que o Anki seja usado para estudar praticamente qualquer tipo de conteúdo, como idiomas, conteúdo acadêmico ou artístico.&lt;/p&gt;
&lt;p&gt;Os usuários podem criar seus próprios baralhos com qualquer conteúdo nos cartões ou usar baralhos prontos criados por outros usuários, disponíveis na plataforma &lt;a href=&#34;https://ankiweb.net/shared/decks/&#34;&gt;AnkiWeb&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-monitoramento-do-twitter&#34;&gt;O Serviço de monitoramento do twitter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Disponibilizar um serviço para aprendizagem através de repetição espaçada.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Promoção de um serviço de repetição espaçada com cartões que automatiza e abstrai do usuário o que for possível, para que ele foque no estudo dos cartões.&lt;/li&gt;
&lt;li&gt;Flexibilidade na customização da apresentação dos cartões (como apresentação de cartões novos e intervalos de repetições)&lt;/li&gt;
&lt;li&gt;Formatação dos cartões com diversos tipos de mídia, como texto, imagens, áudio e vídeo&lt;/li&gt;
&lt;li&gt;Disponibilizade do serviço em plataforma web e aplicativos para Windows, Linux, Mac OS X, Android e iOS&lt;/li&gt;
&lt;li&gt;Acesso do estado mais recente da coleção do usuário em qualquer dispositivo, através da sincronização com o servidor&lt;/li&gt;
&lt;li&gt;Visualização de métricas de utilização, como índice de acertos, previsão de revisões, dificuldade dos cartões e tempo necessário para estudo&lt;/li&gt;
&lt;li&gt;Biblioteca de baralhos disponíveis para uso construída pela comunidade no serviço AnkiWeb&lt;/li&gt;
&lt;li&gt;Extensão da funcionalidade através de add-ons que podem ser desenvolvidos e instalados pelo usuário&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;anki_contexto.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Usuário&lt;/strong&gt;: O usuário deseja usar o Anki para criar e estudar baralhos com os cartões que contém as informações. Para isso, ele interage com a interface principal do Anki e com o AnkiWeb (Shared).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anki&lt;/strong&gt;: Na interface principal, o usuário pode ver seus baralhos, adicionar, editar ou estudar cartões, ver informações estatísticas e editar configurações. O Anki sincroniza todo seu estado com o AnkiWeb.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AnkiWeb&lt;/strong&gt;: No servidor AnkiWeb, ficam armazenados os dados e baralhos dos usuários. O Anki sincroniza os dados com o AnkiWeb para que o usuário não os perca e possa acessá-los de qualquer dispositivo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AnkiWeb (Shared)&lt;/strong&gt;: Essa é a plataforma na web na qual o usuário pode pesquisar e baixar baralhos feitos por outros usuários e fazer upload de seus baralhos para a plataforma pública.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;anki_containers.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Versões da interface do Anki&lt;/strong&gt;: O Anki está disponível em diversas plataformas.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Anki (Windows, Linux, Mac OS X)&lt;/strong&gt;: versões do aplicativo desktop do Anki. Possuem todas as funcionalidades.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AnkiWeb (Decks)&lt;/strong&gt;: aplicativo do Anki no navegador. Permite apenas adicionar e editar notas e estudar baralhos, sem componentes como gerenciador de configurações, editor de tipos de nota, visualização de métricas de utilização e add-ons (mais informações abaixo).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AnkiMobile&lt;/strong&gt;: aplicativo do Anki para iOS. Possui todas as funcionalidades da versão desktop, exceto add-ons. Com o objetivo de apoiar a equipe de desenolvimento, é a única versão paga do Anki.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AnkiDroid&lt;/strong&gt;: aplicativo do Anki para Android. Possui todas as funcionalidades da versão desktop, exceto add-ons.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Add-ons&lt;/strong&gt;: o usuário pode buscar add-ons desenvolvidos pela comunidade que complementam a funcionalidade do Anki. Os add-ons são visualizados através do AnkiWeb (Shared), mas o próprio aplicativo do Anki se encarrega de baixar e instalar. Exemplos de add-ons: dicionário embutido, assistente de foco, edição de cartões em massa, leitor de tela.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Banco de Dados SQLite&lt;/strong&gt;: um banco de dados completo é criado para armazenar a coleção de cada usuário. Cada instalação local do aplicativo do Anki, além do próprio servidor AnkiWeb, possui uma cópia do banco. As mudanças são sincronizadas com o AnkiWeb automaticamente pelo aplicativo ao início e final de cada sessão ou a pedido do usuário. O Anki resolve conflitos automaticamente, mas algumas mudanças, como a adição de um estilo novo de cartão, requerem que a cópia do banco no AnkiWeb seja apagada e substituída completamente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Obs.&lt;/strong&gt;: o usuário que deseja usar o serviço do Anki em um dispositivo iOS sem comprar o aplicativo pode fazer isso através do AnkiWeb (Decks) no navegador, mas precisará de acesso ao aplicativo em outro dispositivo, pois o aplicativo no navegador não possui todas as funções necessárias.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;anki_componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Obs.&lt;/strong&gt;: os componentes com contorno em &lt;strong&gt;vermelho&lt;/strong&gt; não estão disponíveis na plataforma &lt;strong&gt;AnkiWeb (Decks)&lt;/strong&gt; no navegador, apenas nos aplicativos para desktop e celular.&lt;/p&gt;
&lt;p&gt;Há uma relação próxima entre os gerenciadores de configurações, baralhos, tipos de cartões, notas e cartões:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma &lt;strong&gt;configuração&lt;/strong&gt; é um conjunto de parâmetros que define quantos cartões novos serão mostrados por dia, o fator de multiplicação para o tempo em que o cartão será mostrado novamente de acordo com a resposta, a quantidade diária máxima de revisões etc. Pode ser criado qualquer número de configurações e uma configuração pode ser usada por qualquer quantidade de baralhos.&lt;/li&gt;
&lt;li&gt;Um &lt;strong&gt;tipo de nota&lt;/strong&gt; é um esquema que define quais campos uma nota terá. O padrão são dois campos (frente e verso), mas podem ser adicionados mais tipos com outros campos (como mídia e informações adicionais). Um tipo de nota possui um ou mais &lt;strong&gt;tipos de cartão&lt;/strong&gt;. O tipo padrão possui o campo da frente na frente e o campo do verso no verso, mas isso pode ser customizado (e deve, caso campos além da frente e verso sejam adicionados). Os cartões são escritos em HTML.&lt;/li&gt;
&lt;li&gt;Uma &lt;strong&gt;nota&lt;/strong&gt; é uma instância de um tipo de nota, com as informações a serem inseridas nos campos daquele tipo. Uma nota representa uma quantidade de cartões igual à quantidade de tipos de cartão naquele tipo de nota.&lt;/li&gt;
&lt;li&gt;Um &lt;strong&gt;baralho&lt;/strong&gt; é um conjunto de notas. As notas de um baralho não precisam ser todas do mesmo tipo. O conjunto de cartões de um baralho é a união dos cartões de cada nota. Permitir ao usuário estudar os cartões de um baralho é o principal objetivo do Anki.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O Anki já vem com alguns tipos de nota padrão, para que não seja necessário que o usuário saiba gerenciá-los ou precise criar as formatações para os cartões em HTML.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;anki_informacao.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Obs.&lt;/strong&gt;: no diagrama de informação, as setas e contornos pontilhados roxos indicam que aquele fluxo ou etapa é opcional.&lt;/p&gt;
&lt;p&gt;O objetivo do usuário do Anki é estudar seus baralhos; para isso, ele precisa criá-los, tendo a opção de buscar um pronto no AnkiWeb (Shared) ou criar um novo, seguindo o fluxo de informação indicado. Já tendo baralhos com cartões, o usuário sincroniza sua coleção com o AnkiWeb antes e depois de estudá-los.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do Netflix Dispatch</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/dispatch/</link>
       <pubDate>Thu, 29 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/dispatch/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lucas de Medeiros Nunes Fernandes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110210&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lucas.medeiros.fernandes@ccc.ufcg.edu.br&#34;&gt;lucas.medeiros.fernandes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Netflix/dispatch&#34;&gt;https://github.com/Netflix/dispatch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----netflix-dispatch&#34;&gt;Descrição Arquitetural &amp;ndash; Netflix Dispatch&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/Netflix/dispatch&#34;&gt;Dispatch&lt;/a&gt;, desenvolvido pela Netflix. Essa descrição, assim como a produção de seus diagramas, foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição&#34;&gt;Descrição&lt;/h2&gt;
&lt;p&gt;O Dispatch é um &lt;strong&gt;framework de gerenciamento de crises&lt;/strong&gt;, criado para auxiliar no processo de abertura, acompanhamento e fechamento de incidentes de segurança de uma aplicação ou plataforma.&lt;/p&gt;
&lt;p&gt;Ele ajuda a gerenciar tais incidentes de maneira eficaz, oferecendo integração com ferramentas comumente utilizadas por organizações, como Slack, GSuite, Jira etc. Ao aproveitar a familiaridade existente entre todas essas ferramentas, é provido um orquestrador de incidentes e notificações, ao invés de ter que gastar esforços em integrações individuais para cada uma.&lt;/p&gt;
&lt;p&gt;Ou seja, com o Dispatch, as preocupações relacionadas em criar recursos, reunir participantes, enviar notificações, rastrear tarefas e auxiliar nas revisões pós-incidentes são praticamente reduzidas a zero, permitindo que o time realmente se concentre apenas em resolver o problema!&lt;/p&gt;
&lt;h3 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h3&gt;
&lt;p&gt;Em sua essência, o Dispatch visa gerenciar todo o ciclo de vida de um incidente, fornecer aos indivíduos relacionados à crise todo o contexto de que precisam para resolvê-la, prover integrações embutidas com ferramentas como Slack, GSuite e Jira a partir de seus plugins e também ser expansível em relação a essas integrações, permitindo que novos plugins para outras ferramentas (Zendesk, Microsoft Teams, etc. por exemplo) sejam desenvolvidos pelo time. Além disso, também busca oferecer uma solução para gerenciamento de crises internas independente de casos de uso de segurança específicos.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos específicos&lt;/h3&gt;
&lt;p&gt;Ao introduzir um processo automatizado para gerenciar e responder a incidentes de segurança, a Netflix tem como objetivos reusar ferramentas existentes que os times já utilizavam para lidar com as crises, reduzir a curva de aprendizado para contribuir com a resolução dos incidentes, prover uma API unificada para usuários internos e ferramentas, padronizar a comunicação durante a crise e catalogar, salvar e analizar os dados dos incidentes para acelerar a sua resolução.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Lidar com crises internas que levam a disrupções parciais ou totais de um sistema ou plataforma é uma tarefa muito estressante e antiga. Porém, mesmo com tantos casos existentes, ainda não existem muitas soluções unificadas que facilitem o processo e a comunicação interna durante o ciclo de vida do incidente. Sempre surgem questões como &lt;em&gt;Qual o escopo?&lt;/em&gt;, &lt;em&gt;Quem pode me ajudar?&lt;/em&gt;, &lt;em&gt;Quem eu chamo para compor o time que vai resolver?&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O Dispatch se dispõe a mitigar esse cenário, ao atacar quatro aspectos principais de gerenciamento de crise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gerenciamento de Recursos&lt;/strong&gt; &amp;ndash; Gerenciamento e análise dos dados e metadados coletados do incidente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agrupamento de indivíduos&lt;/strong&gt; &amp;ndash; Entender o melhor cenário para formar times de resolução dos incidentes e agrupar &lt;em&gt;participantes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gerenciamento do Ciclo de Vida&lt;/strong&gt; &amp;ndash; Prover ferramentas ao &lt;em&gt;comandante do incidente&lt;/em&gt; para gerenciar de maneira mais fácil o ciclo de vida de um incidente.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Incident Learning&lt;/strong&gt;&lt;/em&gt; &amp;ndash; Se basear em incidentes anteriores para acelerar a resolução de incidentes futuros.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANTE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Os &lt;strong&gt;Comandantes&lt;/strong&gt; são os indivíduos responsáveis por conduzir o incidente à resolução.&lt;/p&gt;
&lt;p&gt;Os &lt;strong&gt;Participantes&lt;/strong&gt; são os indivíduos especialistas que foram adicionados no time para ajudar a resolver o incidente.&lt;/p&gt;
&lt;p&gt;Os &lt;strong&gt;Recursos&lt;/strong&gt; são documentos, &lt;em&gt;screenshots&lt;/em&gt;, registros (logs), ou qualquer outro tipo de informação digital que é utilizada durante um incidente.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;O comandante do incidente cria um incidente com algunas dados básicos. A partir disso, o Dispatch cria todo um &lt;strong&gt;Fluxo de Incidente&lt;/strong&gt;, que consiste na automatização de tarefas como criação de canais de comunicação, criação do documento de incidente, agrupamento e orientação de indivíduos participantes, notificações a stakeholders que precisam estar cientes da crise, revisar a performance de todo o processo, acompanhar ações a serem executadas após o término e gerar aprendizado por meio da estruturação do conhecimento informal.&lt;/p&gt;
&lt;p&gt;Tudo isso é possível graças à integração com diversas ferramentas através de seus plugins. A análise dos dados é feita de maneira interna, mas ações efetivas na organização e comunicação durante o incidente é totalmente baseada na integração com ferramentas como Slack (criação de canais), GSuite (criação de documentos e notificação de stakeholders chave), Jira (criação de tarefas e agrupamento de participantes), ou qualquer outra ferramenta a empresa utiliza e oferecer suporte a integração, por exemplo, Zendesk (abertura de tickets).&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;dispatch_context.png&#34; style=&#34;width: 75%;&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Diagrama de contexto do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A implantação do Dispatch requer um (sub)domínio próprio da empresa e depende de vários serviços para funcionar, todos orquestrados pelo &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para criar um incidente, o comandante interage com a UI do Dispatch passando apenas dados básicos relacionados à crise. Essa UI fornecesse um pequeno formulário de fácil preenchimento, e pode ser acessada a partir da URL abaixo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://&amp;lt;seu-dominio-dispatch&amp;gt;/incidents/report
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Uma vez submetido, é apresentado ao usuário uma tela com todos os recursos que ele precisa para começar a gerenciar o incidente: tickets, video conferência, conversa, documentos etc Depois que um incidente é criado, o Dispatch vai formar times de participantes automaticamente, cuja regra de agrupamento é definida no Admin UI da aplicação. Cada participante recebe um e-mail e uma mensagem no Slack com os recursos e informação para orientá-los nesse incidente.&lt;/p&gt;
&lt;p&gt;Quando as equipes precisam gerenciar muitos incidentes, o Dispatch fornece um admin feito em &lt;strong&gt;VueJS&lt;/strong&gt;. Essa interface também é onde é feito o gerenciamento do conhecimento obtido a partir dos incidentes, a partir de termos comuns e suas definições, indivíduos, equipes e serviços, e é usado em incidentes futuros.&lt;/p&gt;
&lt;p&gt;Como já citado anteriormente, o sistema utiliza plugins em sua arquitetura para realizar o gerenciamento de incidentes de maneira a possibilitar integrações com ferramentas corporativas já existentes, e o plugin do &lt;strong&gt;Slack&lt;/strong&gt; é uma das integrações mais importantes embutidas no Dispatch, ou seja, não precisa ser implementada pelo time de desenvolvimento. Este plugin, além de criar canais de comunicação e notificar de atualizações no incidente através desse plugin, também disponibiliza alguns comandos específicos para o comandante do incidente disponíveis para serem usados dentro de um canal de incidente. Esses comandos estão listados abaixo, juntamente com um link para ler mais sobre eles.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-add-timeline-event&#34;&gt;/dispatch-add-timeline-event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-assign-role&#34;&gt;/dispatch-assign-role&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-engage-oncall&#34;&gt;/dispatch-engage-oncall&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-my-tasks&#34;&gt;/dispatch-list-my-tasks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-participants&#34;&gt;/dispatch-list-participants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-resources&#34;&gt;/dispatch-list-resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-tasks&#34;&gt;/dispatch-list-tasks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-workflows&#34;&gt;/dispatch-list-workflows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-incidents&#34;&gt;/dispatch-list-incidents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-notifications-group&#34;&gt;/dispatch-notifications-group&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-report-executive&#34;&gt;/dispatch-report-executive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-report-incident&#34;&gt;/dispatch-report-incident&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-report-tactical&#34;&gt;/dispatch-report-tactical&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-update-incident&#34;&gt;/dispatch-update-incident&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-update-participant&#34;&gt;/dispatch-update-participant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hawkins.gitbook.io/dispatch/user-guide/incident-commander#%2Fdispatch-list-workflow&#34;&gt;/dispatch-run-workflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além do &lt;strong&gt;Slack&lt;/strong&gt;, o Dispatch oferece plugins embutidos para &lt;strong&gt;GSuite&lt;/strong&gt;, &lt;strong&gt;Jira&lt;/strong&gt;, &lt;strong&gt;Opsgenie&lt;/strong&gt;, &lt;strong&gt;PagerDuty&lt;/strong&gt; e &lt;strong&gt;Zoom&lt;/strong&gt;, porém a arquitetura de plugins implementada permite integrar quaisquer outras ferramentas que uma organização está utilizando, desde que tal ferramenta ofereça suporte a integrações.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;dispatch_container.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Diagrama de container do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para interagir com o formulário de cadastro de incidente e com o Admin UI, o usuário se autentica. Então, para lidar com as requisições, o Dispatch fornece uma API com o serviço principal para criação e gerenciamento do fluxo de incidente.&lt;/p&gt;
&lt;p&gt;Tal serviço, &lt;strong&gt;Incident Service&lt;/strong&gt;, se comunica com outros serviços que auxiliam na tarefa de gerenciamento, por exemplo, serviços como &lt;strong&gt;Task Service&lt;/strong&gt;, responsável pela criação de atividades e ações relacionadas ao incidente, &lt;strong&gt;Resources Services&lt;/strong&gt;, responsável pelo gerenciamento dos recursos relacionados a um incidente (ver definição de recurso na seção Contexto) e &lt;strong&gt;Participants Services&lt;/strong&gt;, responsável pela alocação e estruturação dos times que vão atuar na resolução do incidente.&lt;/p&gt;
&lt;p&gt;O serviço de incidente também é responsável por notificar os plugins responsáveis pelas integrações a respeito das atualizações de um incidente ou de seus recursos. A partir disso, cada plugin segue a sua estratégia para interagir com a sua ferramenta externa específica, automatizando ações que originalmente seriam feitas manualmente pelo comandante do incidente. Observe o diagrama de componentes abaixo, que ilustra esses serviços, assim como seus relacionamentos.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;dispatch_component.png&#34; style=&#34;width: 90%;&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Diagrama de componentes do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Durante o ciclo de vida de um incidente, ele passa por estados até que atinga um certo grau de estabilidade. Até lá, muita informação é gerada e processada pelo Dispatch, para que seja possível gerar um conhecimento a ser utilizado para resolver incidentes similares de maneira mais eficiente no futuro. Até mesmo quando um incidente é marcado como &lt;strong&gt;estável&lt;/strong&gt;, o Dispatch continua a ajudar com o gerenciamento de incidente criando recursos adicionais como o documento &lt;em&gt;Post Incident Review&lt;/em&gt;. O diagrama de estados abaixo ajuda a ilustrar como ocorre esse processo.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;dispatch_information.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Visão da informação do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Stremio Web</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/stremio-web/</link>
       <pubDate>Thu, 29 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/stremio-web/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;stremio-web-header.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Fernando Jorge Pereira Júnior.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210904&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:fernando.junior@ccc.ufcg.edu.br&#34;&gt;fernando.junior@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Stremio/stremio-web&#34;&gt;https://github.com/Stremio/stremio-web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-stream---stremio-web&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de stream - Stremio Web&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://www.stremio.com/translation/br/&#34;&gt;Stremio Web&lt;/a&gt;. A descrição arquitetural aqui apresentada foi construída tendo como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-stremio-web&#34;&gt;Descrição Geral sobre o Stremio Web&lt;/h2&gt;
&lt;p&gt;O Stremio é uma solução integrada que possibilita aos seus usuários assistir e organizar conteúdo de vídeo a partir da instalação de complementos (plugins). Possui como objetivo disponibilizar diversos filmes, programas  de TV, canais da Web, esportes, ouvir podcasts e muitos outros serviços que são disponibilizados através dos addons.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-stream---stremio-web&#34;&gt;O serviço de stream - Stremio Web&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço de stream web  que permite aos seus usuários assistir organizar conteúdos de todos os tipos de mídia digital a partir dos mais de mais de 50 addons (plugins) presentes no catálogo.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Disponibilizar diversos filmes, programas  de TV, canais da Web, esportes, ouvir podcasts e muitos outros serviços aos usuários do sistema.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O diagrama de contexto apresentado a seguir mostra uma visão geral dos sistemas com os quais o Stremio Web se comunica e os perfis de usuários que interagem com o sistema.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;stremio-web-contexto.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;A comunicação entre pode ser resumida da seguinte forma:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O Stremio Web se comunica com a aplicação local do Stremio que obrigatoriamente deve estar instalada na máquina do usuário para que as mídias possam ser executadas.&lt;/li&gt;
&lt;li&gt;O Stremio se comunica com os addons (plugins) que são responsáveis por  apoiar a busca pelas mídias a serem transmitidas.&lt;/li&gt;
&lt;li&gt;O Stremio se comunica com base de dados para permitir os serviços de login e cadastro.&lt;/li&gt;
&lt;li&gt;O Stremio se comunica com base de dados do IMDB para coletar as informações referentes às mídias.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O diagrama de containers apresentado a seguir mostra os elementos internos existentes no Stremio Web e como se comunicam com os serviços internos e externos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;stremio-web-containers.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O sistema é composto por três containers: o frontend, backend e o V3 Cinemeta. Suas responsabilidades podem ser resumidas da seguinte forma:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frontend possibilita a interação com o usuário,  realizada através de uma interface desenvolvida em React.&lt;/li&gt;
&lt;li&gt;Backend responsável pela comunicação externa com o banco de dados para gerenciar os dados referentes ao usuário, é feito utilizando Nodejs&lt;/li&gt;
&lt;li&gt;V3 Cinemeta responsável pela comunicação externa com o IMDB  e gerencia as informações referentes às mídias.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama de componentes apresentado a seguir mostra os elementos internos existentes no backend do Stremio Web e como se comunica com os serviços internos e externos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;stremio-web-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;O componente backend  é composto por três componentes: o gerenciador de usuários, gerenciador de segurança e o gerenciador de addons. Suas responsabilidades podem ser resumidas da seguinte forma:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gerenciador de usuários é responsável pelo controle de usuário, realizando atividades como cadastro e atualização.&lt;/li&gt;
&lt;li&gt;Gerenciador de segurança é responsável pelo controle de acesso aos recursos, realizando atividades como autenticação dos usuários.&lt;/li&gt;
&lt;li&gt;Gerenciador de addons é responsável pelo controle de addons ao usuários, realizando atividades como cadastro e remoção de addons da conta do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama apresentado a seguir mostra o fluxo da informação no Stremio Web para a execução de uma mídia.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;stremio-web-informacao.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;p&gt;O usuário através do frontend solicita para realizar  login na aplicação, esta solicitação é enviada ao backend que busca no banco de dados as informações e válida a autenticação do usuário. Logo em seguida o usuário pode fazer uma requisição para que um mídia seja reproduzida, fazendo o frontend se comunicar com V3 Cinemeta para buscar os dados da mídia no IMDB de acordo com a localização informada pelos addons. Depois da coleta desses dados o frontend se comunica com o Stremio instalado localmente para que a reprodução da mídia aconteça.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o PopCorn</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/popcorn/</link>
       <pubDate>Thu, 29 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/popcorn/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Henrique Dos Santos Soares.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118210761&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.soares@ccc.ufcg.edu.br&#34;&gt;joao.soares@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/popcorn-official/popcorn-desktop&#34;&gt;PopCorn-Desktop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----popcorn-desktop&#34;&gt;Descrição Arquitetural &amp;ndash; popcorn-desktop&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;2.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Este documento descreve a arquitetura do serviço &lt;a href=&#34;https://github.com/popcorn-official/popcorn-desktop&#34;&gt;popcorn-desktop&lt;/a&gt;.
As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.
É importante destacar que não será apresentada toda a documentação da arquitetura do PopCorn.O foco aqui será apresentar a descrição arquitetural do serviço de desktop disponibilizado pelo PopCorn&lt;/p&gt;
&lt;h1 id=&#34;descrição-geral-sobre-o-popcorn-desktop&#34;&gt;Descrição Geral sobre o Popcorn-Desktop&lt;/h1&gt;
&lt;p&gt;É um programa desktop que tem como objetivo a propagação de filmes e séries assim como a Netflix, porém tanto o seu download quanto o seu conteúdo é gratuito, e o melhor de tudo diferentemente do Netflix, o
conteúdo do Popcorn é praticamente infinito.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;É Multiplataforma;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h2&gt;
&lt;p&gt;A implementação desse serviço permite que o usuaria assista filmes ou series com o streaming de torrents de forma gratuita.&lt;/p&gt;
&lt;h2 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h2&gt;
&lt;p&gt;O serviço do Popcorn Time tem como objetivo ser uma alternativa gratuita para serviços de vídeo sob demanda em assinatura, como o Netflix, Amazon Prime Video , Disnay Plus e etc.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;3.gif&#34; alt=&#34;intelliSense&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contexto&#34;&gt;Contexto&lt;/h1&gt;
&lt;p&gt;É necessário baixar o instalador do popcorn e abrir o arquivo de instalação. Depois deste processo, pode começar a usar o sistema. O contexto do sistema se resume ao usuário conseguir acessar o serviço de streaming, navegar por sua galeria e conseguir assistir.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O usuário instala o aplicativo em seu computador&lt;/li&gt;
&lt;li&gt;O sistema consegue trocar informações com o armazenamento de dados para criar ou fazer login.&lt;/li&gt;
&lt;li&gt;O usuário tem acesso ao sistema&lt;/li&gt;
&lt;li&gt;O sistema busca as informações dos streamings de vídeos e criar uma galeria para o usuário escolher&lt;/li&gt;
&lt;li&gt;A plataforma consegue disponibilizar os Streaming de vídeos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;contexto.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;p&gt;O sistema popcorn pode ser dividida basicamente em três containers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sistema Desktop :  foi implementado usando a linguagem JavaScript. O Sistema consegue entregar o conteúdo estático da aplicação.&lt;/li&gt;
&lt;li&gt;Streaming :  foi implementado usando a linguagem JavaScript. Tem como responsabilidade permitir que os usuários consigam reproduzir os arquivos de vídeos.&lt;/li&gt;
&lt;li&gt;API Application : foi implementado usando a linguagem JavaScript e NodeJs. Tem a responsabilidade de fornecer funcionalidades e a lógica de negócio para o sistema.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;containers.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Gerenciador de usuário : Responsável pelo CRUD de usuários&lt;/li&gt;
&lt;li&gt;Autenticação : Responsável por verificar se o token é válido do usuário e ter um controle de acesso dos usuários.&lt;/li&gt;
&lt;li&gt;Gerenciador de Streaming: É responsável por controlar o fluxo de Streaming. Esse componente faz uma conexão com um sistema externo via p2p então ele consegue organizar o download do torrent de forma sequencial para que o usuário consiga assistir de forma fluida.Enquanto o filme é assistido o componente salva o arquivo em memória usando o &lt;a href=&#34;https://github.com/louischatriot/nedb&#34;&gt;NEDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;componentes.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;O objetivo do do popcorn é reduzir o tempo de espera para assistir a filmes baixados pela internet por meio do streaming a partir de torrents de fontes confiáveis. A visão de informação a seguir retrata o fluxo de um usuário para o consumo de uma streaming.
O usuário faz a autenticação no sistema é aprovado e prossegue para a catálogo onde consegue visualizar todos os filmes/séries disponíveis.O usuário seleciona um filme/série e tem a possibilidade de assistir ao fim o usuário pode assistir novamente o streaming ou voltar ao catálogo.&lt;br&gt;
&lt;img src=&#34;visao.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação de Arquitetura da Engine de Jogos: GODOT</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/godot/</link>
       <pubDate>Sat, 24 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/godot/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thomaz Morais.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211053&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thomaz.morais@computacao.ufcg.edu.br&#34;&gt;thomaz.morais@computacao.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/godotengine/godot&#34;&gt;https://github.com/godotengine/godot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-godot&#34;&gt;Descrição Geral sobre o GODOT&lt;/h2&gt;
&lt;p&gt;O Godot é uma engine de criação de jogos 2d e 3d gratuita e de código aberto. Ela é capaz de exportar jogos para a maior parte das plataformas disponíveis na atualidade (video games, mobile, desktop e web) e ela traz uma série de ferramentas que facilitam na hora de desenvolver jogos. O objetivo deste projeto é fazer uma descrição arquitetural desta engine. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://godotengine.org/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Criar jogos multiplataforma através de sistemas de scriptagem e programação visual que sejam intuitivos para os desenvolvedores e competitivo com outras engines de jogos.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Compilar, utilizando os arquivos estruturados pelo programa (sons, imagens, scripts e nodes), jogos. Nesta documentação em específico será feito um panorama geral de como funciona o GODOT na questão dos arquivos, compilação e desenvolvimento de um projeto.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O GODOT é uma aplicação que não possui muitos serviços ao redor dele. A engine de desenvolvimento de jogos está dividida basicamente na própria aplicação de desenvolvimento e nos compiladores de plataformas específicas. Ilustrados na Figura 1 temos a demonstração do diagrama de contexto da aplicação onde há um usuário que utiliza o GODOT para desenvolvimento, e neste caso específico temos o GODOT se utilizando das ferramentas do visual studio para gerar uma aplicação executável que poderá ser testada pelo próprio desenvolvedor.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;
Figura 1 - Diagrama de contexto do GODOT&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O GODOT é composto por um único container que contém todas as ferramentas dentro dele próprio.&lt;/p&gt;
&lt;p&gt;Ele é composto pelo editor de nodes. Nodes são a únidade básica do projeto. Tudo que existe dentro de um projeto é uma node. O personagem, a fase, objetos físicos, estáticos, objetos que reproduzem som, tudo isto é chamado de node dentro de um projeto do godot. O editor de nodes por sua vez possui um sistema de edição de scripts para adicionar funcionalidades a determinados nodes. Além disso o GODOT conta com um sistema de importação de arquivos para administrar os arquivos que serão utilizados nos projetos (e.g. música, modelos, imagens, etc) e esse sistema de arquivo é composto por diretórios e arquivos que estão apenas organizados por pastas dentro de um projeto do GODOT.&lt;/p&gt;
&lt;p&gt;Por fora, o GODOT utiliza das ferramentas do visual studio community 2017 para executar a compilação do projeto para windows, criando assim um arquivo executável do projeto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig1&#34;&gt;
Figura 2 - Diagrama de Containers&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O GODOT roda dentro da máquina do usuário, na aplicação o usuário é capaz de editar configurações do projeto, nodes, scripts e importar arquivos. Temos também a parte de configuração de projeto que pode alterar para qual plataformas queremos exportar o projeto que (neste caso para desktop) utiliza as ferramentas do visual studio community para compilar o projeto para a plataforma windows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig1&#34;&gt;
Figura 3 - Diagrama de Componentes&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da Informação&lt;/h3&gt;
&lt;p&gt;A informação que o GODOT lida em si é o projeto do jogo. O projeto do jogo é um conjunto de arquivos de nodes, sons, imagens, vídeos, modelos 3d, etc que compõem um projeto de jogo. Na Figura 4 é demonstrado um diagrama de visão da informação que mostra os possíveis estados de um projeto. A princípio temos a criação do projeto, em seguida temos o projeto em desenvolvimento (onde o usuário poderá editar o projeto adicionando imagens, códigos e implementando features), depois desta etapa temos a compilação. A compilação pode resultar em erro (e o projeto vai retornar ao desenvolvimento) ou na geração de um arquivo executável do projeto. Se no projeto estiver faltando features ele volta ao desenvolvimento. Se não o projeto está pronto para lançamento ou compartilhamento em uma plataforma qualquer que o desenvolvedor decidir lançar.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;visao.png&#34; alt=&#34;fig1&#34;&gt;
Figura 4 - Diagrama da Informação&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do cep-promise</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/cep-promise/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/cep-promise/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Diego Amancio Pereira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210716&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:diego.pereira@ccc.ufcg.edu.br&#34;&gt;diego.pereira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/BrasilAPI/cep-promise&#34;&gt;https://github.com/BrasilAPI/cep-promise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---cep-promise&#34;&gt;Descrição Arquitetural - cep-promise&lt;/h1&gt;
&lt;p&gt;Neste documento, é descrito um serviço de consulta de cep, o &lt;a href=&#34;https://github.com/BrasilAPI/cep-promise&#34;&gt;cep-promise&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-cep-promise&#34;&gt;Descrição geral sobre o cep-promise&lt;/h2&gt;
&lt;p&gt;O cep-promise é uma biblioteca de busca por cep de forma concorrente  com alta disponibilidade integrado com 3 serviços (Correios, ViaCEP e WideNet).&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Disponibilizar uma busca por cep rápida , eficiente sem depender totalmente de um serviço de busca de cep e ter fácil de utilização;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Chakra UI</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/chakra-ui/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/chakra-ui/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lucas Arcoverde do Nascimento.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211049&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lucas.arcoverde.nascimento@ccc.ufcg.edu.br&#34;&gt;lucas.arcoverde.nascimento@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/chakra-ui/chakra-ui&#34;&gt;https://github.com/chakra-ui/chakra-ui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----chakra-ui&#34;&gt;Descrição Arquitetural &amp;ndash; Chakra UI&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Nome: Chakra UI&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chakra-ui/chakra-ui&#34;&gt;Chakra UI&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Chakra é um framework React que implementa um design system buscando facilitar o desenvolvimento de aplicativos ou sites provendo diversas funcionalidades, como por exemplo: Biblioteca de componentes, tema opnionado e adição de estilos utilizando css-in-js.&lt;/li&gt;
&lt;/ol&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do BrasilAPI</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/brasil-api/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/brasil-api/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Izaquiel Nunes do Nascimento.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117111446&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:izaquiel.nascimento@ccc.ufcg.edu.br&#34;&gt;izaquiel.nascimento@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/BrasilAPI/BrasilAPI&#34;&gt;https://github.com/BrasilAPI/BrasilAPI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----brasilapi&#34;&gt;Descrição Arquitetural &amp;ndash; BrasilAPI&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/BrasilAPI/BrasilAPI&#34;&gt;BrasilAPI&lt;/a&gt;. Essa descrição, assim como a produção de seus diagramas, foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-brasilapi&#34;&gt;Descrição Geral sobre o BrasilAPI&lt;/h2&gt;
&lt;p&gt;O BrasilAPI tem como objetivo disponibilizar de forma rápida e prática informações públicas como CEP, DDD, feriados nacionais, dados do IBGE, entre outros. Esse projeto centraliza e disponibiliza endpoints modernos com baixíssima latência utilizando tecnologias como Vercel Smart CDN responsável por fazer o cache das informações em atualmente 23 regiões distribuídas ao longo do mundo (incluindo Brasil).&lt;/p&gt;
&lt;h2 id=&#34;a-api&#34;&gt;A API&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar uma api rest com alta disponibilidade para dados relacionados ao Brasil.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Se tornar uma plataforma onde qualquer possa contribuir e integrar serviços, aumentando assim a diversidade de dados fornecida pela api.&lt;/p&gt;
&lt;p&gt;Atualmente a API conta com esses endpoints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cnpj/v1/{cnpj}&lt;/li&gt;
&lt;li&gt;cep/v1/{cep}&lt;/li&gt;
&lt;li&gt;ddd/v1/{ddd}&lt;/li&gt;
&lt;li&gt;banks/v1&lt;/li&gt;
&lt;li&gt;banks/v1/{code}&lt;/li&gt;
&lt;li&gt;veriados/v1/{ano}&lt;/li&gt;
&lt;li&gt;ibge/uf/v1&lt;/li&gt;
&lt;li&gt;ibge/uf/v1/{code}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Logo abaixo temos um diagrama que mostra toda a simplicidade da api. O cliente é qualquer pessoa que deseja obter alguma informação que a api disponibiliza. É feita uma requisição HTTP e o BrasilAPI se responsabiliza por verificar se a informação está em cache ou então requisita a diversas fontes externas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;Diagrama de contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Temos apenas um container para a api, ele se encontra implantadado na Vercel.
OBS: cada serviço que a api disponibiliza pode ter seus próprios containers, mas por se tratar de elementos externos não será retratado aqui.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;Diagrama de containers&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A API divide-se basicamente em três componentes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Os Middlewares, responsáveis por tratamento de cache, tratamento dos erros nas requisições e registro de logs da aplicação.&lt;/li&gt;
&lt;li&gt;A api propriamente dita, responsável pelo tratamento e retorno dos dados. Esse componente faz uso do componente de Services para buscar os dados.&lt;/li&gt;
&lt;li&gt;Services, responsável pela busca do dado requisitado nas mais variadas fontes de dados.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;Diagrama de components&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Abaixo temos um diagrama que mostra como a informação trafega na api. Primeiro o usuário faz uma requisição, ela é validada pelos middlewares, se tiver tudo ok, é verificado se o que foi pedido já se encontra em cache, se for encontrado algum erro é retornado pro usuário com alguma mensagem. Se a informação estiver em cache, é retornada imediatamente pro usuário, senão a api vai processar, pedindo para o serviço responsável buscar das fontes externas e retornando a informação requerida. Durante esse processo pode ocorrer algum erro e então o mesmo é retornado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;info.png&#34; alt=&#34;Diagrama de informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Meu Menu</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/meu-menu/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/meu-menu/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Vitória Heliane.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110666&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:vitoria.sobrinha@ccc.ufcg.edu.br&#34;&gt;vitoria.sobrinha@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/proj-comp-20201e&#34;&gt;https://github.com/proj-comp-20201e&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----meu-menu&#34;&gt;Descrição Arquitetural &amp;ndash; Meu Menu&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do &lt;a href=&#34;https://github.com/proj-comp-20201e&#34;&gt;Meu Menu&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do Meu Menu. O foco aqui é a descrição de um serviço específico desse sistema, que é parte de geração estática da página do menu.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-meu-menu&#34;&gt;Descrição Geral sobre o Meu Menu&lt;/h2&gt;
&lt;p&gt;A proposta do Meu Menu é possibilitar aos pequenos empreendedores a criação do seu menu de serviços e/ou produtos disponibilizados para os seus clientes. Esse menu ficará hospedado na plataforma, podendo ser acessado por todos os clientes do estabelecimento através de uma URL. Além disso, também há a opção de gerar um QRCode que redireciona para essa URL, o qual pode ser impresso ou compartilhado. Outra possibilidade é a de exportar o menu no formato de PDF ou PNG, assim ele pode imprimir e disponibilizar no seu estabelecimento ou compartilhar nas suas redes sociais.&lt;/p&gt;
&lt;h3 id=&#34;serviço-de-geração-de-páginas-estáticas-para-o-menu&#34;&gt;Serviço de Geração de Páginas Estáticas para o Menu&lt;/h3&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço de criação de páginas web estáticas a partir das configurações de menu e seus produtos/serviços cadastrados.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A partir da criação de um menu e a adição dos seus produtos/serviços, é desejado que seja criada um página web com essas informações e com as configurações de estilo feitas pelo usuário. Essa página deve ser estática para que os clientes dos usuários tenham uma boa experiência de uso e que seja rebuildada sempre que houver alguma mudança nas informações do menu a fim de manter a consistência das informações na página.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural Leaflet</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/leaflet/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/leaflet/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Gabriel de Oliveira Meira Nóbrega.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110276&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:gabriel.nobrega@ccc.ufcg.edu.br&#34;&gt;gabriel.nobrega@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Leaflet/Leaflet&#34;&gt;https://github.com/Leaflet/Leaflet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----documentação-arquitetural-leaflet&#34;&gt;Descrição Arquitetural &amp;ndash; Documentação arquitetural Leaflet&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/Leaflet/Leaflet&#34;&gt;Leaflet&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-leaflet&#34;&gt;Descrição Geral sobre o Leaflet&lt;/h2&gt;
&lt;p&gt;O leaflet é uma biblioteca leve em javascript que permite o uso de mapas de interativos compatíveis com mobile. Permite o uso de plugins para extender as funcionalidades e tem como objetivo oferecer todas as funcionalidades que podem vir a serem necessárias em mapas. Mais informações podem ser encontradas &lt;a href=&#34;https://leafletjs.com/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação da arquitetura do navegador Pale Moon</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/palemoon/</link>
       <pubDate>Fri, 16 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/palemoon/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Amanda Vivian Alves de Luna e Costa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210896&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:amanda.costa@ccc.ufcg.edu.br&#34;&gt;amanda.costa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://repo.palemoon.org/MoonchildProductions/Pale-Moon&#34;&gt;https://repo.palemoon.org/MoonchildProductions/Pale-Moon&lt;/a&gt; e &lt;a href=&#34;http://www.palemoon.org/&#34;&gt;http://www.palemoon.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----navegador-pale-moon&#34;&gt;Descrição Arquitetural &amp;ndash; Navegador Pale Moon&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do navegador &lt;a href=&#34;http://www.palemoon.org/&#34;&gt;Pale Moon&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-navegador-pale-moon&#34;&gt;Descrição Geral sobre o navegador Pale Moon&lt;/h2&gt;
&lt;p&gt;Pale Moon é um navegador de código aberto Goanna-based disponível para Microsoft Windows e Linux (com outros sistemas operacionais em desenvolvimento), com foco em eficiência e personalização.&lt;/p&gt;
&lt;p&gt;Pale Moon oferece a você uma experiência de navegação em um navegador totalmente construído a partir de sua própria fonte desenvolvida de forma independente, que foi bifurcada do código do Firefox / Mozilla há alguns anos, com recursos e otimizações cuidadosamente selecionados para melhorar a estabilidade do navegador e a experiência do usuário.&lt;/p&gt;
&lt;p&gt;Um dos seus maiores diferenciais é não expor seus dados de maneira nativa. Para tal, alguns recursos padrão dos browsers foram simplesmente eliminados e, o principal motivo das pessoas o utilizarem é a sua garantia de mais segurança dos dados pessoais durante o uso, uma das features que asseguram isso é não possuir telemetria, um recurso que tem acesso a quase todos os dados do seu computador, como por exemplo, qual seu hardware,sistema operacional,entre várias outras coisas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Diagrama_Palemoon_Contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Palemoon é um navegador de internet que protege suas informações de maneira nativa, por causa disso não possui tanta complexidade. Ao invés de incluir dependências e similares, ele os retira para que a privacidade seja mantida. Além disso, ele só está disponível para desktop Windows e Linux, não havendo portabilidade para mobile.&lt;/p&gt;
&lt;p&gt;O Palemoon também oferece nativamente a opção de usar o buscador DuckDuckGo fruto de uma parceria com o sistema, porém, caso o usuário queira, pode trocar de buscador sem complicações.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Diagrama_Contexto_Palemoon.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Por ser uma aplicação mais simples, o Palemoon não dispõe de muitos contâineres. A aplicação pode ser dividida entre a aplicação (Desktop App), que representa o que o usuário visualiza e navega, esta faz chamadas à API. Em relação a API,  ela é feita em C/C++, e contém todas as funções/features que o navegador possui. Esta se comunica com o banco de dados, implementado em SQLite, que fica armazenado localmente com suas configurações e preferências.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;Diagramas_Componentes_Palemoon.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O navegador não possui muitos componentes, quando ele é iniciado outros além dos mostrados aqui são utilizados. Dentre eles, temos os seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Browser:&lt;/em&gt; Responsável pela funcionalidade principal de possibilitar o acesso a internet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Search:&lt;/em&gt; Responsável por disponibilizar os buscadores para o Palemoon. Esse componente que se relaciona com o buscador default, o &lt;a href=&#34;https://duckduckgo.com/about&#34;&gt;DuckDuckGo&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Plugin:&lt;/em&gt;: Responsável por gerenciar os plugins e extensões do navegador, que podem ser instaladas através de um &lt;a href=&#34;https://addons.palemoon.org/extensions/&#34;&gt;site próprio do Palemoon&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Security:&lt;/em&gt; Responsável pela segurança de autenticação quando o usuário inicia o browser ou se vincula durante a sessão.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Services:&lt;/em&gt; Responsável por gerenciar a criptografia e sicronização dos dados, garantindo que seus estes sejam protegidos ao navegar e não sejam capturados pela maioria dos sistemas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;LDAP:&lt;/em&gt; Responsável por gerenciar as conexões de email, também com foco na proteção dos dados.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Descrição Arquitetural do Bento</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/bento/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/bento/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Daniel Bezerra Galvão Mitre.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110274&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:daniel.mitre@ccc.ufcg.edu.br&#34;&gt;daniel.mitre@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://gitlab.cs.washington.edu/sm237/bento&#34;&gt;https://gitlab.cs.washington.edu/sm237/bento&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----bento&#34;&gt;Descrição Arquitetural &amp;ndash; Bento&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do framework &lt;a href=&#34;https://gitlab.cs.washington.edu/sm237/bento&#34;&gt;Bento&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-do-bento&#34;&gt;Descrição Geral do Bento&lt;/h2&gt;
&lt;p&gt;O Bento é um &lt;em&gt;framework&lt;/em&gt; desenvolvido para permitir desenvolvimento ágil de sistemas de arquivos no &lt;em&gt;kernel&lt;/em&gt; Linux. Suas interfaces implementadas em &lt;a href=&#34;https://www.rust-lang.org/pt-BR&#34;&gt;Rust&lt;/a&gt; garantem uma interação segura com mecanismos do &lt;em&gt;kernel&lt;/em&gt; e a compilação para espaço do usuário, facilitando os testes e depuração do sistema de arquivos sem abrir mão da performance. Mais informações podem ser encontradas em seu &lt;a href=&#34;https://www.usenix.org/system/files/fast21-miller.pdf&#34;&gt;paper original&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição Arquitetural do ConsoleMe</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/consoleme/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/consoleme/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Marcus Antonio Rocha Tenorio.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211155&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:marcus.tenorio@ccc.ufcg.edu.br&#34;&gt;marcus.tenorio@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Netflix/consoleme&#34;&gt;https://github.com/Netflix/consoleme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----consoleme&#34;&gt;Descrição Arquitetural &amp;ndash; ConsoleMe&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do framework &lt;a href=&#34;https://github.com/Netflix/consoleme&#34;&gt;ConsoleMe&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-do-bento&#34;&gt;Descrição Geral do Bento&lt;/h2&gt;
&lt;p&gt;O ConsoleMe tem como objetivo facilitar o gerenciamento de credenciais e as permissões do AWS IAM para usuários finais e administradores de nuvem.&lt;/p&gt;
&lt;p&gt;Os administradores de nuvem podem criar / clonar papéis IAM e gerenciar papéis IAM, Buckets S3, filas SQS e tópicos SNS em centenas de contas em uma única interface.&lt;/p&gt;
&lt;p&gt;Os usuários podem acessar a maioria dos seus recursos de nuvem no AWS Console com um único clique. Os administradores de nuvem podem configurar o ConsoleMe para autenticar usuários por meio da autenticação ALB, OIDC / OAuth2 ou SAML.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Kolibri</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/kolibri/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/kolibri/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Maria Cecília Kemiac Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110019&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:maria.cecilia.santos@ccc.ufcg.edu.br&#34;&gt;maria.cecilia.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/learningequality/kolibri&#34;&gt;https://github.com/learningequality/kolibri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----kolibri&#34;&gt;Descrição Arquitetural &amp;ndash; Kolibri&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/learningequality/kolibri&#34;&gt;Kolibri&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-kolibri&#34;&gt;Descrição Geral sobre o Kolibri&lt;/h2&gt;
&lt;p&gt;Kolibri é um aplicativo offline que disponibiliza tecnologia educacional de alta qualidade em comunidades de poucos recursos, como escolas rurais, campos de refugiados, orfanatos, sistemas escolares não formais e sistemas prisionais.&lt;/p&gt;
&lt;h2 id=&#34;o-kolibri&#34;&gt;O Kolibri&lt;/h2&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O sistema do Kolibri é utilizado por usuários que estão interessados em aprender, porém possuem poucos recursos para acessar a internet. Ele também pode ser utilizado por instrutores, que podem criar turmas para organizar o conteúdo que será ministrado. Os usuários interagem com a plataforma do Kolibri, que deve ser instalada localmente. Os materiais e os exercícios disponíveis na plataforma podem ser baixados para serem usados de forma offline, e são provenientes do sistema Kolibri Studio, uma ferramenta onde produtores de conteúdo educacional publicam os materiais que serão deisponibilizados.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do Appwrite</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/appwrite/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/appwrite/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jessé Souza Cavalcanti Neto.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110637&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jesse.neto@ccc.ufcg.edu.br&#34;&gt;jesse.neto@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/appwrite/appwrite&#34;&gt;https://github.com/appwrite/appwrite&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----appwrite&#34;&gt;Descrição Arquitetural &amp;ndash; Appwrite&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do serviço &lt;a href=&#34;https://github.com/appwrite/appwrite&#34;&gt;Appwrite&lt;/a&gt;.
As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que o foco principal da análise será o serviço de &lt;em&gt;Users&lt;/em&gt; do Appwrite, entretanto, será possível entender como funciona a estrutura monolítica + microserviços adotado pelo projeto, uma vez que os outros serviços seguem a mesma lógica. É importante ressaltar que a documentação chama de microserviço por considerar que cada container (serviço ou worker) é um processo independente e pode ser escalado sem depender de outros serviços.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-appwrite&#34;&gt;Descrição Geral sobre o Appwrite&lt;/h2&gt;
&lt;p&gt;O Appwrite é um servidor backend end-to-end que tem como objetivo abstrair grande parte da complexidade, muitas vezes repetitivas, na construção de aplicativos modernos. O serviço é composto por um conjunto de APIs, ferramentas e um console para gerenciamento que auxiliam no desenvolvimento de diversas features, tais como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gerenciamento de conta&lt;/li&gt;
&lt;li&gt;Autenticação&lt;/li&gt;
&lt;li&gt;Preferências do usuário&lt;/li&gt;
&lt;li&gt;Persistência de banco de dados&lt;/li&gt;
&lt;li&gt;Funções de nuvem&lt;/li&gt;
&lt;li&gt;Manipulação de Imagens&lt;/li&gt;
&lt;li&gt;Dentre outros serviços&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além disso tudo, o Appwrite é &lt;strong&gt;cross-platform&lt;/strong&gt;, ou seja, é possível executar em qualquer lugar independente de sistema operacional, linguagem de programação, framework ou plataforma, permitindo uma fácil integração com vários serviços distintos.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-users&#34;&gt;O Serviço de Users&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Fornecer o serviço de cadastro, autenticação e gerenciamento de usuários a aplicação do usuário, permitindo que o mesmo possa implementar um sistema de cadastro/login na aplicação (página web, aplicativo IOS/Flutter/Android ou mesmo outro servidor) sem se preocupar com a implementação e persistência dos dados.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O sistema de usuários do Appwrite permite que o desenvolvedor gerencie os usuários que consomem sua aplicação, permitindo que o mesmo possa criar, procurar, bloquear usuários, visualizar informações de sessão, revisar últimas atividades ou até mesmo obter informações do User Agent do usuário somente através do consumo da API REST.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;O objetivo principal do Appwrite é fornecer grande parte das funcionalidades que um backend normalmente proveria, permitindo ser usado tanto em ambiente de desenvolvimento para prover suporte ao desenvolvimento do Frontend Web, como também pode ser usado em produção devido a sua alta escalabilidade.&lt;/p&gt;
&lt;p&gt;Dito isso, o sistema principal do Appwrite se comunica com o usuário tanto através de sua interface web quanto por meio do consumo de sua API REST (diretamente ou através de suas SDKs).&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-contexto.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de Contexto do Appwrite
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;container&#34;&gt;Container&lt;/h2&gt;
&lt;p&gt;O serviço de usuários do Appwrite envolve basicamente os 3 componentes que serão descritos abaixo:&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Console&lt;/strong&gt; é o container responsável por fornecer uma interface web para que o desenvolvedor consiga ter acesso a parte dos serviços do Appwrite, dentre eles, o gerenciamento de usuários. O console segue o padrão MVC e foi implementado utilizando PHP e HTML (para as views), além da framework &lt;a href=&#34;https://github.com/utopia-php/framework&#34;&gt;Utopia PHP&lt;/a&gt;. A comunicação com o serviço de &lt;em&gt;Users&lt;/em&gt; se dá por meio do protocolo HTTP.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Database&lt;/strong&gt; é o container responsável por armazenar, de forma estruturada, as informações referentes a todos os serviços e workers disponibilizados pelo Appwrite. O banco de dados utilizado é o MariaDB e os dados de cada serviço é separado através de &lt;em&gt;collections&lt;/em&gt; distintas.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Users&lt;/strong&gt; é o container responsável pelo gerenciamento do serviço de usuários na aplicação. O serviço disponibiliza uma API REST para que outros serviços e sistemas possam consumir seus recursos. Foi implementado utilizando o Utopia PHP.&lt;/p&gt;
&lt;p&gt;A API do serviço de &lt;strong&gt;Users&lt;/strong&gt; disponibiliza 11 endpoints para gerenciamento de usuários que podem ser acessados diretamente via HTTP ou pelo uso de uma das suas &lt;a href=&#34;https://appwrite.io/docs/sdks&#34;&gt;SDKs&lt;/a&gt;. Segue uma breve descrição de alguns dos endpoints:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;POST /v1/users&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Cria um novo usuário.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Request&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;email&lt;/code&gt;:&lt;/strong&gt; Email de cadastro do usuário.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;password&lt;/code&gt;:&lt;/strong&gt; Senha do usuário.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;name&lt;/code&gt;:&lt;/strong&gt; Nome do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;$id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;exemplo&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;registration&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;181058&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;status&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;email@email.com&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;emailVerification&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;emailver@email.com&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;prefs&amp;#34;&lt;/span&gt;: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /v1/users/{userId}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Retorna um usuário a partir do id.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Request&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;userId&lt;/code&gt;:&lt;/strong&gt; Identificador único do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;$id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;exemplo&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;registration&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;181058&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;status&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;email@email.com&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;emailVerification&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;emailver@email.com&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;prefs&amp;#34;&lt;/span&gt;: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;DELETE /v1/users/{userId}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Remove um usuário a partir do id.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Request&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;userId&lt;/code&gt;:&lt;/strong&gt; Identificador único do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;204&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A lista completa dos endpoints de usuário fornecidos pode ser encontrado neste &lt;a href=&#34;https://appwrite.io/docs/server/users&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-containers.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 2 - Diagrama de Containers do Appwrite
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Olhando os containers descritos acima, é possível subdividi-los em componentes mais específicos.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Console&lt;/strong&gt; pode ser subdividido em &lt;strong&gt;Views&lt;/strong&gt; e &lt;strong&gt;Console Controller&lt;/strong&gt; seguindo o padrão MVC. As &lt;strong&gt;Views&lt;/strong&gt; contém os templates HTML + PHP que serão retornados ao usuário quando o mesmo acessa uma rota X, por exemplo, caso o usuário acesse &lt;code&gt;/console/account&lt;/code&gt;, é retornada a view &lt;em&gt;account&lt;/em&gt;. Já o &lt;strong&gt;Console Controller&lt;/strong&gt; é o responsável por receber as requisições e retornar as &lt;strong&gt;Views&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Já o &lt;strong&gt;Users&lt;/strong&gt; possui somente um componente que seria o próprio &lt;strong&gt;Users Controller&lt;/strong&gt;. Ele é o responsável por receber as requisições HTTP de outros serviços (internos e externos), além de conter a lógica de negócios necessária para o gerenciamento dos usuários, como o tratamento e o acesso ao &lt;strong&gt;Database&lt;/strong&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-componentes.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 3 - Diagrama de Componentes do Appwrite
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Como o foco deste documento é analizar o Appwrite com foco na funcionalidade de usuários, a informação analisada será os dados cadastrados do usuário.&lt;/p&gt;
&lt;p&gt;Os dados cadastrais do usuário podem sofrer alguns eventos, são eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Criação&lt;/li&gt;
&lt;li&gt;Edição dos status&lt;/li&gt;
&lt;li&gt;Edição das preferências&lt;/li&gt;
&lt;li&gt;Edição das sessões&lt;/li&gt;
&lt;li&gt;Remoção do usuário&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-info.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de informação dos dados de usuário
    &lt;/span&gt;
&lt;/div&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Insomnia</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/insomnia/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/insomnia/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento explica aspectos da arquitetura de um cliente para requisições à API&amp;rsquo;s. O Insomnia
torna a tarefa de teste de Api&amp;rsquo;s mais fáceis.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Filipe Pires Guimarães.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210442&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:filipepiresg@gmail.com&#34;&gt;filipepiresg@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Kong/insomnia&#34;&gt;https://github.com/Kong/insomnia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural--insomnia&#34;&gt;Descrição Arquitetural – Insomnia&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto Insomnia. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será escrita toda a arquitetura do Insomnia. O foco principal é descrever a &lt;code&gt;API client&lt;/code&gt; utilizando o padrão REST de um ùnico workspace, que é parte fundamental do projeto. A organização utiliza um padrão de arquitetura &lt;em&gt;monolíto&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-insomnia&#34;&gt;Descrição Geral sobre o Insomnia&lt;/h2&gt;
&lt;p&gt;O Insomnia é uma ferramenta open-source e cross-platform para desktop, feito em electron para testar requisições à APIs com suporte à protocolos, como: &lt;code&gt;REST&lt;/code&gt;, &lt;code&gt;SOAP&lt;/code&gt;, &lt;code&gt;GraphQL&lt;/code&gt; e &lt;code&gt;GRPC&lt;/code&gt;. De uma forma muito fácil e àgil. Nele,podem ter vários workspaces, com distintas API`s.&lt;/p&gt;
&lt;p&gt;Mais detalhes podem ser vistos &lt;a href=&#34;https://insomnia.rest/&#34;&gt;nesse link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;insomnia-client&#34;&gt;Insomnia Client&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar uma ferramenta em que possa testar mais facilmente, e agilmente, às API&amp;rsquo;s.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O Insomnia é um projeto que tem como objetivo &amp;ldquo;facilitar o teste de requisições às API&amp;rsquo;s&amp;rdquo;, nele pode-se simular uma requisição completa, observar sua execução e verificar o seu retorno. Ele permite o compartilhamento do workspace com o time, acelerando, mais ainda, esse processo.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;insomnia-context.png&#34; alt=&#34;context&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ao baixar a ferramenta, é possível o usuário criar requisições de todos os tipos (&lt;em&gt;GET&lt;/em&gt;, &lt;em&gt;POST&lt;/em&gt;, &lt;em&gt;PUT&lt;/em&gt;, &lt;em&gt;DELETE&lt;/em&gt;, &lt;em&gt;PATCH&lt;/em&gt;, &lt;em&gt;OPTIONS&lt;/em&gt;, &lt;em&gt;TRACE&lt;/em&gt; e &lt;em&gt;CONNECT&lt;/em&gt;, que são todos os tipos de métodos para requisições suportados pelo padrão HTTP). Além disso, é possível o envio de diversos tipos de body pela requisição. como: &lt;em&gt;Multipart Form&lt;/em&gt;, &lt;em&gt;GraphQL Query&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt;, &lt;em&gt;XML&lt;/em&gt;, e outras. E também é possível utilizar padrões de autenticação já pre-definidos ou fazer sobrecarga dos cabeçalhos. Após a criação da requisição, o mesmo é enviado para a API destino, no qual é processado e retornado a requisição é exibida para o usuário em tela, além de ser salva no banco de dados da ferramenta, para posterior visualização e/ou compartilhamento.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a plataforma Insomnia Client:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;insomnia-container.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;p&gt;Vamos detalhar cada container e seu papel no sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SinglePage Application: Esse é o container de exibição dos dados fornecidos para o usuário, feito atualmente em &lt;strong&gt;Electron&lt;/strong&gt; utilizando &lt;em&gt;typescript&lt;/em&gt;, é nele que é feito a criação das requisições e realizado o envio dos mesmos para a API em teste, também é possível visualizar respostas à requisições feitas aquele mesmo &lt;code&gt;endpoint&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;API Application: Nesse container é feito a validação do corpo da requisição, da resposta e até mesmo dos padrões de autenticação, como o &lt;em&gt;Basic Token&lt;/em&gt;, entre outros. Ele também é responsável pelo envio destes dados para persistir no database da aplicação. Utilizado &lt;strong&gt;NodeJS&lt;/strong&gt; com &lt;em&gt;typescript&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Databse: Armazena informações das requisições criadas, feitas e/ou enviadas, e também dos retornos obtidos de cada requisição.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;insomnia-component.png&#34; alt=&#34;component&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nos componentes, temos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Database Controller: Esse componente faz o controle sobre o database, fazendo a persistência dos dados e criação/atualização dos dados no mesmo;&lt;/li&gt;
&lt;li&gt;Request Validator: Esse componente faz a validação das requisições para o padrão selecionado, como por exemplo o body, se foi utilizado &lt;em&gt;JSON&lt;/em&gt;, que é um padrão de notação de objetos, onde deve-se seguir algumas &amp;lsquo;regras&amp;rsquo;, como o nome das propriedades desse objeto devem ser &lt;code&gt;string&lt;/code&gt;, entre outros;&lt;/li&gt;
&lt;li&gt;Response Validator: Esse módulo é responsável por validar as respostas vindas, ou não, da API em testes. Ele utiliza o padrão de respostas de status das requisiçoes HTTP baseado em REST, onde cada status tem sua característica &amp;ldquo;única&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;Axios: Esse módulo utiliza uma biblioteca externa para fazer as requisiçoes a API em teste, facilitando o processamento de envio das requisiçoes. Aqui no blog já foi feito um post sobre ela e pode ser lido mais &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog/posts/axios/&#34;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;Temos um fluxo de estados bem simples, onde a requisição é criada, e ao longo do processo será modificada quando tiver alteração do &lt;code&gt;endpoint&lt;/code&gt;, do body, dos cabeçalhos, entre outros. Em seguida, é enviada para a API em teste e é passada para aguardando resposta, após o retorno, ou não tiver, dessa resposta, ela entra no seu estado final, exibindo para o usuário a resposta, com algumas métricas, que pessoalmente acho bem interessante para o teste da API, como o tempo de resposta e o tamanho da resposta. Após essa interação, é feita a atualização no banco de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;insomnia-estados.png&#34; alt=&#34;estados&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o Dialetus</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/dialetus/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/dialetus/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Almir Gonçalves Crispiniano.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210914&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:almir.crispiniano@ccc.ufcg.edu.br&#34;&gt;almir.crispiniano@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/dialetus/dialetus-service&#34;&gt;https://github.com/dialetus/dialetus-service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----dialetus&#34;&gt;Descrição Arquitetural &amp;ndash; Dialetus&lt;/h1&gt;
&lt;p&gt;Este post descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/dialetus&#34;&gt;Dialetus&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-dialetus&#34;&gt;Descrição Geral sobre o Dialetus&lt;/h2&gt;
&lt;p&gt;O Dialetus é um plataforma que permite pesquisar diferentes sinônimos em um dicionário informal através de uma API Rest em Node.js.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Como possuímos um país multicultural, a aplicação tem como objetivo central permitir encontrar diferentes palavras da língua portuguesa a partir dos diferentes traços linguísticos-culturais encontrados nas cinco regiões brasileiras. Sua ideia surgiu de uma reunião de amigos que apenas se conheciam pela internet para então se tornar um projeto totalmente colaborativo, trazendo a diversidade cultural de cada um para assim possibilitar um aprofundamento na cultura cotidiana do nosso português brasileiro.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Para alcançar os objetivos gerais o &lt;a href=&#34;https://dialetus.com&#34;&gt;Dialetus&lt;/a&gt; provê uma API Rest codificada em Node.js com um database local formado por jsons e uma lista de svgs que representam as bandeiras dos estados. Com a aplicação é possível buscar dialetos de maneira geral e também por regiões. Seus diferentes endpoints utilizam o método GET e sua implementação encontra-se no heroku.app. O frontend da aplicação foi desenvolvido utilizando React.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o Simulador Didático de SystemVerilog</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/learnsystemverilog/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/learnsystemverilog/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Esse documento descreve a arquitetura do projeto Simulador Didático de SystemVerilog&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Matheus de Souza Coutinho&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116111247&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:Matheus.coutinho@ccc.ufcg.edu.br&#34;&gt;Matheus.coutinho@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/learn-systemverilog/learn-systemverilog.github.io&#34;&gt;https://github.com/learn-systemverilog/learn-systemverilog.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquiteturial&#34;&gt;Descrição Arquiteturial&lt;/h1&gt;
&lt;p&gt;        Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, descreve a arquitetura do projeto [Simulador Didático de SystemVerilog] (&lt;a href=&#34;https://github.com/learn-systemverilog/learn-systemverilog.github.io&#34;&gt;https://github.com/learn-systemverilog/learn-systemverilog.github.io&lt;/a&gt;) e usando como descrição principalmente o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-projeto&#34;&gt;Descrição Geral sobre o Projeto&lt;/h2&gt;
&lt;p&gt;        O LearnSystemVerilog tem como principal objetivo tornar o aprendizado e a prática da programação em SystemVeriLog em placas FPGA mais acessível e de forma mais intuitiva, de forma a simular os mesmo resultados e a mesma execução de uma placa física real, obtendo a vantagem de ter a compilação mais rápida em relação as placas físicas e poder ser acessada de qualquer lugar, a qualquer momento utilizando dispositivos móveis.&lt;/p&gt;
&lt;h2 id=&#34;o-simulador-didático&#34;&gt;O Simulador Didático&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;        Implementar um sistema que compile código em SystemVerilog e execute as operações em um modelo de placa FPGA virtual, mantendo todas as funcionalidades de uma placa física de mesmo aspecto.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;        Simular códigos de SystemVerilog em uma placa FPGA virtual com qualidade e eficiência, buscando um melhor desempenho e um tempo de compilação menor que as placas físicas(frequentemente tendem a demorar minutos para realizar a compilação do código).  Além disso, buscar ampliar a acessibilidade ao aprendizado dessa linguagem através de uma aplicação Web, podendo ser acessada em qualquer lugar do mundo com um computador ou celular.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../learnSystemVerilog/contexto.png&#34; alt=&#34;Diagrama de contexto&#34; &gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;O Learn System Verilog é um sistema simples porém bastante eficiente na coleta e transmissão de dados. Na Single Page principal são realizadas todas as funções do sistema que os usuários podem acessar a qualquer momento. &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
Na página do sistema, existe como foco principal o simulador virtual da placa FPGA, logo em seguida os mecanismos de edição de código no Code Editor e a verificação de execução do código em Console. &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
A transmissão de dados entre os componentes do &lt;i&gt;Frontend&lt;/i&gt; e API é realizada através da tecnologia &lt;i&gt;Server Sent Event&lt;/i&gt; (SSE), essa tecnologia permite que dados sejam transmitidos ao ponto de &lt;i&gt;Real-Time&lt;/i&gt; e isso contribui para a eficiência e torna vantajosa a utilização dessa
placa virtual em relação às físicas.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
Os dados que são transmitidos na comunicação com a API são basicamente: código System Verilog escrito pelo usuário no Code Editor e código JavaScript. &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
A API é responsável por converter o código em SystemVerilog para um código JavaScript que será responsável por manipular os componentes do &lt;i&gt;Frontend&lt;/i&gt; no simulador virtual FPGA. 
&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../learnSystemVerilog/container.png&#34; alt=&#34;Containers&#34; &gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;Conforme o diagrama acima, pode-se analisar que o Learn SystemVerilog é um sistema bem simples e robusto, não possuindo banco de dados e portanto sendo dividido em dois subsistemas: A parte do client que é onde os usuários acessam o sistema, portanto o &lt;i&gt;Frontend&lt;/i&gt;, e a parte do &lt;i&gt;WebServer&lt;/i&gt; que é onde o client realizará requisições para transmitir e receber dados.&lt;/p&gt;
&lt;p&gt;Descrevendo os containers apresentados no diagrama, vamos ter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;External API(Google API)&lt;/strong&gt;: É o Container que dá acesso a uma API externa para que o usuário possa realizar login com uma conta do Google, e assim que ele consiga logar o sistema ficará disponível para que as funcionalidades possam ser acessadas pelo mesmo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;User Web(React JS)&lt;/strong&gt;: Container que compõe todas as funcionalidades do sistema que o usuário pode visualizar e interagir, nesse container também é realizado as funções solicitadas pelo usuário.  Além disso, realiza a comunicação com a parte Server do sistema, transmitindo e recebendo dados.  A comunicação é realizada através do Protocolo &lt;em&gt;HTTP&lt;/em&gt; utilizando a tecnologia &lt;em&gt;Server Sent Events&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;API(transpile)&lt;/strong&gt;: Este container é responsável por receber os dados enviados para o Server, e a partir dos dados recebidos realizar os procedimentos internos designados. É a partir desse container que os mecanismos essenciais propostos no sistema são executados.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Export Logs(Server Send Events)&lt;/strong&gt;: Container responsável por enviar dados para o Client sobre os status do código System Verilog enviado para o Server para ser compilado, os dados são do tipo &lt;em&gt;txt&lt;/em&gt; e seu conteúdo é de acordo com a situação de cada etapa de compilação e execução do código enviado. O protocolo de comunicação utilizado é o &lt;em&gt;HTTP&lt;/em&gt; utilizando a tecnologia &lt;em&gt;Server Sent Events&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Response API transpile(Server Send Events)&lt;/strong&gt;: Este container tem como objetivo enviar o código traduzido em System Verilog para JavaScript de forma que sejam utilizados nos componentes do container &lt;em&gt;User Web&lt;/em&gt;(JavaScript). Então esse container é responsável por compilar, checar falhas, traduzir e enviar os novos dados para outro container. Para a execução de compilação e tradução foi utilizada a tecnologia &lt;em&gt;transpile&lt;/em&gt;, implementada no próprio sistema. O protocolo de comunicação utilizado é o &lt;em&gt;HTTP&lt;/em&gt; utilizando a tecnologia &lt;em&gt;Server Sent Event&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p /&gt;
&lt;img src=&#34;../learnSystemVerilog/componentes.png&#34; alt=&#34;Diagrama de componentes&#34; &gt;&lt;/img&gt;
&lt;p /&gt;&lt;p /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Os componentes que estão sendo apresentados no Diagrama de Componentes englobam todas as funcionalidades que o sistema propõe, e serão descritos a seguir:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Single Page Application&lt;/strong&gt;: É nesse componente que estão os outros quatro componentes que interagem diretamente com o usuário, é nesse componente que o usuário realiza as funções disponíveis no sistema e é onde os outros componentes que estão nele são renderizados.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sign in Google Account&lt;/strong&gt;: É o componente externo ao sistema que tem como responsabilidade solicitar ao usuário que realize login com um email válido do Gmail, caso essa ação seja realizada com sucesso, então as funcionalidades do sistema ficarão disponíveis para que o usuário as utilize, caso contrário, o sistema não permitirá que o usuário manipule outros componentes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Simulator FPGA&lt;/strong&gt;: É o componente principal em questão de visualização do usuário, este componente receberá um código JavaScript convertido pelo &lt;em&gt;Server&lt;/em&gt; e o atribuirá em seus componentes JavaScript de forma que simulem o funcionamento de uma placa FPGA física, por ser um simulador a visualização dos componentes base desse componente se assemelha a uma placa FPGA real, o mesmo pode ser dito para o comportamento desses componentes quando executados. O usuário também poderá manipular os objetos e de acordo com o código passado terá diferentes ações.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code Editor&lt;/strong&gt;: É o componente responsável por iniciar o processo de compilação e execução do simulador proposto no sistema. É a partir desse componente que o usuário pode escrever um código em SystemVerilog, compilar e verificar sua execução no componente do Simulador FPGA. O código escrito é enviado para o componente Learn-SystemVerilog API para ser convertido e compilado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Console&lt;/strong&gt;: É o componente intermediário de execução do sistema, após o usuário ter escrito e compilado o código, o console mostrará em formato &lt;em&gt;txt&lt;/em&gt; os status do código que está sendo compilado, informando ao usuário onde existe erro no código, se foi compilado com sucesso, entre outras coisas. Se não houver erros no código, o simulador FPGA começará a simular a execução do código. As informações são recebidas através do componente Learn-SystemVerilog API.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Learn-SystemVerilog API&lt;/strong&gt;: Componente da parte do &lt;em&gt;Server&lt;/em&gt; que recebe requisições e transmite dados. Esse componente é responsável por receber o código System Verilog, compilar, gerar os resultados da compilação, convertê-lo em código JavaScript e transferi-lo para os componentes Console e Simulator FPGA do &lt;em&gt;Client&lt;/em&gt;. Utiliza a API &lt;em&gt;transpile&lt;/em&gt; para conversão dos códigos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../learnSystemVerilog/Fluxo de Informacoes.png&#34; alt=&#34;Visão de Informações&#34; &gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;O sistema caracteriza-se por ser bastante simples de utilizar, basta que o usuário logue em qualquer conta do Google, e após isso pode estudar, implementar e testar seus códigos em um simulador eficiente, rápido e sofisticado, capaz de realizar todas as funcionalidades que uma placa FPGA física real. O sistema possui apenas um campo para escrever o código System Verilog e um botao para compilar, a parte principal é de fato o simulador que execurá os comandos passados no código após ser compilado, e além disso, o usuário poderá verificar os status de compilação e possíveis erros, tornando-se uma ferramenta bastante didática e intuitiva para todos os níveis de usuários.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o Valheim</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/valheim/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/valheim/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto Valheim server docker.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por André Filipe Queiroz.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210818&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:andre.soares@ccc.ufcg.edu.br&#34;&gt;andre.soares@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/lloesche/valheim-server-docker&#34;&gt;https://github.com/lloesche/valheim-server-docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----servidores-dedicados-para-valheim&#34;&gt;Descrição Arquitetural &amp;ndash; Servidores Dedicados para Valheim&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, descrevendo parte da arquitetura do projeto &lt;a href=&#34;https://github.com/lloesche/valheim-server-docker&#34;&gt;Valheim Server Docker&lt;/a&gt; e usando como descrição principalmente o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-valheim-server-docker&#34;&gt;Descrição Geral sobre o Valheim Server Docker&lt;/h2&gt;
&lt;p&gt;O Valheim Server Docker é um projeto Open-Source que permite ao usuário configurar como desejar um servidor dedicado no jogo eletrônico Valheim, utilizando comandos via terminal.&lt;/p&gt;
&lt;h2 id=&#34;servidores-dedicados-para-o-valheim-utilizando-docker&#34;&gt;Servidores Dedicados para o Valheim Utilizando Docker&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar  e configurar com o auxílio da plataforma Docker permitindo um processo repetível e configurável para gerenciar a execução de servidor(es) dedicado(es) para o jogo Valheim.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Valheim tem hospedagem “peer-to-peer”, mas se o host se desconectar, o mundo não estará mais acessível a ninguém e todos os outros serão removidos do mundo. Hospedar um servidor Valheim dedicado resolve isso sendo acessível 24 horas por dia e 7 dias por semana, para que seus amigos possam jogar mesmo se você não estiver online, tornando a experiência ainda melhor.
Além disso, se precisarmos atualizar o servidor, simplesmente o reconstruiremos em um único comando com o Docker. Como um contêiner do Docker, o servidor pode ser executado em qualquer computador que também execute o Docker. Isso significa que é fácil mover o servidor para outro computador, se necessário.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Com o Docker instalado na máquina host, este é executado por linha de comando, no terminal. Depois de executar o comando de execução do Docker, com isso será puxado a imagem do Valheim Server mais recente do repositório do Docker que com isso você poderá se conectar ao servidor Valheim localmente ou pela Internet e Conectar-se pela Internet significa que seus amigos também podem se conectar ao servidor Valheim ou criar uma imagem nova personalizada.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Sabendo disso, usamos a interface de linha de comando (CLI) do Docker chamada docker para executar a aplicação, ademais o Docker usa uma arquitetura cliente-servidor, em que o cliente Docker se comunica com o daemon Docker , que faz o trabalho pesado de construir, executar e distribuir seus containers Docker. O Docker fornece também Dockerfiles(construção de imagens automaticamente lendo instruções) assim podendo fazer uma nova imagem Docker que inicie automaticamente o servidor Valheim sem ter que entrar no contêiner e inserir comandos manualmente. Assim, a imagem Docker do servidor Valheim deve ser o mais genérica possível, permitindo ao usuário personalizar o comportamento específico do servidor em tempo de execução.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No diagrama de componentes (localizado abaixo) temos os componentes, além de seus relacionamentos.  O Dockerfile é um documento de texto que contém todos os comandos que um usuário pode chamar na linha de comando para montar uma imagem, nada mais é do que um meio que utilizamos para criar nossas próprias imagens. Os volumes são o mecanismo preferencial para persistir os dados gerados e usados por containers Docker, assim os volumes são totalmente gerenciados pelo Docker. Sabendo disso, para poder compartilhar dados entre o contêiner e o host usamos o recurso Volumes do Docker, já com a montagem de ligação, o diretório a ser criado na máquina host é montado em um contêiner. Então por padrão, o contêiner Updater irá verificar se há atualizações do servidor Valheim a cada 15 minutos se nenhum jogador estiver conectado ao servidor e o de backup O contêiner será inicializado e criará periodicamente um backup do worlds/diretório.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;No diagrama de informação é descrito os estados que o processamento pode atingir, ao iniciarmos você pode copiar um mundo existente(já existindo uma imagem Docker) ou você pode criar um novo mundo do zero manualmente com as configurações de sua preferência. A imagem Docker do servidor Valheim deve ser o mais genérica possível, permitindo ao usuário personalizar o comportamento específico do servidor em tempo de execução, isso significa que escrevemos um script personalizado para iniciar o servidor Valheim que controla como o servidor é iniciado e encerrado. Sabendo que ao criarmos uma imagem Docker do servidor Valheim, então precisamos executá-lo como um contêiner e que por fim Hospedar um servidor dedicado requer permitir conexões de entrada das portas que o servidor Valheim usa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;visao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento Arquitetural do Compcult Mobile</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/compcult-mobile/</link>
       <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/compcult-mobile/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Adiel Andrade Rocha.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 114110411&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:adiel.rocha@ccc.ufcg.edu.br&#34;&gt;adiel.rocha@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/CompCult/compcult-mobile&#34;&gt;https://github.com/CompCult/compcult-mobile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----compcult-mobile&#34;&gt;Descrição Arquitetural &amp;ndash; CompCult Mobile&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do &lt;a href=&#34;https://github.com/CompCult/compcult-mobile&#34;&gt;Compcult Mobile&lt;/a&gt;.
As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;O Compcult Mobile é um aplicativo base feito com o framework &lt;a href=&#34;https://flutter.dev/&#34;&gt;Flutter&lt;/a&gt;, para dispositivos Android e Ios. Sendo então aplicativo de compartilhamento e aprendizado dinâmico através de atividades didáticas em mundo real e virtual, utilizando assim de uma estrategia de gamificação em realidade alternada. O aplicativo conecta o professor e o aluno, onde o professor tem acesso a um painel web onde ele configura as missões, quizzes e mini-games disponiveis para seu alunos, e ficam assim disponiveis para o aluno realiza-los no aplicativo.&lt;/p&gt;
&lt;p&gt;O Compcult Mobile conta com as seguintes funcionalidades:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Criação de conta&lt;/li&gt;
&lt;li&gt;Login&lt;/li&gt;
&lt;li&gt;Responder missões onde podem ser enviado fotos, videos, audio, geolocalização e texto&lt;/li&gt;
&lt;li&gt;Responder quizzes&lt;/li&gt;
&lt;li&gt;Mini-games(jogo da memoria)&lt;/li&gt;
&lt;li&gt;Criação de Grupos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mais informações podem ser encontradas &lt;a href=&#34;https://github.com/CompCult/compcult-mobile#readme&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h2&gt;
&lt;p&gt;Oferecer um aplicativo de ensino em realidade alternada que conecta alunos e professores para dispositivos Android e Ios.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;h2 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h2&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do Gatsby Stater Shopify</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/gatsby/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/gatsby/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jardely Maris da SIlva Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110274&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jardely.santos@ccc.ufcg.edu.br&#34;&gt;jardely.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/gatsbyjs/gatsby-starter-shopify&#34;&gt;https://github.com/gatsbyjs/gatsby-starter-shopify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---gatsby-starter-shopify&#34;&gt;Descrição Arquitetural - Gatsby Starter Shopify&lt;/h1&gt;
&lt;p&gt;Neste documento, é descrito um serviço de criação de sites e aplicações web, o &lt;a href=&#34;https://github.com/gatsbyjs/gatsby-starter-shopify&#34;&gt;Gatsby Starter Shopify&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-gatsby-starter-shopify&#34;&gt;Descrição geral sobre o Gatsby Starter Shopify&lt;/h2&gt;
&lt;p&gt;O Gatsby é um framework que tem como objetivo facilitar a criação de sites e aplicações web. Ele é baseado em React e no build gera arquivos estáticos que serão acessados pelos usuários. Isso faz com que, com a ajuda do Gatsby, seja mais fácil criar sites com suporte a SEO e que sejam mais rápidos, além de possuir muitos plugins facilitando ainda mais a experiência.&lt;/p&gt;
&lt;p&gt;O Gatsby Shopify é uma especificação do Gatsby, que é uma plataforma de e-commerce que possibilita a criação de lojas online e facilita a compra e venda de produtos pela internet. Gatsby Starter Shopify é uma parte do Shopify, a qual permite que a página da loja seja desenvolvida usando react.&lt;/p&gt;
&lt;p&gt;O site oficial do Gatsby é: &lt;a href=&#34;https://www.gatsbyjs.com/&#34;&gt;https://www.gatsbyjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-gatsby-starter-shopify&#34;&gt;O serviço Gatsby Starter Shopify&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que facilite a abertura de novas lojas online.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Além de poder proporcinar a facilidade de iniciar um ecommerce, o Gatsby Starter Shopify permite que um iniciante possa personalizar a sua loja e até adicionar plugins que irão ajudar a gerenciar, encontrar clientes e até impulsionar as vendas. Para isso, o Gatsby Starter Shopify traz um modelo padrão da página que pode ser desenvolvida e customizada usando React e Chakra-UI.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Gatsby Starter Shopify é uma loja padrão que irá guiar o desenvolvedor a implementar a loja personalizada de acordo com o desejo do dono da loja. No admin do Shopify o dono da loja pode visualizá-la e gerenciá-la. O cliente, por sua vez, poderá visualizar e fazer compras.&lt;/p&gt;
&lt;p&gt;O Gatsby tem vários plugins que facilitam o desenvolvimento.O Starter Shopify faz uso de alguns desses plugins, como por exemplo, para acessar o backend ou até fazer deploy. Portanto, a grande maioria dos serviços que são utilizados nesse sistema são desenvolvidos pela Gatsby. Um sistema externo que é usado é o Amazon Web Service (AWS) para fazer o deploy do backend.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;gatsby-context.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O desenvolvedor cria e personaliza a loja a partir da APlicação Web usando React, Chakra-UI, markdown e os plugins da Gatsby para implementar as funcionalidades. A página web da loja é gerenciada pelo dono que pode adicionar, remover, editar itens através do admin da Shopify e por fim, visualizar a sua loja. Os clientes podem visualizar a loja, fazer pedidos, uma compra, etc.&lt;/p&gt;
&lt;p&gt;A página web tem o deploy na Gatsby Cloud que é o serviço de nuvem da Gatsby. Os dados da página são obtidos através de chamadas na API via markdown que são interpretados pelo plugin &lt;code&gt;gatsby-plugin-image&lt;/code&gt; que faz as requisições em GraphQL. Gatsby faz uso do Redux como armazenamento. Os plugins do Gatsby processam os dados transformando-os em nós que são adicionados numa coleção de nós do Redux. Ele armazena essas coleções na memória durante o tempo de construção ou desenvolvimento e consultas GraphQL com base em um esquema GraphQL gerado automaticamente.&lt;/p&gt;
&lt;p&gt;Por fim, a API tem o seu deploy na Amazon Web Service (AWS).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;gatsby-container.png&#34; alt=&#34;containers&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo contém os principais componentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Home: A página principal da loja a qual contém informações sobre a loja e as coleções.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coleção: A coleção é composta por produtos. Sua função é tornar os produtos mais acessíveis, ou seja, mais fáceis de ser encontrado pelos clientes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Catálogo: É a página que contém a listagem de todos os produtos do catálogo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Carrinho de compras: É composto pelos produtos os quais o cliente marcou para comprar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Produtos: São os itens adicionados na loja pelo dono ou admistrador da loja.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;gatsby-component.png&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da informação&lt;/h3&gt;
&lt;p&gt;Ao criar a loja no admin do Shopify, é possível desenvolver a página da loja a partir do Gatsy Starter Shopify usando as credenciais de sua loja. Ainda no admin, é possível adicionar dados como produtos, coleções, etc. Isso independe do desenvolvimento loja. Caso a página não seja personalizada, o Gatsby Starter Shopify disponibiliza um padrão o qual já pode ser vista pelos clientes. Caso a página tenha sido desenvolvida, é feito o deploy na Gatsby Cloud. Por fim, a loja fica visível e disponível para os clientes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;gatsby-informacao.png&#34; alt=&#34;informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do VLC</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/vlc/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/vlc/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve a arquitetura de uma parte do projeto VLC.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;vlc.gif&#34; alt=&#34;vlc&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Higor Santos de Brito Dantas.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110808&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:higor.dantas@ccc.ufcg.edu.br&#34;&gt;higor.dantas@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/videolan/vlc&#34;&gt;https://github.com/videolan/vlc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----vlc&#34;&gt;Descrição Arquitetural &amp;ndash; VLC&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/videolan/vlc&#34;&gt;VLC&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do VLC. O foco será dado no módulo responsável por realizar a saída de vídeo, que é uma das partes mais importantes do programa.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-vlc&#34;&gt;Descrição Geral sobre o VLC&lt;/h2&gt;
&lt;p&gt;O VLC é um projeto desenvolvido pela &lt;a href=&#34;https://www.videolan.org/vlc/index.pt_BR.html&#34;&gt;VideoLAN&lt;/a&gt; que funciona como um player de arquivos de vídeos e como um servidor de mídia via streaming. Atualmente, o VLC pode ser instalado em computadores com os sistemas operacionais &lt;code&gt;Windows&lt;/code&gt;, &lt;code&gt;MacOS&lt;/code&gt;, &lt;code&gt;Linux&lt;/code&gt;, &lt;code&gt;Chrome OS&lt;/code&gt;, entre outros, além de dispositivos móveis com &lt;code&gt;Android&lt;/code&gt;, &lt;code&gt;iOS&lt;/code&gt;, &lt;code&gt;iPadOS&lt;/code&gt;, &lt;code&gt;Tizen&lt;/code&gt;.&lt;br&gt;
O software é capaz de reproduzir a maioria dos codificadores (MPEG-2, MPEG-4, MKV, H.264, MP3&amp;hellip;) sem ser necessário instalar pacotes adicionais, suporta reprodução de CDs e DVDs, além de vários protocolos de streaming.&lt;/p&gt;
&lt;h2 id=&#34;serviço-de-saída-de-vídeo&#34;&gt;Serviço de Saída de Vídeo&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O VLC busca servir de um &lt;code&gt;media player&lt;/code&gt; completo.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O VLC tem diversas funcionalidades como reprodução de arquivos de vídeos, de CDs e DVDs, de streaming, entre outras. E, em grande parte, uma atividade necessita ser realizada: a saída das imagens na tela do computador, celular, TV&amp;hellip;, enfim, qualquer dispositivo que o mesmo esteja sendo executado. Portanto, ele busca prover uma ferramenta que facilite a visualização de vídeos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para a plataforma insomnia-inso</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/insomnia-inso/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/insomnia-inso/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Dacio Silva Bezerra.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118210572&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:dacio.bezerra@ccc.ufcg.edu.br&#34;&gt;dacio.bezerra@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Kong/insomnia/blob/develop/packages/insomnia-inso&#34;&gt;https://github.com/Kong/insomnia/blob/develop/packages/insomnia-inso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---insocli-by-insomnia&#34;&gt;Descrição Arquitetural - Inso(CLI) by Insomnia&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura da plataforma &lt;a href=&#34;https://insomnia.rest/&#34;&gt;insomnia-cli&lt;/a&gt;. Esta descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Há de se notar que esta representação da arquitetura do projeto supracitado, engloba um módulo - o módulo de CLI - específico da aplicação de integração CI/CD, chamado de &lt;strong&gt;insomnia-inso&lt;/strong&gt; que se trata do &lt;em&gt;main&lt;/em&gt; da aplicação CLI utilizando o TypeScript.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-insocli-by-insomnia&#34;&gt;Descrição Geral sobre o Inso(CLI) by Insomnia&lt;/h2&gt;
&lt;p&gt;A aplicação tem por objetivo implantação e publicação de especificações com confiança garantir que elas sejam válidas durante a fase de teste e implantação de um pipeline de CI / CD.&lt;/p&gt;
&lt;p&gt;Facilita o teste ou a implantação de produção gerando a configuração Kong Declarative ou Kong For Kubernetes com plug-ins diretamente das especificações OpenAPI em qualquer lugar em um pipeline de CI / CD.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Acelerar o deploy de APIs e suas principais funcionalidades.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Integrar facilmente com provedores Git como Github, Gitlab e Bitbucket para construir pipelines de API CI / CD personalizados que funcionam com os fluxos de trabalho existentes.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema. Nele temos um usuário que pode interagir com o Inso (a aplicação de automação de pipeline CI/CD para APIs) seja em sua máquina utilizando-o diretamente como forma de automatizar seu fluxo localmente, ou da forma mais comum, a qual seria a interação pelo gitlab, por exemplo, por meio da ferramenta de configuração de pipeline do Git. Essa ferramenta processaria todo o ferramental provido pelo Inso possibilitando ao usuário, a criação de seu pipeline personalizado para sua API. O Inso utiliza um commander, um módulo externo que disponibiliza para ele toda a base de interpretação de linha de comando. Além disso, o Inso exporta consigurações, para kubernetes, por exemplo. Para tal, ele utiliza o openapi-2-kong que faz todo o &amp;ldquo;trabalho sujo&amp;rdquo; pra ele no que diz respeito a essa &lt;em&gt;task&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;context&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a plataforma insomnia-inso:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;p&gt;Vamos detalhar cada container e seu papel dentro do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cli: Este seria o nosso principal container. Ele processa os comando pré-processados pelo commander, utiliza outro módulo importante da aplicação que seriam o &lt;em&gt;Commands&lt;/em&gt; para realizar o comando em questão. A ferramenta do Git pode utilizar sua exportação de configurações para realizar o pipeline CI/CD bem como o usuário pode utilizá-lo diretamente/localmente. O Cli também é responsável por persistir informações relevantes num banco de dados &lt;em&gt;in-memory&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Commands: Responsável pelo processamento e validação individual dos comandos. Por exemplo, em um contexto de comando de teste, este módulo recebe as opções, valida as opções, roda os testes, encontra suites, gera relatório e devolve tudo para o Cli.&lt;/li&gt;
&lt;li&gt;Database: Armazena informações relevantes dos pipelines utilizados no disco, localmente e para uso futuro ou log.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;component.png&#34; alt=&#34;component&#34;&gt;&lt;/p&gt;
&lt;p&gt;Extraindo os componentes do container Cli, temos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git Component: Módulo responsável por receber requisições do Git e chamar o componente Go para realizar os passos necessários.&lt;/li&gt;
&lt;li&gt;Inso generate-config: Componente responsável por gerar configuração utilizando o openapi-kong.&lt;/li&gt;
&lt;li&gt;Inso lint: Componente responsável por executar ações referente ao lint de código da API. Assim como a maioria dos componentes, utiliza o container Commands para processamento.&lt;/li&gt;
&lt;li&gt;Inso test: Componente responsável por executar e produzir relatórios sobre os testes da API.&lt;/li&gt;
&lt;li&gt;Inso export: Esse componente extrai e exporta as informações geradas no Inso generate-config. As configurações ficam guardadas no Database, o componente Go recebe a requisição e repassa para o Inso export para ele gerar um exportável a partir das informações de configuração.&lt;/li&gt;
&lt;li&gt;Go: Componente mais importante da stack. Ele compila todas as requisições e então redireciona para seus devidos responsáveis. Recebe as respostas de volta e recompila todas as respostas, processa tudo em batch e retorna para o cliente uma resposta.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;Neste exemplo de máquina de estados temos um exemplo bem simples de como funcionaria o fluxo em um pipeline no Inso-Cli. Não é nada de outro mundo.&lt;/p&gt;
&lt;p&gt;Temos um fluxo simples no contexto de execução de um pipeline no Git CI/CD. Temos apenas dois comandos sendo executados: Lint e test. Após o Git iniciar o pipeline o documento gerado pelo componente do Git deve possibilitar, logo em seguida, o build do Node na máquina virtual, se essa instalação der erro, o pipeline encerra com erro. Após a instalação, o npm pode estar disponível e então o Lint pode ser executado, após o Lint ser executado o comando de Teste é executado. Se os testes falharem o pipeline encerra com falha, do contrário, o pipeline se encerra com sucesso.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o MySQL Workbench</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/mysql-workbench/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/mysql-workbench/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto MySql-Workbench&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thalys Menezes Cunha Gadelha.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210271&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thalys.gadelha@ccc.ufcg.edu.br&#34;&gt;thalys.gadelha@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/mysql/mysql-workbench&#34;&gt;https://github.com/mysql/mysql-workbench&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----mysql-workbench&#34;&gt;Descrição Arquitetural &amp;ndash; MySQL Workbench&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, e tem como objetivo descrever parte da arquitetura do projeto &lt;a href=&#34;https://github.com/mysql/mysql-workbench&#34;&gt;MySQL Workbench&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-mysql-workbench&#34;&gt;Descrição Geral sobre o MySQL-Workbench&lt;/h2&gt;
&lt;p&gt;O MySQL Workbench é uma ferramenta visual unificada para arquitetos de banco de dados, desenvolvedores e DBAs. O MySQL-Workbench provê modelagem de dados, desenvolvimento SQL, e ferramentas administrativasde fácil compreensão para configuração de servidores, administração de usuários, backup, entre várias outras funcionalidades.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural do Sequelize</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/sequelize/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/sequelize/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por José Thiago dos Santos Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110537&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jose.thiago.silva@ccc.ufcg.edu.br&#34;&gt;jose.thiago.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/sequelize/sequelize&#34;&gt;https://github.com/sequelize/sequelize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----sequelize&#34;&gt;Descrição Arquitetural &amp;ndash; Sequelize&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/sequelize/sequelize&#34;&gt;Sequelize&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-sequelize&#34;&gt;Descrição Geral sobre o Sequelize&lt;/h2&gt;
&lt;p&gt;O sequelize é um ORM - Mapeamento Objeto Relacional (Object Relational Mapping) para Node.js baseado em promises, que suporta transações sólidas, relacionamentos, eager e lazy loading, replicação para leitura, entre outras funcionalidades. É uma ferramenta que é utilizada para fazer a ponte entre o banco de dados e objetos conhecidos pela linguagem de programação. O sequelize tem suporte para o JavaScript e TypeScript.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>React Intl</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/react-intl/</link>
       <pubDate>Wed, 14 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/react-intl/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Rayla Medeiros Araújo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110383&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:rayla.araujo@ccc.ufcg.edu.br&#34;&gt;rayla.araujo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/formatjs/formatjs/tree/main/packages/react-intl&#34;&gt;https://github.com/formatjs/formatjs/tree/main/packages/react-intl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----react-intl&#34;&gt;Descrição Arquitetural &amp;ndash; React Intl&lt;/h1&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-react-intl&#34;&gt;Descrição Geral sobre o React Intl&lt;/h2&gt;
&lt;p&gt;O React Intl é uma das várias bibliotecas oferecidas pelo FormatJS, coleção de bibliotecas JavaScript, que segue os padrões do JavaScript Intl e do i18n, para internacionalização de números, datas e strings. Sendo essa biblioteca específica utilizada na internacionalização e formatação de aplicações &lt;em&gt;React&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Auxiliar na internacionação de projetos &lt;em&gt;React&lt;/em&gt;, a partir da criação de objetos simples de serem trabalhados.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A biblioteca tem como objetivo trazer a internacionalização de strings, datas, números e pluralização para aplicações &lt;em&gt;React&lt;/em&gt;, com uma API simples que pode ser utilizada tanto em componentes JSX quanto no código Javascript.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Como dito antes, o react-intl é uma biblioteca oferecida pelo FormatJs, que manipula strings, datas, listas, números e pluralizações, tendo em vista a simplificação da internacionalização de aplicações &lt;em&gt;React&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O desenvolvedor da aplicação passa as strings internacionalizadas de cada locale que ele deseja utilizar e o react-intl faz a formatação das mensagens a partir do locale selecionado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;react-intl_context.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O react-intl pode ser divida em dois containers principais: o I18n, responsavél pela configuração do idioma e paramêtros necessários para usar a biblioteca; e o Formatador de Dados, que formata e manipula as mensagens a partir das configurações feitas no I18n e customizações que o usuário pode passar.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;react-intl_container.png&#34; alt=&#34;containers&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo contém os principais componentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Provider: Permite que o usuário configure o idioma da aplicação feita e as mensagens correspondentes a cada idioma.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Formatadores: Formata as mensagens recebidas de acordo com o idioma e customizações que o usuário deseje fazer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manipuladores: Manipula datas, horas e pluralização de acordo com o configurações específicas para esses casos, e no caso das datas e horas também há uma manipulações com intervalos de tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;react-intl_component.png&#34; alt=&#34;componentes&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Ao configurar as mensagens de internacionalização e o locale, a aplicação está pronta para formatar ou manipular as mensagens recebidas. O usuário escolhe a mensagem que deseja manipular e então o react-intl, a partir das configurações feitas, retorna ao usuário sua mensagem formatada.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;react-intl_information.png&#34; alt=&#34;informação&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural Moodle</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/moodle/</link>
       <pubDate>Tue, 13 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/moodle/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Talita Galdino Gouveia.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118111778&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:talita.gouveia@ccc.ufcg.edu.br&#34;&gt;talita.gouveia@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/moodle/moodle&#34;&gt;https://github.com/moodle/moodle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---moodle&#34;&gt;Descrição Arquitetural - Moodle&lt;/h1&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img src=&#34;logo.png&#34; style=&#34;width: 25rem;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/moodle/moodle&#34;&gt;Moodle&lt;/a&gt;, baseando-se no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-moodle&#34;&gt;Descrição geral sobre o Moodle&lt;/h2&gt;
&lt;p&gt;O moodle é uma plataforma de aprendizagem open source projetada para dar suporte a professores, alunos e administradores. Criado para possibilitar uma melhor experiência no ensiono a distância o moodle é usado por diversas escolas e universidades atualmente, inclusive a UFCG. Além do suporte a esses tipos de usuário, ele permite a personalização dos seus ambientes.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Horários UFCG</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/horarios-ufcg/</link>
       <pubDate>Tue, 13 Apr 2021 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/horarios-ufcg/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Eduardo Pereira dos Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210342&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:eduardo.pereira.santos@ccc.ufcg.edu.br&#34;&gt;eduardo.pereira.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/Guardians-DSC/horarios-ufcg&#34;&gt;https://github.com/Guardians-DSC/horarios-ufcg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----horários-ufcg-frontend&#34;&gt;Descrição Arquitetural &amp;ndash; Horários UFCG Frontend&lt;/h1&gt;
&lt;div align=&#34;center&#34; style=&#34;margin-top:1.5rem;&#34;&gt;
    &lt;img src=&#34;horarios-ufcg-logo.png&#34; style=&#34;width:20rem;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Este documento descreve o Frontend do Horários UFCG. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-horários-ufcg&#34;&gt;Descrição Geral sobre o Horários UFCG&lt;/h2&gt;
&lt;p&gt;O Horários UFCG é uma aplicação SPA (Single Page Application), feita em &lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt;, que fornece uma visualização moderna e limpa, ajudando os alunos de Ciência da Computação a montar seu horário antes da realização das matrículas. Além disso, fornece opções de filtragem e pesquisa permitindo uma experiência mais otimizada.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Visualizar os horários das disciplinas dos cursos da UFCG, a princípio do curso de Ciência da Computação.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Ajudar o aluno da UFCG a visualizar melhor os conflitos entre disciplinas e organizar o seu horário, fornecendo uma visualização limpa e amigável.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Como vemos no diagrama de contexto, o Horários UFCG utiliza-se de uma API externa que fornece as disciplinas e horários, que são requisitados utilizando o protocolo HTTP.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Horários UFCG é basicamente uma aplicação &lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; e faz uso do LocalStorage para armazenar as disciplinas selecionadas, mantendo-as salvas mesmo após o fechamento da página.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O Horários UFCG é composto, basicamente, em três tipos de componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visualização: Horário, Dia, Aula, Tabela e Model&lt;/li&gt;
&lt;li&gt;Filtragem e Pesquisa (contém visualização): NavBar e Filtro&lt;/li&gt;
&lt;li&gt;Serviços: Store e Services&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;componente.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O fluxo de informação é bem simples. O usuário escolhe suas disciplinas e em seguida remove os choques de horário, isso se repete até o usuário achar um horário adequado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural ORY Oathkeeper</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/oathkeeper/</link>
       <pubDate>Wed, 09 Dec 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/oathkeeper/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Hemillainy Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210802&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:hemillainy.santos@ccc.ufcg.edu.br&#34;&gt;hemillainy.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ory/oathkeeper&#34;&gt;https://github.com/ory/oathkeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----ory-oathkeeper&#34;&gt;Descrição Arquitetural &amp;ndash; ORY Oathkeeper&lt;/h1&gt;
&lt;p&gt;Nesse documento será descrita a arquitetura base do projeto &lt;a href=&#34;https://github.com/ory/oathkeeper&#34;&gt;ORY Oathkeeper&lt;/a&gt;, utilizando o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-ory-oathkeeper&#34;&gt;Descrição Geral sobre o ORY Oathkeeper&lt;/h2&gt;
&lt;p&gt;O ORY Oathkeeper é um serviço cuja função é analisar as requisições recebidas pelo servidor a fim de validá-las. Caso a requisição seja válida, ela é encaminhada para o servidor final; caso seja inválida, o fluxo de validações é encerrado e o Oathkeeper retorna uma mensagem de erro para o cliente.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementação de um serviço, altamente configurável, que valida toda requisição que chega no servidor. A partir dessa validação, é possível filtrar requisições inválidas, impedindo assim que elas cheguem ao serviço final. Além disso, é possível também fazer alterações em requisições válidas antes de encaminhá-las.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Permitir que a aplicação possa configurar todas as regras de acesso que serão utilizadas pelo Oathkeeper no pipeline de validação. Essa configuração pode ser feita em dois formatos: JSON e YAML. Segue abaixo exemplos dessa configuração:&lt;/p&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;p&gt;JSON&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;id&amp;quot;: &amp;quot;some-id&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;v0.36.0-beta.4&amp;quot;,
    &amp;quot;upstream&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;http://my-backend-service&amp;quot;,
    &amp;quot;preserve_host&amp;quot;: true,
    &amp;quot;strip_path&amp;quot;: &amp;quot;/api/v1&amp;quot;
    },
    &amp;quot;match&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;http://my-app/some-route/&amp;lt;.\*&amp;gt;&amp;quot;,
    &amp;quot;methods&amp;quot;: [&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;]
    },
    &amp;quot;authenticators&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;noop&amp;quot; }],
    &amp;quot;authorizer&amp;quot;: { &amp;quot;handler&amp;quot;: &amp;quot;allow&amp;quot; },
    &amp;quot;mutators&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;noop&amp;quot; }],
    &amp;quot;errors&amp;quot;: [{ &amp;quot;handler&amp;quot;: &amp;quot;json&amp;quot; }]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;heading-1&#34;&gt;&lt;/h4&gt;
&lt;p&gt;YAML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id: some-id
version: v0.36.0-beta.4
upstream:
url: http://my-backend-service
preserve_host: true
strip_path: /api/v1
match:
url: http://my-app/some-route/&amp;lt;.\*&amp;gt;
methods: - GET - POST
authenticators:

- handler: noop
  authorizer:
  handler: allow
  mutators:
- handler: noop
  errors:
- handler: json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Para mais detalhes à respeito da configuração, acesse &lt;a href=&#34;https://www.ory.sh/oathkeeper/docs/api-access-rules&#34;&gt;esse link&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Oathkeeper funciona como uma camada intermediária entre o cliente e o servidor, camada esta que é responsável por fazer a validação das requisições, validando desde o formato da URL chamada até a presença ou não de tokens de acesso, escopos, etc. Desse modo, quando o usuário solicita algo ao cliente, ele enviará a requisição para o servidor, porém antes de chegar ao destino final a requisição será tratada pelo Oathkeeper, caso a requisição atenda às regras de acesso definidas no arquivo de configuração ela será encaminhada para o servidor final; se não, o Oathkeeper não fará o encaminhamento e uma mensagem de erro será retornada para o cliente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Devido à sua implementação ser escrita em GO, torna-se bastante fácil sua utilização ou integração com outros sistemas, uma vez que para utilizá-lo basta instalar o binário GO ou executar sua imagem Docker.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para lidar com as requisições, o Oathkeeper implementa o Access Rule Pipeline que é composto pelos quatro componentes descritos a seguir:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication: valida se a requisição contém as credenciais ou tokens necessários.&lt;/li&gt;
&lt;li&gt;Authorization: valida de o usuário possui as permissões necessárias.&lt;/li&gt;
&lt;li&gt;Mutation: altera as credenciais enviadas na requisição para um formato que o servidor entenda; isso permite que o servidor lide apenas com um único tipo de credencial, visto que independente do tipo que for enviado na requisição, o mutator irá transformá-la em um tipo que é compreendido pelo serviço.&lt;/li&gt;
&lt;li&gt;Error handlers: caso ocorra um erro em um dos steps de validação (authentication ou authorization), esse componente define como o erro será apresentado para o cliente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta o fluxo de uma requisição no Oathkeeper.
Ao ser enviada pelo cliente para o servidor, a requisição entrará no pipeline de regras de acesso, onde o primeiro step será a verificação por parte do Authentication. Em seguida, caso validada, ela será verificada pelo Authorization. Conforme mostra o diagrama, caso a verificação falhe em um dos steps anteriores, o Error Handler é acionado e enviará uma resposta de erro para o cliente, mas caso a requisição seja válida ela é enviada para o Mutator, onde poderá sofrer algumas alterações antes de ser encaminhada para o servidor final.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-info.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o GIMP</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/gimp/</link>
       <pubDate>Mon, 07 Dec 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/gimp/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto GIMP.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Mariana Araújo Lucena.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211305&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:mariana.lucena@ccc.ufcg.edu.br&#34;&gt;mariana.lucena@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/GNOME/gimp&#34;&gt;https://github.com/GNOME/gimp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----gnomegimp&#34;&gt;Descrição Arquitetural &amp;ndash; GNOME/gimp&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, e tem como objetivo descrever parte da arquitetura do projeto &lt;a href=&#34;https://github.com/GNOME/gimp&#34;&gt;GNOME/gimp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do GIMP. O foco aqui é a descrição de um serviço específico de análise do GIMP, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-gimp&#34;&gt;Descrição Geral sobre o GIMP&lt;/h2&gt;
&lt;p&gt;GIMP (acrônimo para GNU Image Manipulation Program) é um programa voltado, essencialmente, para edição e criação de imagens raster e, em menor escala, para desenho vetorial. O software é repleto de recursos, de fácil uso e uma boa alternativa gratuita ao mais conhecido dos editores, o gigante Adobe Photoshop.&lt;/p&gt;
&lt;h2 id=&#34;os-plugins-de-filtros-no-gimp&#34;&gt;Os Plugins de filtros no GIMP&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;As funcionalidades do GIMP pode ser facilmente estendida por meio de plugins. Plugins do GIMP são programas externos que são executados sob o controle da aplicação principal GIMP e interagem com ela muito de perto. Plugins podem manipular imagens de quase todas as formas que os usuários querem.&lt;/p&gt;
&lt;p&gt;Várias dezenas de plugins estão incluídas na distribuição oficial do GIMP e são instaladas automaticamente junto com o programa. A maioria deles pode ser acessada através do menu filtros (na verdade, tudo nesse menu é um plugin ou um script), mas vários deles estão localizados em outros menus. Em muitos casos, você pode usar um sem nunca perceber que é um plugin: por exemplo, a função &amp;ldquo;Normalizar&amp;rdquo; para correção automática de cores é na verdade um plugin, embora não há nada na maneira como ela funciona que iria demonstrar isso.&lt;/p&gt;
&lt;p&gt;Os filtros permitem fazer efeitos complexos com poucos cliques, efeitos como de iluminação, distorção, entre outros. No menu “Filtros”, você tem acesso a mais de 140 tipos de filtros diferentes. Os filtros são divididos em 15 categorias para que você consiga achá-los mais facilmente. Essas categorias são: desfocar, realces, distorções, efeitos de sombra, efeitos de luz, ruído detectar borda, genéricos, combinar, filtros artísticos, mapear, renderizar, web, animação, alfa para logo, decoração.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;É necessário executar o download do instalador do GIMP e abrir o arquivo de instalação. Depois da instalação, pode começar a usá-lo. Para a aplicação de filtros em uma imagem, é necessário fazer o upload da mesma para o programa, no menu superior selecionar a janela &amp;ldquo;Filtros&amp;rdquo; e, logo após, escolher o filtro.&lt;/p&gt;
&lt;p&gt;Para adicionar um plugin de um novo filtro na interface do GIMP é necessário instalar o plugin, descompactá-lo, entrar na pasta do efeito e copiar todos os arquivos .py. Logo após, é necessário acessar a pasta de plugins do GIMP e colar os arquivos .py selecionados anteriormente. Reinicie o programa e o novo filtro já poderá ser visto na aba &amp;ldquo;Filtros&amp;rdquo; do menu.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/contexto1.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Script-Fu é uma linguagem para escrever scripts, que permite que você execute uma série de comandos do GIMP automaticamente.&lt;/p&gt;
&lt;p&gt;Python-Fu é um conjunto de módulos Python que funcionam como um conteúdo adicional para libgimp, permitindo a escrita de plug-ins para o GIMP.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/containers.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O GIMP foi projetado para ser extensível com scripts e plug-ins. Esses dois são tecnicamente diferentes, os scripts estão em Script-Fu e são interpretados pelo interpretador de script integrado. Plugins são processos independentes escritos em potencialmente qualquer idioma. Por muito tempo isso significou apenas C, mas desde o 2.6 também existe uma interface para Python. Mas, para complicar as coisas, a maioria dos &amp;ldquo;plug-ins&amp;rdquo; python são escritos como scripts: eles são principalmente colados entre as chamadas para a API do Gimp, como as de script-fu, então você ouvirá sobre scripts Python (mas eles são realmente plug-ins).&lt;/p&gt;
&lt;h4 id=&#34;script-fu&#34;&gt;Script-Fu&lt;/h4&gt;
&lt;p&gt;Script-Fu é o que o alguns aplicativos chamam de &amp;ldquo;macros&amp;rdquo;. Script-Fu é baseado em uma linguagem interpretada chamada Scheme, e funciona usando funções do banco de procedimentos do GIMP. É possível fazer todos os tipos de coisas com Script-Fu, mas um usuário comum do GIMP provavelmente irá usá-lo para automatizar as coisas que: faz com frequência e/ou são muito complicadas de fazer, e difíceis de lembrar.&lt;/p&gt;
&lt;p&gt;Existem muitos scripts que vêm com o GIMP por padrão, mas existem também grandes quantidades de scripts que estão disponíveis para download em toda Internet.&lt;/p&gt;
&lt;p&gt;Se você tiver baixado um script, copie ou mova o para seu diretório de scripts. Ele pode ser encontrado em Preferências: Pastas → Scripts.&lt;/p&gt;
&lt;p&gt;Faça uma atualização usando filtros → Script-Fu → Atualizar Scripts no menu imagem. O script agora vai aparecer em um dos seus menus. Se você não encontrá-lo, procurar nos filtros no menu de arquivos raiz. Se ele não aparecer em lugar nenhum, algo estava errado com o script e ele não funcionou. (por exemplo, contém erros de sintaxe).&lt;/p&gt;
&lt;h4 id=&#34;python-fu&#34;&gt;Python-Fu&lt;/h4&gt;
&lt;p&gt;Gimp-Python é uma extensão de script para Gimp, semelhante ao Script-Fu. A principal diferença está no que é chamado primeiro. No Script-Fu, o plugin script-fu executa o script, enquanto no Gimp-Python o script está no controle. Outro ponto de diferença entre o Gimp-Python e o Script-Fu é que o Gimp-Python armazena imagens, camadas, canais e outros tipos como objetos em vez de apenas armazenar seus IDs. Isso permite uma melhor verificação de tipo que está faltando no Script-Fu e permite que esses tipos atuem como objetos, completos com atributos e métodos.&lt;/p&gt;
&lt;p&gt;Além disso, o Gimp-Python não se limita apenas a chamar procedimentos do PDB. Ele também implementa o resto do libgimp , incluindo blocos e regiões de pixel, e acesso a outras funções de nível inferior.&lt;/p&gt;
&lt;p&gt;Existe um módulo python chamado plugin.py que define uma estrutura para plug-ins e implementa algumas coisas que eram muito difíceis ou impossíveis de fazer em C.&lt;/p&gt;
&lt;p&gt;O principal objetivo do plugin.py é implementar uma estrutura orientada a objetos para plug-ins. Além disso, ele lida com tracebacks, que de outra forma são ignorados por libgimp, e fornece um método para chamar outros plug-ins Gimp-Python sem passar pelo banco de dados procedural.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O Arquivo é primeiramente selecionado pelo usuário para realização de upload no programa, em seguida é necessário selecionar o filtro desejado, aplicá-lo na imagem, a partir dai tem-se duas opções: salvar e fechar o arquivo ou reverter ao original.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;center&#34; border=&#34;15px&#34; src=&#34;https://github.com/marianaalucena/mini-projeto/blob/main/imagens/infoFiltro.jpg?raw=true&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Até o presente momento ainda não foi aberto nenhum pull request desta documentação para o repositório de docs do GNOME/GIMP.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Inkscape</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/inkscape/</link>
       <pubDate>Tue, 13 Oct 2020 20:00:32 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/inkscape/</guid>
       <description>&lt;h3 id=&#34;autores&#34;&gt;Autores&lt;/h3&gt;
&lt;p&gt;Este documento foi produzido por Gustavo Alves.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Matrícula: 117110919&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contato: &lt;a href=&#34;mailto:gustavo.daniel.alves@ccc.ufcg.edu.br&#34;&gt;gustavo.daniel.alves@ccc.ufcg.edu.br&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Projeto documentado: &lt;a href=&#34;https://gitlab.com/inkscape/inkscape&#34;&gt;https://gitlab.com/inkscape/inkscape&lt;/a&gt; | &lt;a href=&#34;https://gitlab.com/inkscape/extensions&#34;&gt;https://gitlab.com/inkscape/extensions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural--inkex-api&#34;&gt;Descrição Arquitetural – InkEx API&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto Inkscape. Essa descrição foi baseada principalmente no modelo C4.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será escrita toda a arquitetura do Inkscape. O foco principal é descrever a InkEx, API que permite a criação e utilização de extensões no programa.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-inkscape&#34;&gt;Descrição geral sobre o Inkscape&lt;/h2&gt;
&lt;p&gt;O Inkscape se define como um editor de gráficos vetoriais open source. O programa funciona de forma similar a aplicativos famosos como Adobe Illustrator e Corel Draw, com a diferença de utilizar como forma nativa o padrão aberto SVG (Scalable Vector Graphics).&lt;/p&gt;
&lt;h2 id=&#34;a-inkex&#34;&gt;A InkEx&lt;/h2&gt;
&lt;h4 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h4&gt;
&lt;p&gt;Permitir a extensão por parte dos usuários das funcionalidades do Inkscape a partir de uma API.&lt;/p&gt;
&lt;h4 id=&#34;objetivo-específico&#34;&gt;Objetivo específico&lt;/h4&gt;
&lt;p&gt;Expor uma API que permita que os usuários adicionem funcionalidades ao Inkscape sem necessitar conhecer C++ e GTK, porém apenas Python e XML, tornando-a mais acessível e sem necessidade de compilação prévia.&lt;/p&gt;
&lt;h4 id=&#34;contexto&#34;&gt;Contexto&lt;/h4&gt;
&lt;img src=&#34;Diagrama de contexto.svg&#34; class=&#34;center&#34; style=&#34;height: 700px;&#34;&gt;
&lt;p&gt;Por padrão o Inkscape dá suporte a diferentes fluxos de trabalho, desde a sua utilização para a criação de novos vetores como para o processamento dos já pré-existentes. Apesar disto, é sempre interessante permitir que o usuário expanda as funcionalidades do software aumentando a sua produtividade ou abrindo um novo leque de possibilidades de criação.&lt;/p&gt;
&lt;p&gt;Para isto, o Inkscape fornece uma API que permite integrar scripts de funcionalidade ao fluxo de trabalho do programa.&lt;/p&gt;
&lt;h4 id=&#34;containers&#34;&gt;Containers&lt;/h4&gt;
&lt;img src=&#34;Diagrama de contêineres.svg&#34; class=&#34;center&#34;&gt;
&lt;p&gt;As extensões do Inkscape são acessados pelo próprio Inkscape, sendo expostas a partir dos front-ends disponíveis (GUI e CLI). Ao aplicar a funcionalidade de uma extensão, o back-end envia o SVG para a extensão que deverá processá-la e retornar o SVG modificado para o back-end.&lt;/p&gt;
&lt;h4 id=&#34;componentes&#34;&gt;Componentes&lt;/h4&gt;
&lt;img src=&#34;Diagrama de componentes.svg&#34; class=&#34;center&#34;&gt;
&lt;p&gt;As extensões do Inkscape são compostas de dois componentes:&lt;/p&gt;
&lt;h5 id=&#34;descritores&#34;&gt;Descritores&lt;/h5&gt;
&lt;p&gt;Os descritores são arquivos Inkscape XML (.inx) que fornecem informações ao Inkscape referentes aos parâmetros, interface, strings para tradução, configuração e identificação da extensão.&lt;/p&gt;
&lt;h5 id=&#34;scripts&#34;&gt;Scripts&lt;/h5&gt;
&lt;p&gt;Os scripts são os arquivos Python que serão utilizados para realizar o processamento dos arquivos. Eles recebem o SVG a partir de um caminho ou pela entrada padrão. Após finalizar os processamento do arquivo, os scripts podem tanto salvar o arquivo modificado ou reenviá-lo ao Inkscape pela saída padrão. Apesar de não aconselhável, os scripts podem chamar o Inkscape da mesma forma para realizar alguma operação específica.&lt;/p&gt;
&lt;h4 id=&#34;implementação&#34;&gt;Implementação&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;informação&#34;&gt;Informação&lt;/h4&gt;
&lt;p&gt;O fluxo e estados da informação são bastante simples. O SVG é recebido via arquivo ou entrada padrão, é feito uma cópia que se processada corretamente é escrita no arquivo ou na saída padrão.&lt;/p&gt;
&lt;img src=&#34;Visão de informação.png&#34; class=&#34;center&#34;&gt;
&lt;h3 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h3&gt;
</description>
     </item>
   
     <item>
       <title>Arquitetura do Jitsi Meet</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jitsi-meet/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jitsi-meet/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Daniele Aparecida de Melo Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110348&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:daniele.silva@ccc.ufcg.edu.br&#34;&gt;daniele.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/jitsi/jitsi-meet&#34;&gt;https://github.com/jitsi/jitsi-meet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-gravação-de-uma-conferência&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de gravação de uma conferência&lt;/h1&gt;
&lt;p&gt;Neste documento, é descrito um serviço específico de gravaçãode uma conferenência do projeto &lt;a href=&#34;https://github.com/jitsi/jitsi-meet&#34;&gt;Jitsi Meet&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-o-jitsi-meet&#34;&gt;Sobre o Jitsi Meet&lt;/h2&gt;
&lt;p&gt;O Jitsi Meet é uma solução de videoconferência totalmente criptografada e de código aberto disponível todos os dias gratuitamente. O Jitsi Meet é executado no navegador, sem necessidade de criar uma conta ou de instalação.&lt;/p&gt;
&lt;p&gt;O Jitsi Meet permite uma colaboração muito eficiente. Os usuários podem transmitir sua área de trabalho ou apenas algumas janelas. Ele também suporta edição de documentos compartilhados com Etherpad. O site oficial é: &lt;a href=&#34;https://meet.jit.si&#34;&gt;https://meet.jit.si&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-o-serviço-de-gravação-de-uma-conferência&#34;&gt;Sobre o serviço de gravação de uma conferência&lt;/h2&gt;
&lt;p&gt;O objetivo desse serviço é capturar áudio e vídeo de uma conferência e salvar localmente.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto de gravação de uma conferência compreende os seguintes sistemas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jitsi Meet — aplicação JavaScript que usa o Jitsi Videobridge para fornecer videoconferências ​​de alta qualidade, seguras e escaláveis.&lt;/li&gt;
&lt;li&gt;Jitsi Conference Focus (Jicofo) — componente server-side usado nas conferências do Jitsi Meet para gerenciar as sessões de mídia entre cada um dos participantes e o Videobridge.&lt;/li&gt;
&lt;li&gt;Jibri — conjunto de ferramentas para gravar e/ou transmitir uma conferência do Jitsi Meet.&lt;/li&gt;
&lt;li&gt;Prosody — servidor externo XMPP (abreviação para &lt;em&gt;Extensible Messaging and Presence Protocol&lt;/em&gt;) usado para sinalização.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No seguinte diagrama de contexto para o serviço de gravação, o processo começa quando o usuário clica em &amp;ldquo;Iniciar gravação&amp;rdquo;. O frontend do Jitsi Meet captura esse evento e o servidor envia uma requisição para o Prosody em formato XMPP, para que este encaminhe a mensagem ao Jicofo. O Jitsi Meet possui uma instância da conferência criada pelo Jicofo — responsável por todo o gerenciamento de uma conferência —, mas a comunicação entre eles é via XMPP.&lt;/p&gt;
&lt;p&gt;Jicofo recebe um token e o formato do arquivo de gravação (&amp;lsquo;ogg&amp;rsquo;, &amp;lsquo;flac&amp;rsquo; ou &amp;lsquo;wav&amp;rsquo;) e utiliza o Jibri para lidar com a gravação. O Jibri é notificado que a gravação deve ser iniciada e entra como participante para gravar a conferência. Então, informa ao Jicofo seu novo status.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Jitsi Meet é composto de quatro containers: aplicação client-side escrita em React; aplicação móvel implementada com React Native; um servidor Nginx; e um banco de dados SQL.&lt;/p&gt;
&lt;p&gt;As aplicações se comunicam com o servidor via HTTPS. O Nginx conversa com o Prosody atráves de mensagens XMPP, para então ser encaminhadas ao Jicofo. Jicofo e Jibri são escritos na linguagem Java.&lt;/p&gt;
&lt;p&gt;Abaixo se encontra o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No Jitsi Meet, existem três componentes principais para o processo de gravação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RecordingController, que lida com a sinalização entre os participantes e serve de fachada para outros componentes.&lt;/li&gt;
&lt;li&gt;RecordingAdapter, que engloba a API de áudio da Web e diferentes codecs de áudio. Possui uma interface que facilita alternar entre diferentes formatos e serve como um ponto para futuras extensões.&lt;/li&gt;
&lt;li&gt;SessionManager, que gerencia e mantém as informações sobre cada segmento da gravação. Essas informações são usadas para restauração de travamento e concatenação de segmentos da gravação.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As gravações são mantidas no armazenamento local do navegador (local storage) de cada participante, que não possui uma cota. Um codec com espaço eficiente diminui o risco de perda de gravações devido ao espaço.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de componentes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como mencionado, o Jibri entra na conferência como um participante e, em seguida, captura vários fluxos de áudio/vídeo e os envia para arquivos locais.&lt;/p&gt;
&lt;p&gt;Em termos gerais, as etapas para gravar uma conferência são:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criar uma sessão com a conferência JitsiMeet;&lt;/li&gt;
&lt;li&gt;Receber fluxos de áudio/vídeo;&lt;/li&gt;
&lt;li&gt;Receber fluxos de mídia;&lt;/li&gt;
&lt;li&gt;Gravar fluxos de áudio/vídeo;&lt;/li&gt;
&lt;li&gt;Gravar streams de mídia;&lt;/li&gt;
&lt;li&gt;Registrar metadados.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Os metadados são mensagens legíveis por humanos que descrevem todo o procedimento de gravação, por exemplo: gravação iniciada, gravação finalizada e alto-falante alterado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Descrição arquitetural do Zulip</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/zulip/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/zulip/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width:75%; display: flex; margin: 0 auto&#34;/&gt;
Zulip é uma ferramenta de chat em grupo open-source que combina a eficiência de um chat em tempo real com a produtividade de conversas em thread.
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Maurício Alves Valverde Carvalho.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211593&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.carvalho@ccc.ufcg.edu.br&#34;&gt;joao.carvalho@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/zulip/zulip&#34;&gt;https://github.com/zulip/zulip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/zulip/zulip&#34;&gt;Zulip&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;Zulip é um aplicativo de chat em grupo. O zulip combina o imediatismo de um chat em tempo real com a organização e produtividade de um modelo de threads baseado nos emails. Mais informações sobre o produto podem ser encontradas &lt;a href=&#34;https://zulip.com&#34;&gt;nest link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-zulip&#34;&gt;O zulip&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço de chat em tempo real em grupo para uma ampla gama de organizações e equipes. De empresas a projetos voluntários.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Um servidor pode hospedar múltiplos realms (organizações) Zulip, cada um no seu domínio. Cada realm é uma instância única com os seus próprios usuários, streams, customizações e etc.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de contexto, podemos ver que o Zulip consiste de uma aplicação backend, um banco de dados e aplicações cliente. Essas aplicações cliente fazem requisições por meio do protocolo HTTPS para a API do Zulip Server, que por sua vez se comunica com o banco de dados, atualizando mensagens, threads, canais, entre outros. Além disso, o Zulip fornece um módulo que implementa autenticação por meio de diversas aplicações de terceiros, como o Github, Google account e Facebook.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;clients&#34;&gt;Clients&lt;/h4&gt;
&lt;p&gt;Aplicações que rodam no lado do cliente, e são responsáveis por prover a interação do cliente com uma determinada instância de servidor Zulip por meio de requisições HTTPS e também via web socket para eventos. São fornecidas funcionalidades como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Listagem de canais&lt;/li&gt;
&lt;li&gt;Listagem de threads&lt;/li&gt;
&lt;li&gt;Listagem de usuários&lt;/li&gt;
&lt;li&gt;Painel de configuração do realm&lt;/li&gt;
&lt;li&gt;Caixa para composição de mensagem&lt;/li&gt;
&lt;li&gt;Funcionalidade de criação de canais/threads&lt;/li&gt;
&lt;li&gt;Espaço de leitura de mensagens&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;zulip-web&#34;&gt;Zulip Web&lt;/h5&gt;
&lt;p&gt;Principal aplicação cliente, roda no domínio específico da organização (ex: chat.zulip.org).&lt;/p&gt;
&lt;h5 id=&#34;zulip-terminal&#34;&gt;Zulip Terminal&lt;/h5&gt;
&lt;p&gt;Permite rodar uma versão simplificada do Zulip diretamente do terminal do usuário.&lt;/p&gt;
&lt;h5 id=&#34;zulip-mobile&#34;&gt;Zulip Mobile&lt;/h5&gt;
&lt;p&gt;Aplicação mobile escrita em React Native que permite utilização do Zulip nas plataformas Android e iOS.&lt;/p&gt;
&lt;h5 id=&#34;zulip-desktop&#34;&gt;Zulip Desktop&lt;/h5&gt;
&lt;p&gt;Aplicação escrita com o framework Electron que permite rodar o zulip diretamente na máquina, sem necessidade de utilizar o browser.&lt;/p&gt;
&lt;h4 id=&#34;zulip-server&#34;&gt;Zulip Server&lt;/h4&gt;
&lt;p&gt;Aplicação escrita em Python, utilizando o framework Django que implementa praticamente toda lógica de negócios do Zulip. Serve aplicações client com o conteúdo das mensagens/canais via requisições HTTPS e também atualiza o banco de dados via queries SQL.&lt;/p&gt;
&lt;h4 id=&#34;os-endpoints-são-divididos-nas-seguintes-entidades&#34;&gt;Os endpoints são divididos nas seguintes entidades:&lt;/h4&gt;
&lt;h5 id=&#34;messages&#34;&gt;Messages&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma mensagem. Mensagens podem ser enviadas, editadas, podem ter anexos, emojis customizados. Existem também endpoints para pegar o histórico de edição de uma mensagem.&lt;/p&gt;
&lt;h5 id=&#34;streams&#34;&gt;Streams&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma stream (canal). Um usuário pode se inscrever num canal, criar, deletar, criar tópicos.&lt;/p&gt;
&lt;h5 id=&#34;users&#34;&gt;Users&lt;/h5&gt;
&lt;p&gt;Entidade que representa um usuário&lt;/p&gt;
&lt;h5 id=&#34;server--organização&#34;&gt;Server &amp;amp; Organização&lt;/h5&gt;
&lt;p&gt;Entidade que representa uma organização que hospeda um servidor Zulip&lt;/p&gt;
&lt;h4 id=&#34;módulo-de-autenticação&#34;&gt;Módulo de autenticação&lt;/h4&gt;
&lt;p&gt;Módulo responsável por autenticar um usuário a aplicação. Além de prover sua própria implementação, ele também disponibiliza integração com diversas aplicações de terceiros para que seja possível configurar 3rd party authentication.&lt;/p&gt;
&lt;h4 id=&#34;banco-de-dados&#34;&gt;Banco de dados&lt;/h4&gt;
&lt;p&gt;Responsável por persistir os dados&lt;/p&gt;
&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;
&lt;p&gt;Nesta seção, focarei nos componentes do Zulip Server.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;nginx&#34;&gt;Nginx&lt;/h4&gt;
&lt;p&gt;Front-end do servidor. Recebe todo o tráfego da parte do cliente, repassando para o Tornado/Django e vice-versa. Ele lida com solicitações HTTP de acordo com as regras estabelecidas nos vários arquivos de configuração encontrados em zulip/puppet/zulip/files/nginx/.&lt;/p&gt;
&lt;h4 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h4&gt;
&lt;p&gt;PostgreSQL (também conhecido como Postgres) é o banco de dados que armazena todos os dados persistentes, ou seja, dados que devem viver além da sessão atual do usuário.&lt;/p&gt;
&lt;h4 id=&#34;django&#34;&gt;Django&lt;/h4&gt;
&lt;p&gt;É a principal aplicação server. Implementa toda a lógica de negócios do Zulip na parte do servidor, lidando com todas as rotas, exceto a de eventos.&lt;/p&gt;
&lt;h4 id=&#34;tornado&#34;&gt;Tornado&lt;/h4&gt;
&lt;p&gt;O Tornado é um servidor assíncrono e destina-se especificamente a manter abertas dezenas de milhares de conexões de longa duração - ou seja, rotas que mantêm uma conexão persistente de cada cliente em execução. Por este motivo, é responsável pela entrega do evento nova mensagem, mas não muito mais.&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui vamos focar na entidade mensagem. Embora enviar uma mensagem em um produto de bate-papo possa parecer simples, há muita complexidade necessária para fazer uma experiência de qualidade profissional.&lt;/p&gt;
&lt;h4 id=&#34;lista-de-mensagens---frontend&#34;&gt;Lista de mensagens - Frontend&lt;/h4&gt;
&lt;p&gt;Uma lista de mensagens é o nome dado para o conceito de feed de mensagens no front-end. Existem 3 principais estruturas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma &lt;em&gt;message_list_data&lt;/em&gt; tem apenas os dados de sequenciamento de quais IDs de mensagem vão em que ordem.&lt;/li&gt;
&lt;li&gt;Uma &lt;em&gt;message_list&lt;/em&gt; é construída em cima de message_list_data e contém, adicionalmente, os dados para uma lista de mensagens visíveis para o usuário.&lt;/li&gt;
&lt;li&gt;Uma &lt;em&gt;message_list_view&lt;/em&gt; é construída sobre message_list e contém adicionalmente detalhes de renderização como por exemplo uma janela de até 400 mensagens que está presente no DOM no momento, controles de posição de rolagem, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;implementação-backend&#34;&gt;Implementação backend&lt;/h4&gt;
&lt;p&gt;O fluxo de uso para enviar uma mensagem segue o seguinte fluxo no backend:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;event_queue: Envia emails e notificações mobiele para usuários que precisam receber notificação desta mensagem (ex: usúario marcado no corpo da mensagem)&lt;/li&gt;
&lt;li&gt;check_message: Verifica se o input é uma mensagem válida&lt;/li&gt;
&lt;li&gt;do_send_message: Rotina que de fato envia uma mensagem. Salva o objecto no banco de dados e envia um evento de Mensagem para o subsitema de eventos&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Realizei algumas contribuições no Zulip, segue a lista:&lt;/p&gt;
&lt;h2 id=&#34;contribuições-já-aceitas&#34;&gt;Contribuições já aceitas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15149&#34;&gt;stream_color.js: Fix color picker not saving custom color.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/14970&#34;&gt;compose.js: Fix compose box didn&amp;rsquo;t collapse.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13463&#34;&gt;stream settings: Fixing a bug where the stream-list in the stream settings would list all streams but wold show the &amp;lsquo;Subscribed&amp;rsquo; label enabled by resetting the control variable when setting up the page.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13178&#34;&gt;Settings: Change username to &lt;code&gt;bot email&lt;/code&gt; in bot settings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contribuições-em-aberto&#34;&gt;Contribuições em aberto&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/13459&#34;&gt;typeahead: Allows typeahead to work with &amp;ldquo;intersection&amp;rdquo; logic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/16061&#34;&gt;compose_area: Highlight excessive message length instead of cutting it off&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15160&#34;&gt;Allow search for messages that have reactions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zulip/zulip/pull/15088&#34;&gt;composebox_typeahead: Autocomplete for &amp;lsquo;#&amp;rsquo; should also suggest topics.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Leggo Painel</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/leggo/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/leggo/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Lucas Galvão Menezes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110464&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.menezes@ccc.ufcg.edu.br&#34;&gt;joao.menezes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/parlametria/leggo-painel&#34;&gt;https://github.com/parlametria/leggo-painel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----site-leggo-painel&#34;&gt;Descrição Arquitetural &amp;ndash; Site Leggo Painel&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/parlametria/leggo-painel&#34;&gt;Leggo Painel&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do Leggo. O foco aqui é a descrição da página específica de análise de atividade parlamentar, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-leggo&#34;&gt;Descrição Geral sobre o Leggo&lt;/h2&gt;
&lt;p&gt;O leggo é um projeto que tem como objetivo permitir o acompanhamento das atividades realizadas por cada deputado e senador no congresso, quais as suas principais áreas de atuação e sua relevância, a partir de ações feitas, dentro do congresso.&lt;/p&gt;
&lt;h2 id=&#34;a-página-leggo-painel&#34;&gt;A página Leggo Painel&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para permitir a fácil visualização das atividades de cada parlamentar no Congresso.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos mostrar a atividade dos parlamentares através de seus documentos apresentados na Câmara ou Senado. Fazemos isso com contagens e avaliações dos pesos de participação que o parlamentar teve em cada documento, sendo esses autorias, emendas, proposições, apensamentos ou requisições. Mostramos também ordenações dos mais ativos em documentos, em redes social e por peso político.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Leggo Painel recebe os dados de um outro serviço de coleta de dados do Congresso, o &lt;a href=&#34;https://github.com/analytics-ufcg/rcongresso&#34;&gt;r-congresso&lt;/a&gt;, e também direto da API do Congresso e pré-processa todos os dados antes de armazena-los. Nosso back-end prepara rotas e reorganiza os dados de acordo com o necessário para o uso.Com os dados adequados, produzimos as visualizações para que o usuário final consiga ler as informações passadas com naturalidade.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Temos quatro containers para abordar aqui.
O container que faz obtenção dos dados, a partir da API externa do Congresso e da biblioteca r-congresso, é implementado em R e faz um pré-processamento dos dados para serem armazenados. Esse container funciona via docker em máquina virtual do LSD;
O container de armazenamento de dados é implementado em postgres, implatado em um heroku próprio, e serve os dados ao back-end;
O container do back-end, também implantado em heroku separado, é implementado em Django e cria as rotas que vão servir o front-end da aplicação, expondo a API e modelando ainda mais os dados;
O container do front-end, que se encontra implantado no heroku próprio para ele, é implementado em Angular e faz requisições HTTP através de seus services para consumir as rotas da API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Temos dois componentes na parte dos dados, o fetcher e o transformador. O fetcher realiza a captura dos dados dos parlamentares da câmara e senado através das API&amp;rsquo;s externas e direciona para o transformador, onde os dados são analisados e pré-processados para seguirem para o armazenamento no banco de dados.
No back-end temos mais três componentes, models, views e controllers (segunido modelo MVC). O controller é o responsável por receber as requisições do front-end e se comunicar com o model apresentando a demanda. O model responde ao controller com os dados necessários para responder a demanda e o controller envia os dados para a view. Na view acontece a formatação dos dados para o modelo e tipo aguardado na resposta da requisição.
E no front-end, temos dois grandes componentes, os services e os components. Os components são de fato onde as funcionalidades do site são implementadas (filtragem de parlamentares, ordenações, criação de visualizações, normalizador de atividades, entre outras) e também o responsável por receber da interface da aplicação (site) as requisições. Já os services são a camada de contato entre front-end e back-end, ela que faz as requisições necessárias para a API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-componente.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O Leggo Painel começa a obtenção de seus dados a partir de API&amp;rsquo;s externas. O Congresso, por exemplo, disponibiliza todas as ações, oficializadas através de um documento, de um parlamentar. Capturamos essas informações, em XML, e tratamos, para que facilite a usabilidade mais adiante no sistema, criando ID&amp;rsquo;s únicos para os parlamentares, por exemplo. Com os dados armazenados já de maneira organizada e coesa, o sistema consegue utilizar esses para suas diversas requisições e funcionalidades. Por exemplo, exibir para cada parlamentar uma badge mostrando quantos documentos autorais ele possui.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;leggo-painel-info.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o OsmAnd</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/osmand/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/osmand/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do OsmAnd&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Débora Ferreira de Barros.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116211210&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:debora.barros@ccc.ufcg.edu.br&#34;&gt;debora.barros@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/osmandapp/OsmAnd&#34;&gt;https://github.com/osmandapp/OsmAnd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----mapas-e-rotas-de-navegação-do-osmand&#34;&gt;Descrição Arquitetural &amp;ndash; Mapas e rotas de navegação do OsmAnd&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/osmandapp/OsmAnd&#34;&gt;OsmAnd&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do OsmAnd. O foco é a descrição do serviço que fornece mapas e rotas de navegação do OsmAnd, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-osmand&#34;&gt;Descrição Geral sobre o Osmand&lt;/h2&gt;
&lt;p&gt;OsmAnd (OSM Automated Navigation Directions) é um projeto que tem como objetivo permitir a visualização de mapas bem como oferecer rotas de navegação para carros, bicicletas, transportes públicos e pedestres a partir do uso de dispositivos móveis de forma online e offline. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://osmand.net/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-mapas-de-navegação-do-osmand&#34;&gt;O Serviço de mapas de navegação do OsmAnd&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que oferece mapas e rotas de navegação disponíveis para diversos tipos de transporte e para pedestres.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Utilizando-se de um serviço de mapeamento é desejado criar rotas de navegação que guiem os usuários pelo mapa para o destino escolhido a partir de sua localização atual e disponibilizar mapas que funcionem de forma online e offline.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A partir de um dispositivo móvel o usuário do OsmAnd consegue visualizar mapas de lugares específicos e traçar rotas de navegação. O OsmAnd por sua vez se utiliza do mapeamento de lugares feitos pelo OpenStreetMap, que é um projeto colaborativo que cria mapas livres e editáveis do mundo com dados abertos, para fornecer a visualização de mapas e rotas.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;osmand-context.jpg&#34; style=&#34;width:25%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O meio de acesso ao OsmAnd é feito exclusivamente a partir de um aplicativo móvel que acessa todas as suas funcionalidades. O aplicativo móvel se utiliza de uma API que faz chamadas XML/HTTPS  para a API da aplicação que por sua vez faz uso dos dados dos mapas oferecidos pelo OpenStreetMap utilizando-se de chamadas de API XML/HTTPS. Todas as informações necessárias são armazenadas em um banco de dados SQLite.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;osmand-container.jpg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O Connection Service tem todos os métodos necessários para fazer a comunicação entre os os dados armazenados e a aplicação. Para isso ele faz chamadas ao Maps Component que por sua vez é o responsável por requisitar dados, estes que são obtidos no OpenStreetMap ou que são passadas pelo Data Component. O Data Component é responsável por manipular o armazenamento, exclusão e modificação de todos os dados no banco de dados da aplicação. Em sua maioria as informações manipuladas são do tipo XML e seguem protocolos do tipo HTTPS.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;osmand-componentes.jpg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Os principais dados manipulados, armazenados, distribuídos e coletados são arquivos do tipo GPX que usam um esquema XML para transferir dados GPS entre aplicações. Eles são usados para descrever rotas, trilhas ou pontos de passagem em mapas.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;GPX-maquina-de-estados.jpg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Adicionando diagramas: Enviado para análise&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/osmandapp/OsmAnd/pull/10019&#34;&gt;Link&lt;/a&gt; do Pull Request.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o TEAMMATES</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/teammates/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/teammates/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Jonas Gomes Aguiar.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210390&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:jonas.aguiar@ccc.ufcg.edu.br&#34;&gt;jonas.aguiar@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/TEAMMATES&#34;&gt;https://github.com/TEAMMATES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----teammates&#34;&gt;Descrição Arquitetural &amp;ndash; TEAMMATES&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/TEAMMATES&#34;&gt;TEAMMATES&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-teammates&#34;&gt;Descrição Geral sobre o TEAMMATES&lt;/h2&gt;
&lt;p&gt;O TEAMMATES é um projeto que tem como objetivo &amp;ldquo;gerenciar avaliações de alunos de um mesmo grupo e outros caminhos de feedback de seus alunos. É fornecido como um serviço baseado em nuvem para educadores e alunos.&amp;rdquo; Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://teammatesv4.appspot.com/web/front/home&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;teammates&#34;&gt;TEAMMATES&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para realização de avaliação e feedback entre pares, e professores.&lt;/p&gt;
&lt;p&gt;Buscamos ter meios flexiveis de feedback, usufruindo de controle de visibilidade para tal, gerando relatórios e estatisticas, com um controle de acesso refinado. Na geração de avaliação, buscamos disponibilizar diferentes tipos delas, podendo conjunto serem reutilizados. Os alunos poderam ter acesso as atividades e feedbacks via email sem necessitar acessar diretamente a plataforma.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.jpg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O sistema da aplicação do TEAMMATES é utilizado por usuários de dois tipos: Student e Instructor. Eles interagem com o sistema atráves de uma SPA, ou atráves do serviço de email do google. Tem como principais agentes relacionados os usuários, o próprio sistema TEAMMATES e o serviço de email.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;container.jpg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;O SPA é a porta principal de acesso com os usários, a comunicação do SPA com o container Backend é feita via http/ajax utilizando de json como modelo de dados. A comunicação entre o backend e o Google Cloud Storage é feita via http/dto. O Google App Engine serve é PaaS que hospeda e orquestra toda a infraestrutura de processos do TEAMMATES.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;componente.jpg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Backend se expande e divide-se em quatro componentes: UI Server, Common, Logic e Storage. O UI Server consiste em ser o componente que realiza o processamento das requisições, que podem chegar via GAE, retornará uma página da web como resposta utilizando AJAX. O componente Common é o responsavel por disponibilizar os utilitários comuns usados nos outros componentes. O Logic é o componente responsável pela lógica do negócio do TEAMMATES, gerencia os relacionamentos entre entidades, transações, higieniza os valores vindo da UI, oferece controle de acesso e é responsável pela conexão com o GAE e o serviço de email. O Storage é o componente que executa o CRUD dos dados, e é responsável or validar os dados, esconder a complexidade de armazenamento, ocultar a persistência dos objetos, mas ele não executa nenhuma criação ou exclusão em cascata.&lt;/p&gt;
&lt;p&gt;Single Page, UI Server e Logic representam um padrão Model-View-Controller.&lt;/p&gt;
&lt;p&gt;O UI Server retorna uma WebPage ao usuario atraves de WebPageServelet. O Logic utiliza os seguintes serviços para respostas de requisições: JavamailService, SendgridService, Service, além do GAE Task Queue API. O Common possui três classes internas: util, exceptions e datatransfer. O Storage possui sua API padrão em CRUD HTTP, além da classe entity que representa entidades persistentes, e a classe search usada para lidar com pesquisa e indexação.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;p&gt;Em breve.&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;estado.jpg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;O caminho de uma requisição vinda do GAE até ser armazenada no Google Cloud Storage.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Não foi enviado PR ao projeto.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o Youtube-dl</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/youtube-dl/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/youtube-dl/</guid>
       <description>&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thaynnara Raiany Uchôa Gonçalves.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115210050&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thaynnara.goncalves@ccc.ufcg.edu.br&#34;&gt;thaynnara.goncalves@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ytdl-org/youtube-dl&#34;&gt;https://github.com/ytdl-org/youtube-dl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-downloads-de-vídeos&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de downloads de vídeos&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido para a disciplina de Arquitetura de Software da UFCG, e tem como objetivo descrever parte da arquitetura do projeto &lt;a href=&#34;https://github.com/ytdl-org/youtube-dl&#34;&gt;Youtube-dl&lt;/a&gt;, usando como base, principalmente, o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-youtube-dl&#34;&gt;Descrição Geral sobre o Youtube-dl&lt;/h2&gt;
&lt;p&gt;O youtube-dl é um projeto open-source que permite ao usuário, via comandos do terminal, fazer o download de vídeos, a partir da url do mesmo, de alguma plataforma na internet. Sendo, dentre essas, com foco no Youtube.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema é instalado na máquina do usuário, logo, este é executado por linha de comando, no terminal. Sendo assim, o usuário chama a aplicação, passando a url do vídeo a ser baixado. Logo mais, a aplicação busca o vídeo na internet, a partir da url, e o salva do disco do usuário.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagram-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;h4 id=&#34;youtube-dl-api&#34;&gt;Youtube-dl API&lt;/h4&gt;
&lt;p&gt;O sistema é instalado na máquina do usuário, no diretório $(dirname)/bin/youtube-dl, logo o mesmo é executado na própria máquina do usuário. Neste contexto, a aplicação é executado por linha de comando,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ youtube-dl &amp;lt;options&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Onde o comando &amp;lsquo;youtube-dl&amp;rsquo; está configurado para executar, com o python instalado na maquina do usuário, a aplicação salva em /bin/youtube-dl.&lt;/p&gt;
&lt;p&gt;Sendo assim, o usuário chama a aplicação com o comando youtube-dl, passando a url do vídeo a ser baixado e opções para o dowload, se desejar ou se o site onde o video está hospedado, requerir. Logo mais, a aplicação busca o vídeo via batch files e batch url, usando o protocolo adequado a cada requisição, e por fim o salva no disco do usuário, no diretório onde foi feita a chamada a aplicação.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container-diagram.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo está o diagrama de componentes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;options&#34;&gt;Options&lt;/h4&gt;
&lt;p&gt;O options é o módulo responsável por fazer a validação da entrada dada pelo usuário, mas especificamente quanto a veracidade da url e o mapeamento dos parâmetros opcionais.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tecnologias
&lt;ul&gt;
&lt;li&gt;Este módulo faz uso do otparse para o recebimento das entradas.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;extractor&#34;&gt;Extractor&lt;/h4&gt;
&lt;p&gt;Este módulo é composto por varios InfoExtractors, cada um responsável por extrair a informação necessária da url por domínio específico. Ou seja, existe um InfoExtractor para cada domíminio suportado pela aplicação, por exemplo o Youtube, que tem seu pŕoprio InfoExtractor.&lt;/p&gt;
&lt;p&gt;Nesse contexto, o Extractor, dada uma url, pega o primerio InfoExtractor capaz de lidar com a mesma e extrai as informações necessárias e faz o mapeamento com as opções passadas, na chamada da aplicação, se for o caso.&lt;/p&gt;
&lt;h4 id=&#34;youtube-dl&#34;&gt;Youtube-dl&lt;/h4&gt;
&lt;p&gt;Aqui é feito o gerenciamente do fluxo da informação. Neste módulo a informação é recebida, depois dada ao Extractor, que retorna todas as informações requeridas e no formato ideal. Logo mais, a informação extraida é dada ao Downloader.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tecnologias
&lt;ul&gt;
&lt;li&gt;Aqui é feito o uso de Cache paras as urls&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;downloader&#34;&gt;Downloader&lt;/h4&gt;
&lt;p&gt;Este módulo é responsavel por fazer o download do vídeo e o salva-lo do disco do usuário. Sendo assim, aqui existem vários Files Downloader, os quais cada um tem como função baixar os dados do vídeo de acordo com diferentes protocolos. Logo, em Downloader é encontrado o File Downloader para aquele vídeo a partir do protocolo que deve ser usado para baixar o mesmo.&lt;/p&gt;
&lt;p&gt;Por exemplo, ao se deparar com um url do Youtube, é escolhido o File Downloader HTTP, pois os downloads de videos pelo Youtube funciona a partir do protocolo http.&lt;/p&gt;
&lt;p&gt;Por fim, os dados, que chegam em formato JSON, ao final do Download, sofrem um pós processamento, por parte do PostProcessor, para então ser salvo no computador do usuário.&lt;/p&gt;
&lt;h4 id=&#34;postprocessor&#34;&gt;PostProcessor&lt;/h4&gt;
&lt;p&gt;Responsável por processar os dados, em formato de JSON, baixados do vídeo, os reconstruindo novamente para o formato original&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;A url é primeiramente passada pelo usuário, que primeiramente é validada, em seguida é destinada a um InfoExtractor responsável por aquele domínio, o qual ira extrair as informações adequadas da url, estas então são dadas a um File Downloader, adequada para as mesmas, que irá usa-la para fazer o download do vídeo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;infromation_view.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural do TypeORM</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/typeorm/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/typeorm/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Lucas Henrique de Lima e Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115110163&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:lucas.silva@ccc.ufcg.edu.br&#34;&gt;lucas.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/typeorm/typeorm&#34;&gt;https://github.com/typeorm/typeorm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----typeorm&#34;&gt;Descrição Arquitetural &amp;ndash; TypeORM&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto TypeORM. Essa descrição foi baseada principalmente no modelo C4.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do TypeORM, uma biblioteca para projetos em Javascript e Typescript. O foco aqui é a descrição do funcionamento básico da biblioteca através do padrão Active Record, como ela se comunica com os vários tipos de banco de dados e como o programador pode utilizá-la.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-typeorm&#34;&gt;Descrição Geral sobre o TypeORM&lt;/h2&gt;
&lt;p&gt;TypeORM é uma ferramenta de mapeamento objeto relacional disponível como biblioteca para projetos em Javascript e Typescript. Ela oferece uma interface de programação para gerenciar a persistência em bancos de dados. Esse tipo de ferramenta diminui ou elimina a necessidade de utilizar diretamente comandos SQL, pois é criada uma abstração na própria linguagem para o qual foi construído.&lt;/p&gt;
&lt;p&gt;Através deste documento quero descrever a arquitetura da ferramenta e como ela se integra com os bancos de dados e à linguagem Javascript e o superset Typescript. Visto que a ferramenta oferece dois padrões de ORM (Data Mapper e Active Record), estarei utilizando o Active Record como foco. A diferença entre eles pode ser entendida através &lt;a href=&#34;https://medium.com/@matheusflauzino/entenda-orm-active-record-e-data-mapper-9be60da0e799&#34;&gt;deste pequeno post&lt;/a&gt;. Na prática, em TypeORM, o Active Record usa o Data Mapper, expondo os métodos disponíveis (insert, update, delete, count, etc.) diretamente na classe que herda de &lt;code&gt;BaseEntity&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-funcionamento-do-typeorm&#34;&gt;O funcionamento do TypeORM&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Expor uma interface para a manipulação de tabelas em bancos de dados de forma mais fácil e intuitiva, utilizando-se do poder da linguagem javascript e facilitando a construção de sistemas.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;O objetivo do TypeORM é sempre suportar as últimas funcionalidades de Javascript e prover funcionalidades adicionais para auxiliar no desenvolvimento de qualquer aplicação que usa banco de dados, desde pequenas aplicações com poucas tabelas até aplicações em larga escala com muitos bancos de dados. Além disso, possibilitar a escrita de código de alta qualidade, acoplamento reduzido, com graus elevados de escalabilidade e manutenabilidade de forma mais produtiva também são objetivos da ferramenta.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;É fato que a maior parte das aplicações desenvolvidas atualmente se comunicam com bancos de dados. Por muito tempo utilizou-se e até hoje utiliza-se programação direta ou linguagens de consulta de banco de dados para realizar ações simples em um banco de dados, como criar tabelas, inserir, atualizar, deletar valores e executar scripts. No entanto, muitas vezes a camada criada em um software para que ele se comunique com o banco de dados pode ser pouco intuitiva e de difícil manutenção, de acordo com a proficiência da equipe de desenvolvimento as linguagens que manipulam os bancos de dados. Em outros casos, a equipe de desenvolvimento procura organização e boa qualidade de código, sem misturar queries e scripts de banco de dados com o código da aplicação.&lt;/p&gt;
&lt;p&gt;Para mitigar problemas como estes, surgiram as ferramentas chamadas ORM - Mapeamento objeto-relacional (Object-relational mapping em inglês). Hibernate, Doctrine and Entity Framework são exemplos amplamente utilizados. Com ORMs, o programador não precisa se preocupar com os comandos em linguagens de banco de dados, pois basta usar uma interface de programação simples que faz todo o trabalho de persistência.&lt;/p&gt;
&lt;p&gt;Javascript e Typescript são altamente poderosos no ramo de desenvolvimento de aplicações, e tomando proveito disso, o TypeORM surgiu. Além de tornar a manipulação e manutenção de banco de dados mais fácil e intuitiva, TypeORM ainda oferece diversas funcionalidades que exploram a fundo o poder dessas linguagens.&lt;/p&gt;
&lt;p&gt;O TypeORM funciona em diversos ambientes e se conecta com diversos tipos de banco de dados. Uma aplicação que utiliza o TypeORM pode ser escrita em NodeJS, Browser, Cordova, PhoneGap, Ionic, React Native, NativeScript, Expo e Electron, e pode acessar bancos de dados MySQL, MariaDB, PostgreSQL, CockroachDB, SQLite, Microsoft SQL Server, sql.js e Oracle. Também há suporte experimental para MongoDB.&lt;/p&gt;
&lt;p&gt;A arquitetura usada na biblioteca é simples e bem estruturada. O diagrama abaixo mostra como a biblioteca funciona integrada aos bancos de dados e às aplicações que fazem uso deles.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-contexto.png&#34; style=&#34;width:50%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de contexto do TypeORM
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Por se tratar de uma biblioteca, o TypeORM é integrado à aplicação que o utiliza, seja no cliente e/ou no servidor. Além disso, ele oferece uma interface de linha de comando, para que o programador possa executar ações de nível de desenvolvimento, como criação de migrações à medida que a aplicação evolui. O banco de dados a ser acessado pode estar totalmente desacoplado da máquina na qual a aplicação roda, pois isso já é previsto pelos protocolos de conexão dos bancos de dados.&lt;/p&gt;
&lt;p&gt;A figura abaixo ilustra um exemplo de implantação de um sistema que utiliza TypeORM.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-containers-implantacao.png&#34; style=&#34;width:80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 2 - Exemplo de implantação de um sistema utilizando TypeORM
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para se comunicar com o banco de dados, o TypeORM utiliza vários componentes que são interligados e se completam. No momento em que o programador escreve código para consulta ou atualização de valores, o código é transformado em queries de acordo com o tipo de banco de dados que está sendo usado, isso porque cada banco de dados tem sua própria linguagem.&lt;/p&gt;
&lt;p&gt;Para manipular dados, é possível utilizar repositórios (utilizando o padrão Data Mapper) ou Active Records.&lt;/p&gt;
&lt;p&gt;Considere o seguinte trecho de código e uma entidade de nome Foo:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let myFoo = Foo.find({ where: { name: &#39;Bar&#39; }})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A figura abaixo mostra como a aplicação se conectará ao banco de dados e como a linha de código acima será transformada em uma consulta no banco de dados PostgreSQL.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-componentes.png&#34; style=&#34;width: 80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 3 - Diagrama de componentes do TypeORM 
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Através da CLI do TypeORM, é possível gerar migrações. Migrações são necessárias quando a aplicação já está em produção, mas o modelo de dados é modificado ou precisa de alterações não triviais.&lt;/p&gt;
&lt;p&gt;A CLI é capaz de analisar a versão atual do modelo de dados e compará-la com uma versão anterior em busca de mudanças. Caso sejam encontradas mudanças, um script de migração é criado e fica disponível para o TypeORM para ser aplicado manualmente pelo programador ou automaticamente na próxima vez que a aplicação for iniciada.&lt;/p&gt;
&lt;p&gt;A figura abaixo ilustra o diagrama de estados de uma migração.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;typeorm-informacao.png&#34; style=&#34;width: 80%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 4 - Máquina de estados de uma migração em TypeORM
    &lt;/span&gt;
&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Documento referente à arquitetura do Frontend e Deploy do projeto Eureca</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca__front_deploy/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca__front_deploy/</guid>
       <description>&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Hércules Rodrigues Anselmo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210908&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:hercules.anselmo@ccc.ufcg.edu.br&#34;&gt;hercules.anselmo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-frontend&#34;&gt;Eureca Frontend&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy&#34;&gt;Eureca Deploy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-eureca&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço Eureca&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/computacao-ufcg&#34;&gt;Eureca&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar, não será descrita toda a arquitetura do Eureca. O foco aqui é a descrição do serviço Frontend e Deploy.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-eureca-frontend-e-eureca-deploy&#34;&gt;Descrição Geral sobre o Eureca-Frontend e Eureca-Deploy&lt;/h2&gt;
&lt;p&gt;O Eureca-Frontend é um projeto que tem como objetivo separar a parte visual do projeto Eureca. Atualmente está sendo possível visualizar apenas um dos sub-módulos do Eureca, que é o sub-módulo Estatísticas.&lt;/p&gt;
&lt;p&gt;O Eureca-Deploy é um projeto com principal objetivo efetuar o Deploy do Eureca, além de fazer todo o processo de configuração, escalabilidade e scripts para o Banco de Dados.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-eureca&#34;&gt;O Serviço Eureca&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Servir uma plataforma administradora para coordenadores de cursos da UFCG. A princípio está sendo desenvolvida para o curso de Ciências da Computação - UFCG. Esta plataforma tem como principal objetivo aumentar a eficiêcia e a facilidade para o coordenador com respeito aos discentes do curso. Ela contará com diversos serviços que auxiliará o coordenador na sua administração, sendo estes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monitoramento&lt;/li&gt;
&lt;li&gt;Estatísticas&lt;/li&gt;
&lt;li&gt;Comunicação&lt;/li&gt;
&lt;li&gt;Serviços&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos implantar os dados obtidos através do eureca-coleta-dados em um banco de dados para que este possa ser acessado por um outro projeto Eureca (eureca-backend), que servirá uma API para ser consumida pelo eureca-frontend, sendo este, responsável por mostrar visualmente todos os serviços disponíveis na plataforma.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema Eureca-frontend busca as informações na API através de métodos HTTP, a API logo faz consultas ao Banco de Dados e retorna uma viewer para o Coordenador.
No sistema Eureca-deploy, após receber os dados da coleta de dados, faz o procedimento de popular o Banco de Dados, mas também faz o deploy da aplicação através de containers Dockers, ele busca estas imagens no Docker Hub para levantar os respectivos containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;É importante frizar que no momento da escrita deste artigo as relações das entidades são as que estão na imagem, podendo assim, serem alteradas.&lt;/p&gt;
&lt;p&gt;No sistema Eureca-Frontend temos o Single Page Aplication, container responsável por prover uma interface para o usuário, a partir deste é possível acessar o container de Módulos, sendo este responsável por oferecer os serviços de gráficos, geração de arquivos csv e outras informação sobre os discentes, após a comunicação com o container FetcherAPI: Responsável por se comunicar com a API através da biblioteca Axios nos EndPoints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estatisticas/ativos&lt;/li&gt;
&lt;li&gt;estatisticas/ativos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/ativos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/ativos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/egressos&lt;/li&gt;
&lt;li&gt;estatisticas/egressos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/egressos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/egressos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos/csv&lt;/li&gt;
&lt;li&gt;estatisticas/evadidos/csv?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;No sistema Eureca-Deploy temos o container &amp;ldquo;Refinador&amp;rdquo;, responsável por tratar os dados recebidos do Eureca - Coleta de dados. Esses novos dados são repassados para o &amp;ldquo;Construtor do Banco de Dados&amp;rdquo; que irá implantar estes no Banco de Dados.
O Container Scripts Deploy é responsável por fazer o deploy dos containers do  Eureca-frontend, Eureca-backend e Banco de Dados, após acessar as imagens do Docker Hub.&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;Detalhes de implantação do Eureca-Frontend:&lt;/p&gt;
&lt;p&gt;Atualmente está implantado em uma máquina virtual no LSD UFCG através de um container docker na porta 3000. É possível acessá-lo pelo link: &lt;a href=&#34;http://150.165.15.71:3000&#34;&gt;http://150.165.15.71:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;O sistema Eureca-Deploy não tem implantação, pois como se trata de scrips para efetuar o deploy de terceiros, ele é executado apenas uma única vez. Após sua execução, o Banco de Dados postgreSQL fica hospedado, também, na mesma máquina do Eureca-Frontend, mas na porta 5432.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Sobre os componentes do container Módulos:&lt;/p&gt;
&lt;p&gt;O componente Home é responsável por renderizar a Home Page, que a partir deste é possível navegar entre os outros componentes oferecidos pelo Sistema. O componente Estatística, em específico, utiliza o componente gráficos para fazer a renderização dos dados em Gráficos específicos.&lt;/p&gt;
&lt;p&gt;Sobre os componentes do container Contrutor do Banco de Dados:&lt;/p&gt;
&lt;p&gt;O componente PopulateDB é responsável por utilizar os dados refinados e passá-los para os componentes Migrations e Seeders, responssáveis por popular o banco de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama a seguir mostra o estado da informação da tela ativos quando o coordenador tentar acessá-la.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;estados.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Como faço parte do projeto Eureca, constantemente estou efetuando PR&amp;rsquo;s para contribuir com o projeto.&lt;/p&gt;
&lt;p&gt;-&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy/pull/23&#34;&gt;Contribuição no projeto Eureca-Deploy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-frontend/pull/47&#34;&gt;Contribuição mais recente no Eureca-Frontend&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Erxes - Documento arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/erxes/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/erxes/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este artefato foi elaborado por Felipe de Amorim Ferreira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118111800&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:felipe.amorim.ferreira@ccc.ufcg.edu.br&#34;&gt;felipe.amorim.ferreira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/erxes/erxes-api&#34;&gt;https://github.com/erxes/erxes-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----erxes-api&#34;&gt;Descrição Arquitetural &amp;ndash; Erxes api&lt;/h1&gt;
&lt;p&gt;Esta descrição arquitetural é sobre a principal funcionalidade do projeto &lt;strong&gt;Erxes&lt;/strong&gt;, repositório disponível clicando &lt;strong&gt;&lt;a href=&#34;https://github.com/erxes/erxes-api&#34;&gt;aqui&lt;/a&gt;&lt;/strong&gt; e foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para deixar claro, neste documento não serão abordados todos os aspectos arquiteturais do projeto. Será destacado a descrição de um serviço específico de integração com plataformas de terceiros, que é a funcionalidade principal do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-erxes&#34;&gt;Descrição geral sobre o Erxes&lt;/h2&gt;
&lt;p&gt;O Erxes é um projeto open source e uma plataforma de crescimento em marketing. Criada para atrair clientes mais engajados, ela consegue fazer integrações de forma ilimitada com várias plataformas de atendimento ao cliente dentre elas estão plataformas de mídia, serviços de messeger, email e SMS por várias marcas.&lt;/p&gt;
&lt;h2 id=&#34;serviço-de-integração-erxes&#34;&gt;Serviço de integração Erxes&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que consegue integrar qualquer plataforma de interação entre cliente e empresa, tendo como objetivo uma relação mais próxima com o cliente e promover campanhas de marketing de forma mais impactante.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos obter o máximo de informações sobre os leads que interagem com o sistema e buscar interligar o máximo de canais de comunicação disponibilizados por eles. Com todas essas informações armazenadas conseguimos fazer testes A/B, assim, possibilitando a criação de materiais para campanhas de marketing, que são personalizadas para cada tipo de cliente. Além disso, criar triggers que são acionados quando os clientes interagem com os scripts gerados, dessa forma, permitindo com que a empresa utilizadora do &lt;strong&gt;Erxes&lt;/strong&gt; entre em contato pelos vários meios de comunicação disponibilizados.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto do Erxes API abrange os seguintes sistemas e utilizadores:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes customer&lt;/strong&gt;: Esse é o cliente que está utilizando os serviços do Erxes, ele é responsável por registrar sua marca, interagir com os clientes das marcas através das diversas plataformas e gerar os scripts de triggers para serem configurados nos sites das marcas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Company customer&lt;/strong&gt;: Esse é o cliente de uma marca registrada no Erxes, é ele que interage com a página de vendas ou serviços das marcas, consequentemente ativando vários triggers que coletam seus dados e agendam eventos(Como o envio de um email) para o sistema do Erxes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes Frontend&lt;/strong&gt;: Esse é o sistema onde o usuário interage com o Erxes, ou seja, a user interface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes API&lt;/strong&gt;: É aqui que vai ficar a maior parte da lógica de negócios, o Erxes API vai manipular as integrações de ferramentas para marketing, vai conseguir fazer um &amp;ldquo;merge&amp;rdquo; dos dados dos usuarios com várias contas, gerar scripts, disponibilizar dados para o Erxes customer e unificar a comunicação entre a marca e o Company customer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Erxes customer&amp;rsquo;s website&lt;/strong&gt;: Essa é a página de vendas ou de serviços da marca, aqui vão ser configurados os scripts que quando acionados geram dados do usuario ou agendam eventos que são mandados para o Erxes API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Means of communication API&lt;/strong&gt;: Essas são as APIs que irão fornecer e receber as mensagens de chat, email ou SMS e que serão unificadas para os Erxes customers interagirem com os Company customers das marcas em um único local.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Os containers do Erxes API são divididos em três serviços e dois banco de dados, apesar de estarem no mesmo repositório eles são independentes:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: Aqui é onde todas as requisições da comunicação entre client e Erxes API passam, dentro desse container estão implementadas algumas features que garantem a confiabilidade do sistema, mesmo estando instável ou caindo. Dentre várias features temos: Manipulação de arquivos XLSX para envio e recebimento, serviços cron job, implementação de um histórico de ações do sistema e filas de solução de requisições.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Email Verifier&lt;/strong&gt;: Este container tem a função de validação de grande parte dos dados fornecidos pelos Company customers, o email verifier vai verificar se os dados são válidos com ajuda de serviços externos e internos, além disso, persistirá esses dados caso forem válidos. Toda essa validação evita dados falsos e/ou duplicados, dessa forma, o banco de dados não é tão requisitado, tanto em memória quanto nas queries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Engage Email Sender&lt;/strong&gt;: O Engage Email Sender já mostra sua função pelo nome, ele é reponsável pelo envio dos emails e também lida com o agendamento do envio.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para ilustrar o documento de componentes foi expandido o container da API do tópico passado.
Também foram escolhidos os componentes mais relevantes do container, então somente alguns containers foram ilustrados.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General API&lt;/strong&gt;: Componente responsável por manipular e encaminhar as requisições para os componentes responsáveis por resolvê-las.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;File Handler&lt;/strong&gt;: Tem como papel receber arquivos tanto por stream como diretamente, também é responsável por analisar os arquivos, se estão no formato correto ou se precisam de um &amp;ldquo;parse&amp;rdquo;, caso precise de um parse, ele realiza o parse e persiste os dados no elasticsearch.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Commands&lt;/strong&gt;: Responsável por manipular funções internas do sistema, tal como carregar dados do sistema e reiniciar serviços que não foram corretamente iniciados.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Auth&lt;/strong&gt;: Responsável por validar as ações do usuário dentro do sistema, ele verifica se os dados de autenticação fornecidos usuário permitem ele realizar determinada ação dentro do sistema.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message Broker&lt;/strong&gt;: Componente responsável pela tradução de mensagens entre protocolos formais de mensagens. Isto permite que serviços interdependentes &amp;ldquo;falem&amp;rdquo; uns com os outros diretamente, mesmo que tenham sido escritos em línguas diferentes ou implementados em plataformas diferentes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cron jobs&lt;/strong&gt;: Responsável por executar uma tarefa recorrente repetidamente em algum tempo mais tarde. A ação de dar um comando para agendar uma tarefa para um tempo específico e de forma repetida é responsabilidade deste componente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;As trocas de mensagens, em companhia dos dados gerados pela interação dos clientes das marcas, exercem um papel primordial para o funcionamento da aplicação. Com eles nós conseguimos gerar relatórios dos comportamentos dos usuários e promover várias campanhas de marketing mais acertivas. Abaixo ilustro os estados de uma email enviado pelo sistema.&lt;/p&gt;
&lt;p&gt;Descrição da sequência de estados:&lt;/p&gt;
&lt;p&gt;Primeiro o email começa a ser produzido pelo usuário, em seguida ele pode ser enviado ou salvo. Caso o email seja enviado, ele pode ser aberto, ir para span, ser cancelado, ou devolvido. Ao cancelar o envio ele é automaticamente salvo, e ao ser salvo ele pode ser deletado. Quando o email é devolvido ele pode ser reenviado ou editado.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;states.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>OpenFaaS Of-Watchdog</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/ofwatchdog/</link>
       <pubDate>Tue, 13 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/ofwatchdog/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por David Ferreira Quaresma.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210041&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:david.quaresma@ccc.ufcg.edu.br&#34;&gt;david.quaresma@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/openfaas/of-watchdog&#34;&gt;https://github.com/openfaas/of-watchdog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----proxy-reverso-do-openfaas-of-watchdog&#34;&gt;Descrição Arquitetural &amp;ndash; Proxy Reverso do OpenFaaS (Of-Watchdog)&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/openfaas&#34;&gt;OpenFaaS&lt;/a&gt;, mais precisamente o componente chamado &lt;a href=&#34;https://github.com/openfaas/of-watchdog&#34;&gt;Of-Watchdog&lt;/a&gt; - uma versão alternativa do watchdog clássico do OpenFaaS. Essa descrição foi feita com baseada no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Vale salientar que neste documento não será descrito toda a arquitetura do OpenFaaS, como já mecionado. Aqui iremos descrever o proxy reverso utilizado pela plataforma, componente este de função essencial para a comunicação com as funções conteinerizadas e extração de métricas.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-opefaas&#34;&gt;Descrição Geral sobre o OpeFaaS&lt;/h2&gt;
&lt;p&gt;O OpenFaaS é um framework de provisionamento de funções como serviço que possibilita a rápida implementação e deploy de aplicações sob o paradigma de computação em Funções como Serviço, também se responsabilizando pela escalabilidade da aplicação (pré configurada pelo usuário). Para mais detalhes sobre esta plataforma, visite &lt;a href=&#34;https://www.openfaas.com/&#34;&gt;este link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;of-watchdog---proxy-reverso-do-openfaas&#34;&gt;Of-Watchdog - Proxy reverso do OpenFaaS&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um servidor HTTP que atua como um proxy reverso para a execução de funções e microserviços, podendo ser usado de forma independente ou como um ponto de entrada para conteineres com o OpenFaaS.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Possibilitar uma versão do watchdog que dê suporte para proxy HTTP e STDIO, o que habilita o reuso de memória (em contraste ao clássico que precisa iniciar um novo conteiner para cada invocação de função) e um atendimento de requisições mais eficiente (devido a não necessidade de iniciar novas instâncias para a atender requisições).&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;No OpenFaaS, cada função é encapsulada em um contêiner, e dentro dele há o handler da função e o proxy reverso. Neste contexto, o Of-Watchdog (um proxy reverso, como já mencionado) executa dentro do contêiner e junto à função. Além do próprio handler da função, o Of-Watchdog também comunica-se com o FaaS Provider (responsável por encaminhar requisições às réplicas de funções)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Uma vez que o OpenFaaS trata-se de uma plataforma de funções como serviço, é natural que seus componentes esteja decomposto à nível de contêineres. Nesta seção iremos apresentar os componentes mais próximos do of-watchdog, que são eles o próprio contêiner em que o of-watchdog executa e o contêiner em que executa o outro processo que se comunica com o of-watchdog, o Faas Provider.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;A principal informação que trafega através do Of-Watchdog são as requisições enviadas às funções em que o Of-Watchdog está proxeando. Neste caso, a requisição advinda do FaaS Provider (que a recebeu do OpenFaaS Gateway) é interceptada pelo Of-Watchdog e encaminhada para o Handler da função.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-informacao.png&#34; alt=&#34;fig7&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o projeto Farol Covid</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/farolcovid/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/farolcovid/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Natan Macena Ribeiro.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 114111371&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:natan.ribeiro@ccc.ufcg.edu.br&#34;&gt;natan.ribeiro@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;https://github.com/ImpulsoGov/farolcovid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----farolcovid&#34;&gt;Descrição Arquitetural &amp;ndash; FarolCovid&lt;/h1&gt;
&lt;p&gt;A fonte utilizada para produção deste documento foi o projeto &lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;Farol Covid&lt;/a&gt;. A partir desse projeto (&lt;a href=&#34;https://github.com/ImpulsoGov/farolcovid&#34;&gt;Farol Covid&lt;/a&gt;), este documento propõe uma descrição arquitetural baseada essencialmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;, pelo qual permite que diferentes stakeholders possam compreender o funcionamento da ferramenta a partir de algumas visões arquiteturais.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-farol-covid&#34;&gt;Descrição Geral sobre o Farol Covid&lt;/h2&gt;
&lt;p&gt;O Farol Covid é uma ferramenta de monitoramento do risco de colapso no sistema de saúde em municípios brasileiros com a COVID-19. Além de apresentar a situação atual da COVID-19 nos estados ou municípios, esse projeto permite que governantes consigam definir políticas de contingenciamento da doença, baseando-se em indicadores bem definidos que inclusive, permitem a realização de simulações que projetam possíveis cenários para a região de interesse. Para mais detalhes sobre o projeto abordado, acesse &lt;a href=&#34;https://farolcovid.coronacidades.org/&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O objetivo do projeto é disponibilizar um serviço para coleta e visualização de dados relacionados a COVID-19, apresentando análises e indicadores da situação da doença para uma determinada região.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A idéia é viabilizar que gestores públicos (estaduais e municipais), possuam uma ferramenta que mostra a situação atual da COVID-19 e indica possíveis cenários baseados no comportamento da doença na região de seu mandato.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A partir da introdução, podemos expecificar o sistema do FarolCovid, como um serviço Web que apresenta informações contidas nos sistemas de base de dados brasileiros &lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; e &lt;a href=&#34;https://datasus.saude.gov.br/&#34;&gt;DataSUS&lt;/a&gt;, considerando os interesses especificos do usuário. De maneira geral, o sistema funciona como um facilitador, entre o usuário e as bases de dados anteriormente citadas, em que simplifica a obtenção de determinada informação por meio de refinamento e operações de analises sobre tais bases de dados.&lt;/p&gt;
&lt;p&gt;Assim, podemos representar a aplicação como uma entidade intermediária (&amp;ldquo;FarolCovid&amp;rdquo;) entre as entidades &amp;ldquo;Usuário&amp;rdquo; e &amp;ldquo;Brasil.IO&amp;rdquo; juntamente com &amp;ldquo;DataSUS&amp;rdquo;, como é ilustrado no diagrama de contexto abaixo:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;01_diagrama_de_contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como containers do FarolCovid, podemos elencar 3 entidades: Web Page, View e API.&lt;/p&gt;
&lt;p&gt;O primeiro deles, &lt;strong&gt;Web Page&lt;/strong&gt;, é responsável por pela representação gráfica do sistema, ou seja, todo o HTML que o browser irá interpretar e renderizar para o usuário final.&lt;/p&gt;
&lt;p&gt;O elemento &lt;strong&gt;View&lt;/strong&gt;, trata-se de toda lógica do negócio, realizando todas as operações com os dados (refinamento, filtragem e análise) coletados das bases de dados (&lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; e &lt;a href=&#34;https://datasus.saude.gov.br/&#34;&gt;DataSUS&lt;/a&gt;) atravéz de uma &lt;a href=&#34;http://datasource.coronacidades.org/br/&#34;&gt;API&lt;/a&gt; desenvolvida para isso. Esse contêiner utilizar Python como linguagem e é acompanhado pelos frameworks Flask e Streamlit. O sistema é executado numa nuvem Heroku, utilizando uma máquina virtual com o sistema operacional Ubuntu 18.04 LTS.&lt;/p&gt;
&lt;p&gt;O container &lt;strong&gt;API&lt;/strong&gt;, é um conjunto de rotinas e padrões de programação para acesso das bases de dados do FarolCovid. Foi construido para o sistema que estamos apresentando e o projeto (que pode ser acessado &lt;a href=&#34;https://github.com/ImpulsoGov/coronacidades-datasource&#34;&gt;neste link&lt;/a&gt;) possui o nome de &lt;em&gt;Coronacidades API&lt;/em&gt;. Assim como o FarolCovid, o &lt;a href=&#34;https://github.com/ImpulsoGov/coronacidades-datasource&#34;&gt;Coronacidades API&lt;/a&gt; é servido por uma maquina virtual Heroku e foi desenvolvido em Python juntamente com o framework Django, a partir do padrão de projeto MTV (Model, Template, View).&lt;/p&gt;
&lt;p&gt;Veja principais endpoints utilizados pelo FarolCovid:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;br/cities/cases/full: Fornece histórico completo de dados do &lt;a href=&#34;https://brasil.io/home/&#34;&gt;Brasil.IO&lt;/a&gt; com a taxa e estimativa dos casos ativos&lt;/li&gt;
&lt;li&gt;br/cities/simulacovid/main: Dados filtrados para servir a aplicação SimulaCovid do FarolCovid&lt;/li&gt;
&lt;li&gt;br/cities/farolcovid/main: Dados filtrados e indicadores de cidades&lt;/li&gt;
&lt;li&gt;br/states/farolcovid/main: Dados filtrados e indicadores de estados&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*Para os demais endpoints acesse &lt;a href=&#34;http://datasource.coronacidades.org/br/&#34;&gt;API.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Abaixo encontra-se o diagrama de container para o que foi discutido anteriormente:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;02_diagrama_de_containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A fim de detalhamento, podemos dividir o container View em cinco componentes: Resources, Model, Helper Server, Utils e Pages.&lt;/p&gt;
&lt;p&gt;O componente Resources é composto por um conglomerado de scripts em Python que são utilizados em páginas HTML, compondo de forma fragmentada, funcionalidades para interação do usuário no sistema.&lt;/p&gt;
&lt;p&gt;Model provê o conceito matemático utilizado para a realização de simulações e projeções epidemiológicas, através da linguagem em Python.&lt;/p&gt;
&lt;p&gt;Helper Server utiliza o microframework Flask juntamente com Python, para fornecer um serviço de cache do sistema, carregando dados via API calls.&lt;/p&gt;
&lt;p&gt;O elemento Utils, é responsável pela realização de diferentes funções relacionadas ao gerenciamento da seção do usuário no sistema coletando, informações da seção dos usuário e interações através do Streamlit framework, integrado com Python.&lt;/p&gt;
&lt;p&gt;Por último temos o componente Pages que usa Python, HTML e o framework Streamlit, para fornecer visualização interativa com dados. É nesse componente, encontra-se todas as subaplicações disponibilizadas pelo FarolCovid (descritas na seção &lt;strong&gt;Visão de Informação&lt;/strong&gt; deste documento) e se comunica com a API para buscas, filtragens e realização de análises dos dados.&lt;/p&gt;
&lt;p&gt;Logo abaixo, temos o diagrama de componentes para o FarolCovid:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;03_diagrama_de_componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como sabemos, a principal funcionalidade do projeto Farol Covid é apresentar informações pré-processadas, no formato de análises, de acordo com uma determinada localidade. Dessa forma, nesta seção abordaremos de maneira simplificada, o percurso habitual que os usuários percorrem na busca das informações disponibilizadas pela aplicação em estudo.&lt;/p&gt;
&lt;p&gt;Na página inicial, o usuário se depara com uma breve apresentação da plataforma e, logo em seguida, uma caixa de seleção é disponibilizada dividida em três tipos: Estado, Região de Saúde (algo particular de cada estado) e Município (Municípios do estado selecionado). Podemos perceber que há uma hierarquia entre os tipos disponíveis, onde um &amp;ldquo;Município&amp;rdquo; é um subtipo de uma &amp;ldquo;Região de Saúde&amp;rdquo; e de um &amp;ldquo;Estado&amp;rdquo;, assim como &amp;ldquo;Região de Saúde&amp;rdquo; é subtipo de um &amp;ldquo;Estado&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Logo abaixo, temos as informações apresentadas de acordo com o que foi selecionado pelo usuário. Essas informações são mostradas a partir de métricas bem definidas (que  estão disponíveis para consulta no botão &amp;ldquo;Entenda a Classificação dos Níveis&amp;rdquo;) e indicam, por exemplo, situação e controle da doença, capacidade do sistema de saúde, etc.&lt;/p&gt;
&lt;p&gt;Além disso, é disponibilizado quatro subaplicações que permitem uma análise mais detalhada de acordo com a localidade anteriormente escolhida, sendo elas: Simula Covid, que permite a realização de uma simulação da situação da Covid considerando variáveis pertinentes; Distanciamento Social, que mostra a taxa de isolamento social; Saúde em Ordem, que dá uma prognóstico no que diz respeito a possíveis atividades econômicas seguras para reabertura; Onda Covid, que mostra a evolução da curva de contágio da Covid-19 em relação a outros países.&lt;/p&gt;
&lt;p&gt;Para cada interação do usuário, a página é automaticamente recarregada de acordo com o que foi selecionado. Por default, o elemento pré-selecionado do sistema é o estado do Acre.&lt;/p&gt;
&lt;p&gt;Vejamos abaixo, uma máquina de estados que ilustra fluxo da informação da aplicação estudada, para principais interações de um usuário:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;04_fluxo_informacao.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento arquitetural do Querido Diário</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/querido-diario/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/querido-diario/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Matheus Alves dos Santos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110503&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:matheus.santos@ccc.ufcg.edu.br&#34;&gt;matheus.santos@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario&#34;&gt;https://github.com/okfn-brasil/querido-diario&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----querido-diário&#34;&gt;Descrição Arquitetural &amp;ndash; Querido Diário&lt;/h1&gt;
&lt;div align=&#34;center&#34; style=&#34;margin-top:1.5rem;&#34;&gt;
    &lt;img src=&#34;logo.png&#34; style=&#34;width:20rem;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario&#34;&gt;Querido Diário&lt;/a&gt; da &lt;em&gt;&lt;a href=&#34;https://github.com/okfn-brasil&#34;&gt;Open Knowledge Brasil&lt;/a&gt;&lt;/em&gt;, baseando-se especialmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante ressaltar que o Querido Diário é composto por módulos cujas implementações estão em repositórios à parte do principal. Por isso, este documento incluirá módulos como a &lt;a href=&#34;https://github.com/okfn-brasil/querido-diario-api&#34;&gt;API do Querido Diário&lt;/a&gt; e o serviço de &lt;a href=&#34;https://github.com/okfn-brasil/busca-querido-diario&#34;&gt;Busca por Palavras-Chave&lt;/a&gt;. Em contrapartida, o conteúdo de repositórios relacionados que não têm impacto direto no sistema, como o site de divulgação do projeto, não será incluído.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-e-objetivos&#34;&gt;Descrição Geral e Objetivos&lt;/h2&gt;
&lt;p&gt;Os Diários Oficiais estão entre as melhores fontes de informação sobre as ações da administração pública brasileira, especialmente por sua granularidade, existindo até mesmo no âmbito municipal. Contudo, mesmo com a &lt;a href=&#34;https://www.gov.br/acessoainformacao/pt-br&#34;&gt;Lei de Acesso à Informação&lt;/a&gt; vigente, a maioria destas publicações não está disponível em formatos adequados. Elas são encontradas quase exclusivamente em formato PDF.&lt;/p&gt;
&lt;p&gt;Nesse cenário, o Querido Diário visa rastrear as fontes destas publicações nos 5.570 municípios brasileiros, extrair as informações ali contidas e, posteriormente, disponibilizá-las na forma de dados abertos.&lt;/p&gt;
&lt;p&gt;Ao criar uma fonte confiável e centralizada para estas informações, o Querido Diário busca auxiliar a sociedade civil no acompanhamento dos atos públicos municipais, bem como fomentar avanços nas ferramentas de fiscalização da administração pública brasileira.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Os usuários do Querido Diário formam um grupo muito heterogêneo, contemplando desde servidores públicos e jornalistas até organizações não governamentais de controle social. De forma geral, todos os cidadãos que busquem acesso aos atos públicos dos municípios brasileiros são potenciais usuários deste &lt;em&gt;software&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Ainda assim, é possível dividi-los em dois grupos principais: a &lt;strong&gt;sociedade civil&lt;/strong&gt; e as &lt;strong&gt;ferramentas de fiscalização da administração pública&lt;/strong&gt;. Ambos utilizam o Querido Diário como fonte centralizada e confiável de informação acerca dos Diários Oficiais municipais. Contudo, diferenciam-se à medida que as ferramentas de fiscalização não usam os dados disponibilizados apenas como fonte de informação. Elas vão além, aplicando-os na identificação de padrões, detecção de problemas e promoção de impactos positivos na administração pública das cidades brasileiras.&lt;/p&gt;
&lt;p&gt;Para atender às demandas desses dois grupos de usuários, o Querido Diário precisa acessar uma grande quantidade de &lt;strong&gt;portais dos poderes públicos municipais&lt;/strong&gt; nos quais os Diários Oficiais são disponibilizados. A partir dos documentos encontrados, as informações de interesse são extraídas e estruturadas adequadamente para que possam ser, posteriormente, disponibilizadas.&lt;/p&gt;
&lt;p&gt;O diagrama apresentado na Figura 1 descreve sucintamente o contexto em que o Querido Diário está inserido.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-contexto.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 1 - Diagrama de contexto do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;containers&#34;&gt;&lt;em&gt;Containers&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;O Querido Diário é composto atualmente pelos quatro &lt;em&gt;containers&lt;/em&gt; que serão descritos a seguir.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Raspador de Diários Oficiais&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por acessar os portais do poder público onde são disponibilizados os Diários Oficiais municipais, bem como por extrair as informações de interesse sobre estes documentos. Ele foi implementado em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;, mais especificamente através das bibliotecas &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt; e &lt;a href=&#34;https://scrapy.org/&#34;&gt;Scrapy&lt;/a&gt;. Este &lt;em&gt;container&lt;/em&gt; se comunica com os portais do poder público através de requisições HTTP e aplica rotinas de pré-processamento nos dados (por meio de &lt;em&gt;middleware&lt;/em&gt;) antes de enviá-los para o armazenamento usando &lt;em&gt;Data Mappers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Pré-Processador de Dados&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por aplicar transformações aos dados brutos extraídos dos Diários Oficiais, colocando-os em um formato estruturado, acessível e mais amigável à compreensão humana. Ele foi implementado em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; e disponibiliza diversas rotinas de tratamento e limpeza de dados, sendo utilizado como um &lt;em&gt;middleware&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;strong&gt;Banco de Dados&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; responsável por armazenar, de forma estruturada, todas as informações extraídas a partir dos Diários Oficiais municipais. Ele foi implementado em &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; e outros &lt;em&gt;containers&lt;/em&gt; utilizam &lt;em&gt;Data Mappers&lt;/em&gt; para acessá-lo.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;API do Querido Diário&lt;/strong&gt; é o &lt;em&gt;container&lt;/em&gt; que viabiliza o acesso externo e eficiente aos dados armazenados no banco de dados. Ela foi implementada em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;, mais especificamente através das bibliotecas &lt;a href=&#34;https://elasticsearch-py.readthedocs.io/en/master/&#34;&gt;Elastic Search&lt;/a&gt;, &lt;a href=&#34;https://fastapi.tiangolo.com/&#34;&gt;Fast-API&lt;/a&gt; e &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;. Foram utilizados padrões REST e o acesso a esta API se dá por meio de requisições HTTP em formato JSON. Os dois &lt;em&gt;endpoints&lt;/em&gt; disponíveis atualmente estão descritos a seguir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /gazzettes/&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Retorna informações sobre os Diários Oficiais que atendam às características descritas no &lt;em&gt;payload&lt;/em&gt; da requisição.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atributos do &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;since&lt;/code&gt;:&lt;/strong&gt; Data mínima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;until&lt;/code&gt;:&lt;/strong&gt; Data máxima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;keywords&lt;/code&gt;:&lt;/strong&gt; Lista das palavras-chave que os Diários Oficiais retornados devem conter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page&lt;/code&gt;:&lt;/strong&gt; Número da página de resultados a ser retornada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page_size&lt;/code&gt;:&lt;/strong&gt; Tamanho da página de resultados a ser retornada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;since&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-09-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-10-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;queimadas&amp;#34;&lt;/span&gt;],
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page_size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /gazzettes/&amp;lt;territory_id&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; Retorna informações sobre os Diários Oficiais que atendam às características descritas no &lt;em&gt;payload&lt;/em&gt; da requisição e que sejam do município cujo código no IBGE é igual ao &lt;strong&gt;territory_id&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atributos do &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;since&lt;/code&gt;:&lt;/strong&gt; Data mínima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;until&lt;/code&gt;:&lt;/strong&gt; Data máxima de publicação dos Diários Oficiais a serem retornados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;keywords&lt;/code&gt;:&lt;/strong&gt; Lista das palavras-chave que os Diários Oficiais retornados devem conter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page&lt;/code&gt;:&lt;/strong&gt; Número da página de resultados a ser retornada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;page_size&lt;/code&gt;:&lt;/strong&gt; Tamanho da página de resultados a ser retornada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exemplo de &lt;em&gt;Payload&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{ 
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;since&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-03-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2020-08-01&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;keywords&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;medidas&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;covid-19&amp;#34;&lt;/span&gt;],
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;page_size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama apresentado na Figura 2 descreve os &lt;em&gt;containers&lt;/em&gt; que compõem o Querido Diário.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-containers.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 2 - Diagrama de &lt;i&gt;containers&lt;/i&gt; do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Além destes &lt;em&gt;containers&lt;/em&gt;, futuramente serão implementados outros dois: um para o &lt;em&gt;&lt;strong&gt;Front-End&lt;/strong&gt;&lt;/em&gt;, que permitirá o acesso facilitado aos resultados e informações do Querido Diário, e um para &lt;strong&gt;Processamento de Linguagem Natural&lt;/strong&gt;, que permitirá a execução de algoritmos de Inteligência Artificial com os dados extraídos.&lt;/p&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;p&gt;Até a conclusão deste documento, o processo de implantação do Querido Diário não havia sido concluído e, portanto, nem todas as decisões sobre este tópico estavam disponíveis.&lt;/p&gt;
&lt;p&gt;Contudo, já se sabe que o serviço &lt;a href=&#34;https://www.digitalocean.com/products/spaces/&#34;&gt;Spaces Object Storage&lt;/a&gt; da &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; será utilizado para a hospedagem de todos os arquivos e que a integração contínua com o código hospedado no &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; será feita por meio do &lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;Observando a arquitetura do Querido Diário em mais detalhes, os &lt;em&gt;containers&lt;/em&gt; descritos anteriormente podem ser subdivididos em componentes.&lt;/p&gt;
&lt;p&gt;No Raspador de Diários Oficiais, o componente mais importante talvez seja o &lt;strong&gt;Extrator de Documentos&lt;/strong&gt;. Ele é formado por um extenso conjunto de &lt;em&gt;spiders&lt;/em&gt; do &lt;a href=&#34;https://scrapy.org/&#34;&gt;Scrapy&lt;/a&gt; que, através de requisições HTTP, recuperam os arquivos dos Diários Oficiais municipais no formato em que estão disponibilizados. Já o componente &lt;strong&gt;Raspador de Dados&lt;/strong&gt; é aquele responsável por identificar e executar a forma mais adequada de raspagem das informações contidas nestes arquivos.&lt;/p&gt;
&lt;p&gt;É durante essa raspagem de dados que ocorre o uso (como &lt;em&gt;middleware&lt;/em&gt;) do Pré-Processador de Dados ou, mais especificamente, do conjunto de &lt;strong&gt;Rotinas de Tratamento de Dados&lt;/strong&gt; implementadas em &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt; que o compõe. Esses componentes são responsáveis por garantir que, uma vez extraídos, os dados assumam a forma acessível e amigável que se espera deles. A partir deste ponto, o componente &lt;strong&gt;Modelador de Dados&lt;/strong&gt; irá garantir que os dados sejam armazenados, estruturando-os adequadamente e enviando-os ao Banco de Dados por meio de &lt;em&gt;Data Mappers&lt;/em&gt; do &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Já na API do Querido Diário, é possível identificar dois componentes principais. O primeiro deles, a &lt;strong&gt;Interface de Acesso&lt;/strong&gt;, utiliza o &lt;a href=&#34;https://fastapi.tiangolo.com/&#34;&gt;Fast-API&lt;/a&gt; para manipular as requisições HTTP recebidas e extrair os parâmetros de consulta que serão encaminhandos ao Buscador de Dados. Além disso, também é este componente que envia os resultados das consultas aos usuários que realizaram as requisições à API do Querido Diário.&lt;/p&gt;
&lt;p&gt;Por fim, o &lt;strong&gt;Buscador de Dados&lt;/strong&gt; é o componente responsável por recuperar o conjunto de dados que atenda às especificações dos parâmetros de consulta recebidos. Para isso, o acesso ao Banco de Dados utiliza o &lt;a href=&#34;https://elasticsearch-py.readthedocs.io/en/master/&#34;&gt;Elastic Search&lt;/a&gt; e os &lt;em&gt;Data Mappers&lt;/em&gt; do &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;, permitindo que mesmo consultas complexas (como a busca por palavras-chave nos documentos) sejam executadas de forma eficiente.&lt;/p&gt;
&lt;p&gt;O diagrama apresentado na Figura 3 descreve os componentes do Querido Diário que foram citados ao longo desta seção.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;diagrama-componentes.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 3 - Diagrama de componentes do Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
&lt;h2 id=&#34;visão-da-informação&#34;&gt;Visão da Informação&lt;/h2&gt;
&lt;p&gt;Apesar da grande quantidade de dados que é manipulada pelo Querido Diário, todas as informações podem ser centralizadas no conceito de Diário Oficial.&lt;/p&gt;
&lt;p&gt;Inicialmente, o Diário Oficial é um documento &lt;strong&gt;disponibilizado&lt;/strong&gt; em algum portal de poder público municipal, geralmente em formatos pouco amigáveis ao processamento por máquina (como PDFs). Por isso, a primeira atividade do Querido Diário é acessá-lo e obtê-lo. Uma vez que o documento foi &lt;strong&gt;recuperado&lt;/strong&gt;, as informações de interesse contidas nele precisam ser &amp;ldquo;raspadas&amp;rdquo;, de modo que o sistema passe a lidar apenas com esse conjunto de dados &lt;strong&gt;extraído&lt;/strong&gt;. Durante este processo, o conjunto de dados ainda deve sofrer diversas transformações para que se torne mais acessível e compreensível, ou seja, se torne &lt;strong&gt;tratado&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Com essas etapas concluídas, o Diário Oficial pode finalmente ser &lt;strong&gt;armazenado&lt;/strong&gt; no banco de dados do Querido Diário, onde permanecerá indefinidamente. Finalmente, todas as publicações de Diários Oficiais que forem armazenadas pelo Querido Diário poderão ser &lt;strong&gt;requisitadas&lt;/strong&gt; por qualquer indivíduo que tenha interesse em conhecer mais sobre os atos do poder público nos municípios brasileiros.&lt;/p&gt;
&lt;p&gt;O fluxo de informações descrito nesta seção está apresentado no diagrama de estados da Figura 4.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin:2rem 0;&#34;&gt;
    &lt;img src=&#34;visao-informacao.png&#34; style=&#34;width:95%;&#34;&gt;
    &lt;span style=&#34;display:block;font-weight:bold;&#34;&gt;
        Figura 4 - Visão da Informação dos Diários Oficiais no Querido Diário
    &lt;/span&gt;
&lt;/div&gt;
</description>
     </item>
   
     <item>
       <title>Projeto Eureca - Da coleta de dados ao backend</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca-da_coleta_de_dados_ao_backend/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/eureca-da_coleta_de_dados_ao_backend/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Mendes da Silva Júnior.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210922&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.junior@ccc.ufcg.edu.br&#34;&gt;paulo.junior@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projetos documentados: &lt;/br&gt;
&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-coleta-de-dados&#34;&gt;https://github.com/computacao-ufcg/eureca-coleta-de-dados&lt;/a&gt; &lt;/br&gt;
&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend&#34;&gt;https://github.com/computacao-ufcg/eureca-backend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----projeto-eureca-coleta-de-dados-ao-backend&#34;&gt;Descrição Arquitetural &amp;ndash; Projeto Eureca (Coleta de dados ao backend)&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura de uma parte do projeto &lt;strong&gt;Eureca&lt;/strong&gt; (&lt;a href=&#34;https://github.com/computacao-ufcg/eureca-coleta-de-dados&#34;&gt;Coleta de dados&lt;/a&gt; e &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend&#34;&gt;Backend&lt;/a&gt;). Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-eureca-da-coleta-de-dados-ao-backend&#34;&gt;Descrição geral sobre o Eureca (da coleta de dados ao backend)&lt;/h2&gt;
&lt;p&gt;O projeto &lt;strong&gt;Eureca&lt;/strong&gt; se trata de um projeto da coordenação do curso de Computação@UFCG, projeto ao qual eu estou vinculado, que tem a finalidade de auxiliar a coordenação do curso em suas ações a curto e longo prazo. Com funcionalidades de monitoramento, estatísticas, comunicação e serviços que englobam todos os alunos do curso de Computação na UFCG.&lt;/p&gt;
&lt;h2 id=&#34;eureca-da-coleta-de-dados-ao-backend&#34;&gt;Eureca (da coleta de dados ao backend)&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Prover uma interface de monitoramento para a coordenação do curso, que possua informações sobre como os alunos estão se comportando de acordo com o período aos quais se encontram, em relação as suas notas, presenças e demais especificidades. Essas informações são divididas em quatro grandes blocos: Monitoramento, Estatísticas, Comunicação e Serviços.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos que o coordenador seja capaz, de por exemplo, fazer um acompanhamento mais direto com aqueles alunos que se encontram em situações críticas. Além de observar também os que se encontram &amp;ldquo;Acima da média&amp;rdquo; e também os regulares. O sistema também irá possuir serviços de estatísticas sobre todos os alunos que já passaram pelo curso, sejam eles graduados, ativos ou evadidos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O repositório Eureca-coleta-de-dados inicia se comunicando com o sistema de controle acadêmico a fim de baixar páginas .html de alunos do curso de Computação@UFCG, onde ocorre todo um processamento nessas páginas, desde a raspagem dos dados relevantes das páginas .html até a criação dos relacionamentos dos dados em arquivos .csv para inserção no banco de dados. Logo após, esses dados são inseridos no Banco de Dados Eureca-Deploy, a partir disso, o Eureca-Backend, que consiste de uma API REST, acessa o banco de dados atráves de requisições HTTP e expõe endpoints para que a API seja acessada pelo Eureca-Frontend.&lt;/p&gt;
&lt;p&gt;Logo abaixo temos o diagrama de contexto referente a parte de coleta de dados e backend do projeto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama_contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O crawler acessa o sistema de controle acadêmico (serviço externo) e baixa várias páginas .html por aluno, que são as de cadastro, histórico, faltas, notas, etc. Essas páginas são processadas por parsers, que filtram os dados relevantes que estão nas páginas, esses dados então são formatados e por fim, retornados na saída padrão. Logo após scripts shell fazem a separação dos dados adicionado os relacionamentos e separando os dados em arquivos .csv que correspondem aos dados que serão inseridos em cada tabela do banco de dados, incluindo relacionamentos de chaves estrangeiras, chave auto incremental, etc. Assim os dados estarão prontos para serem inseridos no banco de dados.
Com o banco de dados populado, o eureca-backend (API REST) o acessa através de queries SQL e o banco de dados retorna respostas JSON para o backend.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama_container.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;Todo o sistema (exceto o Eureca-coleta-de-dados) está hospedado em uma máquina virtual Linux (Ubuntu) do LSD (Laboratório de Sistemas Distribuídos) da UFCG, onde nessa máquina virtual encontram-se 3 (três) contêineres Docker em execução, o primeiro é Eureca-deploy rodando na porta 5432, o segundo é o Eureca-Backend rodando na porta 5500, e por fim, o Eureca-frontend rodando na porta 3333.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Obs:&lt;/strong&gt; O Eureca-coleta-de-dados não encontra-se em execução porque o coordenador, no momento, está fazendo esse processo de download das páginas e geração dos dados para o banco de dados localmente. Além de que esse é um processo que não é feito com frequência.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;endpoints&#34;&gt;Endpoints&lt;/h5&gt;
&lt;p&gt;A API REST que se trata do repositório Eureca-Backend, no momento em que este documento foi escrito possui os seguintes endpoints.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/api/estatisticas/ativos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/ativos/csv&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/egressos/csv&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos?de=periodo&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos?de=periodo_min&amp;amp;ate=periodo_max&lt;/li&gt;
&lt;li&gt;/api/estatisticas/evadidos/csv&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No diagrama de componentes (localizado abaixo) temos os componentes principais de cada container, além de seus relacionamentos e responsabilidades. Em nosso projeto o &lt;strong&gt;Crawler&lt;/strong&gt; obtém as páginas .html de alunos no sistema de controle acadêmico, então os &lt;strong&gt;Parsers&lt;/strong&gt; (que são scripts python) utilizam essas páginas para fazer uma espécie de raspagem dos dados relevantes (web scrapping) utilizando o Beautiful Soap, que é um pacote python para análise de documentos, e assim, retirar as informações relevantes para o projeto.&lt;/p&gt;
&lt;p&gt;Então os &lt;strong&gt;Scripts Shell&lt;/strong&gt; fazem uso desses dados filtrados para gerar arquivos .csv contendo relacionamentos desses dados para formar os dados que irão compor as tabelas do banco de dados. Após isso os dados são inseridos no banco de dados, e esses dados são acessados a partir de uma API REST (Eureca-Backend) que possui &lt;strong&gt;Controllers&lt;/strong&gt; que fornecem as rotas e se comunicam com os &lt;strong&gt;Models&lt;/strong&gt;, onde estes fazem as requisições que utilizam queries SQL, que são feitas através de uma lib chamada psycopg, que nada mais que é que um adaptador de banco de dados Postgres, onde o mesmo acessa um banco de dados Postgres através de queries SQL. Então esses dados resultantes das queries são processados no backend e retornados no formato JSOn em endpoints ou rotas, que são acessadas pelo Eureca-Frontend que renderiza esses dados de forma amigável em uma interface do usuário.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de informação&lt;/h3&gt;
&lt;p&gt;As informações trafegam pelo sistema de modo que tudo se inicia com os dados brutos, que são as páginas .html do SCA, então essas páginas são processadas pelos scripts de parser que filtram os dados relevantes para a aplicação. Logo, esses dados filtrados são processados por scripts shell que geram arquivos .csv que criam relacionamentos entre os dados, de modo que esses arquivos são os dados que serão inseridos nas tabelas no banco de dados.&lt;/p&gt;
&lt;p&gt;Logo a seguir, podemos ver o diagrama de máquina de estados referente à coleta de dados:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;maquina_estados.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h3&gt;
&lt;p&gt;Como eu faço parte do projeto Eureca, então eu já fiz inúmeras Pull Request&amp;rsquo;s, principalmente nos repositórios Eureca-Deploy e Eureca-Backend, algumas dessas PR&amp;rsquo;s podem ser vistas nos seguintes links: &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-deploy/pulls?q=is%3Apr+is%3Aclosed&#34;&gt;Eureca-Deploy-pull_requests&lt;/a&gt; e &lt;a href=&#34;https://github.com/computacao-ufcg/eureca-backend/pulls?q=is%3Apr+is%3Aclosed&#34;&gt;Eureca-Backend-pull_requests&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documento Arquitetural do Axios</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/axios/</link>
       <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/axios/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Marcus Vinícius de Farias Barbosa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110906&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:marcus.barbosa@ccc.ufcg.edu.br&#34;&gt;marcus.barbosa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;https://github.com/axios/axios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----axios&#34;&gt;Descrição Arquitetural &amp;ndash; Axios&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;Axios&lt;/a&gt;.
As descrições e diagramas aqui presentes foram produzidos usando como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral&#34;&gt;Descrição Geral&lt;/h2&gt;
&lt;p&gt;O Axios é um cliente HTTP, que pode ser utilizado tanto no navegador quando em projetos Node.js. Ele é disponibilizado como um pacote npm, e fornece uma API para o envio de requisições que lida com &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt; do navegador e com o &lt;a href=&#34;https://nodejs.org/api/http.html&#34;&gt;http&lt;/a&gt; do Node.js, desse modo o mesmo código pode ser utilizado no lado cliente e no lado servidor.&lt;/p&gt;
&lt;p&gt;De acordo com sua documentação oficial, o Axios conta com as seguintes funcionalidades:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Faz requisições com XMLHttpRequest a partir do browser;&lt;/li&gt;
&lt;li&gt;Faz requisições http a partir do node.js;&lt;/li&gt;
&lt;li&gt;Tem suporte à API &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Intercepta requisições e respostas;&lt;/li&gt;
&lt;li&gt;Transforma dados de requisições e respostas;&lt;/li&gt;
&lt;li&gt;Cancela requisições;&lt;/li&gt;
&lt;li&gt;Faz transformações automáticas para dados JSON;&lt;/li&gt;
&lt;li&gt;Fornecer proteção no lado cliente contra &lt;a href=&#34;https://pt.wikipedia.org/wiki/Cross-site_request_forgery&#34;&gt;XSRF&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além disso, por ser uma biblioteca bastante conhecida e utilizada no meio do desenvolvimento web, existem diversas bibliotecas criadas pela comunidade que interagem com o Axios e adicionam a ele novos recursos, que vão desde interceptores de requisições a cache.&lt;/p&gt;
&lt;p&gt;Mais informações podem ser encontradas &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h2&gt;
&lt;p&gt;Oferecer uma biblioteca baseada em Promises para envio de requisições HTTP de forma simples e sem que o usuário se preocupe se a requisição será feita a partir do navegador ou de um servidor Node.js.&lt;/p&gt;
&lt;h2 id=&#34;contexto&#34;&gt;Contexto&lt;/h2&gt;
&lt;p&gt;Como o Axios se trata de uma biblioteca, os usuários finais são os desenvolvedores de &lt;em&gt;software&lt;/em&gt;, que a importam em seus projetos e assim fazem uso de suas funcionalidades.&lt;/p&gt;
&lt;p&gt;Em relação à comunicação com sistemas externos, a principal interação realizada é com o servidor alvo das requisições definido pelo usuário. Esse servidor precisa dispor de uma API HTTP, pois esse é o protocolo de comunicação utilizado pelo Axios em suas requisições.&lt;/p&gt;
&lt;p&gt;A comunicação também é feita com &lt;em&gt;plugins&lt;/em&gt; de terceiros, que são bibliotecas desenvolvidas para interagirem com os recursos do Axios e adicionam a ele novas funcionalidades como suporte a &lt;em&gt;cookies&lt;/em&gt;, manipulação de &lt;em&gt;cache&lt;/em&gt; e comunicação com &lt;em&gt;middlewares&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O diagrama de contexto abaixo ilustra quais entidades interagem com o Axios.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context-diagram.png&#34; alt=&#34;Diagrama de Contexto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;containers&#34;&gt;&lt;em&gt;Containers&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Como o Axios não é um sistema de &lt;em&gt;software&lt;/em&gt;, ou seja, não é composto por aplicações nem possui armazenamento de dados, mas uma biblioteca, ele é constituído de um único &lt;em&gt;container&lt;/em&gt; que possui todos os módulos de código necessários para seu funcionamento e implementação de suas funcionalidades.&lt;/p&gt;
&lt;p&gt;A sua API disponibiliza os seguintes recursos:&lt;/p&gt;
&lt;h4 id=&#34;envio-de-requisições&#34;&gt;Envio de requisições&lt;/h4&gt;
&lt;h5 id=&#34;axiosconfig&#34;&gt;axios(config)&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de uma requisição POST para um serviço local
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;post&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/user/12345&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Fred&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Flintstone&amp;#39;&lt;/span&gt;
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de uma requisição GET para um serviço remoto
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://bit.ly/2mTM3nY&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;responseType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;stream&amp;#39;&lt;/span&gt;
})
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pipe&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createWriteStream&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ada_lovelace.jpg&amp;#39;&lt;/span&gt;))
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;axiosurl-config&#34;&gt;axios(url[, config])&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de envio de uma requisição GET, utilizando o método me envio padrão
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/user/12345&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;criação-de-instância-axios&#34;&gt;Criação de instância Axios&lt;/h4&gt;
&lt;h5 id=&#34;axioscreateconfig&#34;&gt;axios.create([config])&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Exemplo de criação de uma instância Axios
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;axios&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;baseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://some-domain.com/api/&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;headers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Custom-Header&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foobar&amp;#39;&lt;/span&gt;}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mais detalhes sobre a API podem ser encontrados &lt;a href=&#34;https://github.com/axios/axios#axios-api&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;implantação&#34;&gt;Implantação&lt;/h3&gt;
&lt;p&gt;A sua implantação também é simples se comparado com sistemas de &lt;em&gt;software&lt;/em&gt;, pois, tendo sido instalado no projeto através de algum gerenciador de pacotes (como npm e yarn) ou pelo CDN, é preciso apenas se atentar para os requisitos de ambiente: o navegador e sua versão, e a versão no Node.js. Como essas informações são voláteis e dependem da versão atual do Axios, é recomendado verificá-las na &lt;a href=&#34;https://github.com/axios/axios&#34;&gt;documentação&lt;/a&gt; oficial.&lt;/p&gt;
&lt;p&gt;O diagrama de implantação abaixo ilustra como é feita a implantação do Axios. Nele é possível notar que a biblioteca pode ser utilizada tanto em aplicações que são executadas por um navegador quanto em aplicações Node.js em um servidor. Além disso, nota-se também que os &lt;em&gt;plugins&lt;/em&gt; utilizados estão no mesmo nível que o Axios e são importados e utilizados de modo semelhante a ele.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deployment-diagram.png&#34; alt=&#34;Diagrama de Implantação&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;
&lt;p&gt;O Axios é composto pelos seguintes componentes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Axios&lt;/strong&gt;: fornece uma instância Axios com todos os métodos necessários configurados.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Core&lt;/strong&gt;&lt;/em&gt;: contém a lógica de domínio do Axios. É nesse componente em que são implementados o gerenciador de interceptadores, a manipulação de configurações e envio de requisições.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Defaults&lt;/strong&gt;&lt;/em&gt;: define as configurações iniciais para a criação de uma instância Axios, como os &lt;em&gt;aliases&lt;/em&gt; para os métodos de requisição e a definição do &lt;em&gt;adapter&lt;/em&gt; adequado.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Adapters&lt;/strong&gt;&lt;/em&gt;: responsável pelo envio de requisições e resolução de &lt;em&gt;Promises&lt;/em&gt; retornadas assim que uma resposta é recebida. Existe um adapter para lidar com http do Node.js e outro para lidar com o XHR do navegador.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Helpers&lt;/strong&gt;&lt;/em&gt;: dispõe de implementações genéricas que não são específicas para a lógica de domínio, mas que são utilizadas por toda a aplicação, como gerenciamento de &lt;em&gt;cookies&lt;/em&gt;, &lt;em&gt;parsers&lt;/em&gt; de cabeçalhos HTTP e &lt;em&gt;polyfills&lt;/em&gt; do navegador.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama de componentes abaixo ilustra os componentes apresentados e sua comunicação.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components-diagram.png&#34; alt=&#34;Diagrama de Componentes&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h2&gt;
&lt;p&gt;Dentre os vários tipos de dados que o Axios manipula, o que foi escolhido para ser apresentado nessa seção foi o dado que representa uma requisição, desde a chamada ao método de envio ao seu dispacho para o destinatário.&lt;/p&gt;
&lt;p&gt;Através do seguinte fluxo de processamento de uma requisição é possível notar os estados que ela assume ao logo do processo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O método para envio de uma requisição é chamado, e inicia-se o processo de configuração da requisição;&lt;/li&gt;
&lt;li&gt;O Axios verifica a existência de cabeçalhos e os manipula, adicionando cabeçalhos necessários;&lt;/li&gt;
&lt;li&gt;Os dados (cabeçalhos e informações enviadas no corpo) da requisição são transformados para um formato padrão;&lt;/li&gt;
&lt;li&gt;É validado se esses dados são do tipo &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;ArrayBuffer&lt;/em&gt;, &lt;em&gt;Buffer&lt;/em&gt; ou &lt;em&gt;Stream&lt;/em&gt;:
&lt;ul&gt;
&lt;li&gt;Se sim, a requisição continua sendo processada;&lt;/li&gt;
&lt;li&gt;Se não, seu processo de envio é cancelado;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;São definidos dados de autenticação básica HTTP na requisição;&lt;/li&gt;
&lt;li&gt;O endereço (URL) do destinatário da requisição é formatado, bem como o protocolo utilizado;&lt;/li&gt;
&lt;li&gt;Se foi definido algum &lt;em&gt;proxy&lt;/em&gt;, a requisição recebe toda a configuração referente a ele, como porta, caminho e nome;&lt;/li&gt;
&lt;li&gt;A requisição é então enviada.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O diagrama abaixo ilustra o que foi explanado acima, dando enfoque nos estados assumidos por uma requisição.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fsm-diagram.png&#34; alt=&#34;Diagrama de Máquina de Estados&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h2&gt;
&lt;p&gt;Ainda não foram abertas PRs para o repositório oficial do Axios porque ainda é necessário validar a documentação já
produzida e produzir uma versão em inglês.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>UFCGPro</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/matheusaraujo/</link>
       <pubDate>Sun, 11 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/matheusaraujo/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Matheus Silva Araújo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117210375&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:matheus.araujo@ccc.ufcg.edu.br&#34;&gt;matheus.araujo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/lucis/ufcg-pro&#34;&gt;https://github.com/lucis/ufcg-pro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----extensão-do-controle-acadêmico-da-universidade-federal-de-campina-grande&#34;&gt;Descrição Arquitetural &amp;ndash; Extensão do Controle Acadêmico da Universidade Federal de Campina Grande.&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/lucis/ufcg-pro&#34;&gt;UFCGPro&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O UFCGPro é uma ferramenta para melhorar o uso do Controle Acadêmico da Universidade Federal de Campina Grande.&lt;/p&gt;
&lt;h2 id=&#34;extensão-do-controle-acadêmico&#34;&gt;Extensão do Controle Acadêmico&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para auxiliar discentes e docentes em atividades comuns da rotina acadêmica institucional como disciplinas, matrículas e afins.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Adicionar recursos ao controle acadêmico da Universidade Federal de Campina Grande a fim de tornar mais práticas as atividades listadas nesse documento.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O contexto do sistema se resume ao usuário, o browser e a extensão. O usuário adiciona a extensão ao browser, o usuário acessa o Controle Acadêmico pelo browser e a extensão complementa recursos do Controle Acadêmico.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaContexto.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Os containers do sistema se resumem ao browser, pois a extensão UFCGPro funciona individualmente no browser de cada usuário, sem a necessidade de estar implantada num servidor externo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaContainer.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Os componentes do sistema podem ser descritos por: &lt;em&gt;background.js&lt;/em&gt;, que faz a comunicação entre o usuário e os &lt;em&gt;injectors&lt;/em&gt;; os &lt;em&gt;injectors&lt;/em&gt;, que atuam como controllers do sistema e acionam os &lt;em&gt;components&lt;/em&gt;; que por sua vez, fazem as chamadas necessárias e a comunicação com o sistema do Controlador Acadêmico&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaComponentes.png&#34; alt=&#34;componentes&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Nesse exemplo, temos a visão da informação no momento de realizar o planejamento e automatização de uma matrícula. Primeiramente, o usuário acessa a tela de planner, preenche as disciplinas, o sistema verifica se é possível realizar a matrícula e por fim, realiza o processamento do pedido.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;DiagramaInformacional.png&#34; alt=&#34;informação&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;A pull request realizada para o repositório pode ser vista através do link: &lt;a href=&#34;https://github.com/lucis/ufcg-pro/pull/26&#34;&gt;https://github.com/lucis/ufcg-pro/pull/26&lt;/a&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Bypass PayWalls</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/bypass_paywalls/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/bypass_paywalls/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Sammara Beserra Nunes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210039&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:sammara.nunes@ccc.ufcg.edu.br&#34;&gt;sammara.nunes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/iamadamdev/bypass-paywalls-chrome&#34;&gt;https://github.com/iamadamdev/bypass-paywalls-chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-análise-do-twitter&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de análise do twitter&lt;/h1&gt;
&lt;p&gt;Este post descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/iamadamdev/bypass-paywalls-chrome&#34;&gt;ByPass PayWalls&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O Bypass PayWalls é uma extensão para os navegadores Google Chrome e Mozilla Firefox que permite o acesso a certos sites que antes eram bloqueados por acesso pago.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-monitoramento-do-twitter&#34;&gt;O Serviço de monitoramento do twitter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;É uma extensão de navegador que permite o acesso a páginas que são permitidas apenas a assinantes, assim como a limitação dessas mesmas leituras.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Permitir que o conteúdo seja divulgado a quem não pode pagar com uma ferramenta também gratuita.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O plug-in em questão funciona com a manipulação de cookies e arquivos javascript, oferecendo um serviço semelhante aos bloqueadores de anúncio, porém bloqueando acesso pago (ou &amp;ldquo;paywalls&amp;rdquo;), possibilitando a leitura de artigos bloquados e/ou limitados. Antes de executar alguma remoção, ele verifica se o  domínio do site está na lista pré-configurada de &amp;ldquo;domínios permitidos&amp;rdquo;. Caso contrário, permanecerá o acesso bloqueado.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;c4_diagram.png&#34; style=&#34;width:40%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Como trata-se se um plug-un, não há muitos containers. Apenas o navegadores permitidos (Mozilla Firefox e Chrome), o plug-in e a página a ser manipulada pelo plug-in.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;containers_diagram.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;No diagrama de containers, podemos ter uma visão se seus principais serviços para que ele funcione. Como se trata de um plug-in para navegador, seus componentes estão, sua maioria, no seu código (escrito em javascript) e consiste em um arquivo sites.js que armazena todos os sites permitidos em uma const, além da comunição com os navegadores Google Chrome e Firefox. Lembrando que é sempre recomendado limpar os cookies do navegador antes de ver se é algum erro do plug-in.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;components_diagram.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O plug-in coleta o domínio da página e, caso seja um domínio permitido, ele manipula a visualização caso seja uma página com o acesso bloquado.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;diagrama_estados.png&#34; style=&#34;width:70%&#34;&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Ainda nenhum.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para o SAPS</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/saps/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/saps/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
Projeto SAPS para construção de uma plataforma automatizada que realize o cálculo do método SEBAL utilizando imagens de satélite.
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Thiago Yuri Evaristo de Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211156&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:thiago.souza@ccc.ufcg.edu.br&#34;&gt;thiago.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/ufcg-lsd/saps-engine&#34;&gt;https://github.com/ufcg-lsd/saps-engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/ufcg-lsd/saps-engine&#34;&gt;SAPS&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-saps&#34;&gt;Descrição Geral sobre o SAPS&lt;/h2&gt;
&lt;p&gt;O SAPS é um projeto que tem como objetivo processar imagens de satélite utilizando o &lt;a href=&#34;https://en.wikipedia.org/wiki/SEBAL&#34;&gt;método SEBAL&lt;/a&gt; de forma a facilitar o usuário (geralmente um pesquisador) que deseja realizar analises sobre os resultados obtidos pelo seu processamento automático. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0098300419302961&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;imagem-de-satélite&#34;&gt;Imagem de satélite&lt;/h3&gt;
&lt;p&gt;Imagem de satélite é um arquivo de imagem (&lt;a href=&#34;https://en.wikipedia.org/wiki/TIFF&#34;&gt;TIFF&lt;/a&gt;) obtido por sensoriamento remoto a partir de um satélite artificial. Existem diferentes satélites de recolha de imagens, os mais conhecidos são QuickBird, Ikonos, Landsat e Spot.&lt;/p&gt;
&lt;p&gt;No contexto do SAPS, a única família de satélite com suporte é a &lt;a href=&#34;https://en.wikipedia.org/wiki/Landsat_program&#34;&gt;Landsat&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;método-sebal&#34;&gt;Método SEBAL&lt;/h3&gt;
&lt;p&gt;SEBAL (Surface Energy Balance Algorithm for Land) é um algoritmo que usa o balanço de energia de superfície para estimar aspectos do ciclo hidrológico, mapeando então informações como evapotranspiração, crescimento de biomassa, déficit hídrico e umidade do solo.&lt;/p&gt;
&lt;p&gt;Essa quantificação do balanço de energia é calculado usando dados de satélite que originam características da superfície terrestre, como albedo da superfície, índice de área foliar, índice de vegetação e temperatura da superfície. Além das imagens de satélite, o modelo SEBAL requer dados meteorológicos, como velocidade do vento, umidade, radiação solar e temperatura do ar relativos a região de analise.&lt;/p&gt;
&lt;h3 id=&#34;scripts&#34;&gt;Scripts&lt;/h3&gt;
&lt;p&gt;O SAPS é composto de 3 grandes partes para realizar seus processamentos, são eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inputdownloading: responsável pela aquisição dos dados a serem utilizados, como dados de elevação, metereológicos ou até mesmo as próprias imagens de satélite.&lt;/li&gt;
&lt;li&gt;preprocessing: responsável pela preparação dos dados obtidos como por exemplo, extração de pixels de nuvens/sombra de nuvens, &lt;a href=&#34;https://docs.qgis.org/2.14/pt_BR/docs/user_manual/working_with_projections/working_with_projections.html&#34;&gt;reprojeção de imagens&lt;/a&gt; e entre outros.&lt;/li&gt;
&lt;li&gt;processing: responsável pela aplicação do algoritmo final (por exemplo, SEBAL) nos dados preprocessados para geração de novos dados uteis para o usuário a fim de realizar analise e extração de informações.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essas fases são selecionadas pelo usuário formando um pipeline de processamento, cada uma dessas fases é implementada e executada utilizando containers Docker configurados e preparados para execução do passo necessitando somente dos dados de entrada.&lt;/p&gt;
&lt;h2 id=&#34;saps&#34;&gt;SAPS&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo geral&lt;/h3&gt;
&lt;p&gt;Implementar uma plataforma em que usuários possam requisitar/acompanhar/recuperar processamentos de imagens de satélite em um determinado intervalo de tempo e localização, que serão realizados de forma automática.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos específicos&lt;/h3&gt;
&lt;p&gt;Ter uma plataforma abrangente, que possa processar imagens de diversos tipos de familias de satélite (LANDSAT, &amp;hellip;) e computar diversos métodos de processamentos de imagens, além do SEBAL.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;contexto.svg&#34; alt=&#34;diagrama-contexto&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de contexto é apresentado como se da a interação dos demais elementos com a plataforma SAPS. Primeiramente temos os clientes, que requisitam processamentos de imagens de satélite (em um intervalo de tempo e lugar), depois os mesmos acessam para acompanhar a execução do seu processamento e por fim depois que finalizar, recuperar os dados calculados pelo SAPS a partir das imagens fornecidas na entrada.&lt;/p&gt;
&lt;p&gt;Temos também o serviço de e-mail que é utilizado pelo SAPS para envio de mensagens para o usuário, principalmente dos dados finais de um processamento. Além dos datasets (imagens de satélite, dados de elevação e dados meteorológicos) que são bastante uteis para obtenção de informações para o processamento. O serviço de storage serve para armazenar dados finais ou parciais dos processamentos feitos pelo SAPS, isto é destinado a um serviço externo que possui uma boa tecnologia que lida melhor com questões de segurança e persistência dos dados.&lt;/p&gt;
&lt;p&gt;Por último, o serviço de execução de trabalhos que é responsável por receber um workload e executa-lo, e depois enviar informações sobre a execução. Por exemplo, selecionar uma VM com 2GB ram e 4 CPUs, levantar um container docker X (no caso do SAPS será os algoritmos dos passos de inputdownloading, preprocessing ou processing) e executar os comandos Y e Z com os argumentos A e B. Por fim, o serviço vai acompanhar a execução e coletar os exitcodes de cada comando e concluir se o trabalho foi bem sucedido ou falho. O que é importante nesse serviço é sabe o estado final da execução e manter os resultados em um local acessível e seguro.&lt;/p&gt;
&lt;p&gt;Existe uma coisa complicada associada entre os datasets e o serviço de execução de trabalhos que será abordado na visão de componentes.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;containers.svg&#34; alt=&#34;diagrama-containers&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama de containers, o sistema SAPS é amplicado em três novos blocos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUI: Responsável por interagir com o usuário de forma facilitada e gerar workload&lt;/li&gt;
&lt;li&gt;API da aplicação: Responsável por interagir com os pedidos da GUI de workload ou obtenção de informação e processa-las&lt;/li&gt;
&lt;li&gt;Database: Responśavel por registrar informações sobre processamentos e usuários&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;gui&#34;&gt;GUI&lt;/h4&gt;
&lt;p&gt;A GUI possui uma interface com algumas operações simples como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Submeter nova requisição de processamento&lt;/strong&gt; gerando workload a aplicação do SAPS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Acompanhar processamento&lt;/strong&gt; verificando os estados do processamento fazendo com que a aplicação do SAPS gere uma listagem das informações para o usuário&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Obter resultados&lt;/strong&gt; gerando workload a aplicação do SAPS para organização dos dados resultantes e disponibização dos mesmos por meio de um email&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-da-aplicação&#34;&gt;API da aplicação&lt;/h4&gt;
&lt;p&gt;A API possui algumas operações simples como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adicionar nova requisição de processamento&lt;/li&gt;
&lt;li&gt;Adicionar novo usuário&lt;/li&gt;
&lt;li&gt;Recuperar informações sobre processamentos&lt;/li&gt;
&lt;li&gt;Enviar resultados de processamentos&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;database&#34;&gt;Database&lt;/h4&gt;
&lt;p&gt;O banco de dados é responsável por manter os dados do usuário e processamentos.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;componentes.svg&#34; alt=&#34;diagrama-componentes&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagram de componentes são apresentados três componentes principais pertencentes a aplicação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dispatcher: Responsável por registrar novos processamentos ou usuários, e obtenção dos mesmos, além de envio de email para o usuário obter os resultados dos processamentos&lt;/li&gt;
&lt;li&gt;Archiver: Responsável por obter processamentos finalizados e prontos para arquivamento dos dados resultantes/parciais no serviço de storage&lt;/li&gt;
&lt;li&gt;Scheduler: Responsável por agendar as execuções dos passos do processamento com o serviço de execução de trabalhos&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;por-que-existe-uma-camada-a-mais-entre-os-datasets-e-o-serviço-de-execução-de-trabalhos&#34;&gt;Por que existe uma camada a mais entre os datasets e o serviço de execução de trabalhos?&lt;/h4&gt;
&lt;p&gt;Como dito na seção sobre o modelo de contexto, o serviço de execução de trabalhos executa um workload enviado pelo SAPS (Scheduler) que irá ser processado em um ambiente. Esse ambiente por sua vez irá rodar os algoritmos dos passos de inputdownloading, preprocessing e processing que estão em containers Dockers.&lt;/p&gt;
&lt;p&gt;Na execução desses algoritmos (principalmente de fase inputdownloding), irá ser feito a obtenção dos dados presentes nos datasets de imagens de satélite, de dados de elevação e metereológicos, no caso, ainda existe uma pequena camada do SAPS no que está sendo executado representada pelos algoritmos rodados no serviço de execução de jobs para comunicação com esses datasets.&lt;/p&gt;
&lt;p&gt;Importante ressaltar que essa seção é útil para enchar a introdução vista na visão geral com a plataforma SAPS em questões de como o dado é obtido, não sendo feito por nenhum dos componentes, mas por um algoritmo que é executado dentro do serviço de execução de trabalhos.&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da informação&lt;/h3&gt;
&lt;img src=&#34;./fluxo-informacao.svg&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
&lt;p&gt;No diagrama de fluxo de informação é descrito os estados que o processamento pode atingir, começando no estado &lt;strong&gt;created&lt;/strong&gt; e finalizando (se bem sucedido) em &lt;strong&gt;archived&lt;/strong&gt;. Existem alguns pontos de falha nos estados de downloading, preprocessing, processing e archiving, que são originados por:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;downloading: os arquivos relativos ao processamento não foram encontrados nos datasets de imagens de satélite, metereológicos ou dados de elevação, ou estão corrumpidos. Também pode acontecer por uma situação inesperada que ocorreu nessa fase.&lt;/li&gt;
&lt;li&gt;preprocessing/processing: os arquivos baixados não estão como esperado, ou estão ausentes, ou alguma situação inesperada&lt;/li&gt;
&lt;li&gt;archiving: os arquivos a serem armazenados apresentam problemas para enviar ao serviço de storage, ou algum problema inesperado&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições concretas&lt;/h1&gt;
&lt;p&gt;Não realizei a submissão do PR por questões de idioma, as informações/documentações feitas pelo SAPS são em Inglês. Num futuro próximo, pretendo realizar essa contribuição.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Fission Serverless Platform</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/fission/</link>
       <pubDate>Sat, 10 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/fission/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve diversos aspectos arquiteturais da plataforma de
computação &lt;em&gt;serverless&lt;/em&gt; para funções-como-serviço - &lt;em&gt;Fission&lt;/em&gt;.
A promessa dessa plataforma é permitir que desenvolvedores se concentrem
unicamente na tarefa de implementação da lógica de negócio, deixando os detalhes de
implantação sobre a responsabilidade da plataforma.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Feitosa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116211477&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.felipe.silva@ccc.ufcg.edu.br&#34;&gt;paulo.felipe.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/fission/fission&#34;&gt;https://github.com/fission/fission&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural---fission-core-services&#34;&gt;Descrição Arquitetural - Fission Core Services&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto
&lt;a href=&#34;https://fission.io/&#34;&gt;Fission&lt;/a&gt;.
Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura da Fission.
O foco deste documento será a descrição arquitetural dos serviços de &lt;em&gt;core business&lt;/em&gt; da
plataforma em questão.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-fission&#34;&gt;Descrição Geral sobre o &lt;em&gt;Fission&lt;/em&gt;.&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Fission&lt;/em&gt; é uma plataforma de computação serverless para funções-como-serviço que tem
como objetivo principal retirar dos desenvolvedores toda a carga de implantação de
software. Dessa forma, os programadores podem se preocupar apenas com os detalhes da
implementação da lógica de negócio.&lt;/p&gt;
&lt;p&gt;A plataforma garante realizar automaticamente o &lt;em&gt;scale-up&lt;/em&gt; e &lt;em&gt;scale-down&lt;/em&gt; dos recursos
computacionais para executar as funções quando estiverem sobre uma alta ou baixa
utilização. Mais detalhes sobre a plataforma podem ser acessados
&lt;a href=&#34;https://docs.fission.io/docs/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;fission-core-services&#34;&gt;&lt;em&gt;Fission Core Services&lt;/em&gt;&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;O &lt;em&gt;Core Services&lt;/em&gt; tem como principais objetivos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;permitir a implantação de funções dentro da plataforma &lt;em&gt;Fission&lt;/em&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;autorizar o acesso de clientes às funções implantadas;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Para alcançar os objetivos gerais, o &lt;em&gt;Core Services&lt;/em&gt; provê uma API REST que é ponto
de entrada de diversas operações da plataforma. A API permite a realização de CRUD
de funções por desenvolvedores, dessa forma, o &lt;em&gt;Core Services&lt;/em&gt; é o responsável por
interagir com os serviços internos para que a operação seja concluída.&lt;/p&gt;
&lt;p&gt;Além disso, depois de implantada a função pode ser invocada pelos seus clientes.
Neste caso, a API deve rotear as requisições HTTP para as instâncias que executam
o código-fonte da função.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os principais sistemas que interagem com o &lt;em&gt;Core Services&lt;/em&gt;,
assim como as suas responsabilidades.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;eventos-de-entrada&#34;&gt;Eventos de entrada&lt;/h4&gt;
&lt;p&gt;Podemos observar que o &lt;em&gt;Core Services&lt;/em&gt;, como já descrito anteriormente, também funciona
como o &lt;em&gt;Back-end&lt;/em&gt; da &lt;em&gt;Fission&lt;/em&gt;. Os Desenvolvedores e seus Clientes podem interagir
com a plataforma por meio do &lt;em&gt;Front-end&lt;/em&gt; ou do &lt;em&gt;Fission CLI&lt;/em&gt; (um software de linha
de comando).&lt;/p&gt;
&lt;p&gt;Quando os Desenvolvedores realizam a implantação de uma função, a plataforma
disponibiliza um &lt;em&gt;endpoint&lt;/em&gt; que pode ser acessado para invocar a execução da função.
Assim, a forma mais comum dos Clientes interagirem com a plataforma é
pelo disparo de requisições HTTP para invocar funções.&lt;/p&gt;
&lt;h4 id=&#34;eventos-de-saída&#34;&gt;Eventos de saída&lt;/h4&gt;
&lt;p&gt;Como o &lt;em&gt;Core Services&lt;/em&gt; é o ponto de entrada da plataforma, pode ser razoável imaginar
que todos os recursos sejam resolvidos por esse componente, contudo, diversas tarefas
são delegadas para outros componentes.&lt;/p&gt;
&lt;p&gt;Como apresentado no diagrama acima, o &lt;em&gt;Kubernetes&lt;/em&gt; é responsável por gerenciar os
recursos computacionais para permitir que as funções processem requisições dos seus
clientes. Dessa forma, o &lt;em&gt;Core Services&lt;/em&gt; precisa interagir com o Kubernetes para
realizar o CRUD de funções, além de consultar os endereços das réplicas da função
para roteá-las. O &lt;em&gt;Kubernetes&lt;/em&gt; também é o responsável por realizar o escalonamento
das instâncias em execução da função com base na métrica de utilização de CPU.&lt;/p&gt;
&lt;p&gt;Quando um desenvolvedor realiza o &lt;em&gt;deployment&lt;/em&gt; de uma função, o &lt;em&gt;Core Services&lt;/em&gt; se
encarrega de transformar o código-fonte em uma função implantável. Após o processo de
&lt;em&gt;build&lt;/em&gt;, o &lt;em&gt;StorageSVC&lt;/em&gt; é o responsável por armazenar os artefatos de
implantação resultantes. Dessa forma, quando necessário, o &lt;em&gt;Kubernetes&lt;/em&gt; pode recuperar
esses artefatos para criar novas réplicas da função.&lt;/p&gt;
&lt;p&gt;Além disso, o &lt;em&gt;Core Services&lt;/em&gt; também funciona como um &lt;em&gt;Proxy&lt;/em&gt; para serviços externos
que pode ser oferecidos por terceiros dentro da plataforma.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os serviços que compõem o &lt;em&gt;Fission Core Services&lt;/em&gt; assim
como as suas responsabilidades e interações com outros sistemas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Container.png&#34; alt=&#34;containers&#34;&gt;&lt;/p&gt;
&lt;p&gt;Como podemos observar, o &lt;em&gt;Core Services&lt;/em&gt; é composto pelos serviços: &lt;em&gt;Controller&lt;/em&gt;,
&lt;em&gt;Router&lt;/em&gt;, &lt;em&gt;Executor&lt;/em&gt;, &lt;em&gt;Function Pod&lt;/em&gt; e &lt;em&gt;Builder Manager&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;Controller&lt;/em&gt; expõe uma API que pode ser acessada pelos usuários da plataforma
via &lt;em&gt;Fission CLI&lt;/em&gt; ou &lt;em&gt;Fission UI&lt;/em&gt;. O &lt;em&gt;Controller&lt;/em&gt; também funciona como &lt;em&gt;Gateway&lt;/em&gt;
para os serviços internos e externos da plataforma.&lt;/p&gt;
&lt;h4 id=&#34;crud-de-funções&#34;&gt;CRUD de funções&lt;/h4&gt;
&lt;p&gt;Quando o &lt;em&gt;Controller&lt;/em&gt; recebe uma requisição para realizar o &lt;em&gt;CRUD&lt;/em&gt; de funções, ela
é repassada para o &lt;em&gt;Kubernetes&lt;/em&gt; via
&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34;&gt;CRDs&lt;/a&gt;
que armazena informações sobre a função e o seu código-fonte. O &lt;em&gt;Builder Manager&lt;/em&gt;
observa os eventos de &lt;em&gt;CRUD&lt;/em&gt; e dispara o processo de transformar o código-fonte da
função em um artefato executável.&lt;/p&gt;
&lt;p&gt;Após o processo de &lt;em&gt;build&lt;/em&gt; da função, o &lt;em&gt;Builder Manager&lt;/em&gt; armazena os artefatos
resultantes no &lt;em&gt;StorageSVC&lt;/em&gt; para que, posteriormente, possa ser recuperado e usado
na criação de novas réplicas da função.&lt;/p&gt;
&lt;h4 id=&#34;invocação-de-funções&#34;&gt;Invocação de funções&lt;/h4&gt;
&lt;p&gt;Quando o &lt;em&gt;Controller&lt;/em&gt; recebe uma requisição HTTP para disparar a execução de uma
função, ele repassa a responsabilidade para o &lt;em&gt;Router&lt;/em&gt;. O &lt;em&gt;Router&lt;/em&gt; em seguida
consulta o &lt;em&gt;Executor&lt;/em&gt; para saber se existe alguma instância/réplica da função
disponível para processar a requisição recebida. Se existir, o &lt;em&gt;Router&lt;/em&gt; apenas
encaminha a requisição para a réplica. Caso contrário, o &lt;em&gt;Router&lt;/em&gt; requisita ao
&lt;em&gt;Executor&lt;/em&gt; a criação de novas instâncias da função via &lt;em&gt;Function Pod&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Function Pod&lt;/em&gt; é o serviço responsável por carregar e executar uma função, para isso
ele realiza o &lt;em&gt;download&lt;/em&gt; da função executável no &lt;em&gt;StorageSVC&lt;/em&gt;, cria um processo para
a função quee aceita requisições via um servidor HTTP. Dessa forma, o &lt;em&gt;Router&lt;/em&gt; pode
encaminhar as requisições para o servidor HTTP associado à função.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta o diagrama de componentes do serviço &lt;em&gt;Function Pod&lt;/em&gt;
que pertence ao &lt;em&gt;Fission Core Services&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Components.png&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;p&gt;Podemos observar que &lt;em&gt;Function Pod&lt;/em&gt; possui dois componentes principais: &lt;em&gt;Fetcher&lt;/em&gt; e
&lt;em&gt;Environment Container&lt;/em&gt;. O &lt;em&gt;Fetcher&lt;/em&gt; é o responsável por realizar o &lt;em&gt;download&lt;/em&gt;
dos artefatos de &lt;em&gt;deployment&lt;/em&gt; de uma função. Esses artefatos são compartilhados com
o &lt;em&gt;Environment Container&lt;/em&gt; via um &lt;em&gt;Shared Volume&lt;/em&gt;, ou seja, com o protocolo de
comunicação via &lt;em&gt;File System&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Dessa forma, quando o &lt;em&gt;Fetcher&lt;/em&gt; requisita a inicialização da função, o &lt;em&gt;Environment
Container&lt;/em&gt; cria um processo que carrega a função executável, que por meio de um
servidor HTTP pode processar as requisições encaminhadas pelo &lt;em&gt;Router&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;visão-da-informação&#34;&gt;Visão da informação&lt;/h3&gt;
&lt;p&gt;A máquina de estados abaixo apresenta a visão da informação do estado das funções
dentro da plataforma &lt;em&gt;Fission&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Fission-Architecture-Visao-da-Informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
&lt;p&gt;O diagrama expõe os possíveis estados de uma função assim como as possíveis
transições dos estados. Os estados mais importantes são: &lt;strong&gt;Implantada&lt;/strong&gt; e
&lt;strong&gt;Disponível&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Quando uma função está &lt;strong&gt;Implantada&lt;/strong&gt;, significa que os seus artefatos
de implantação estão disponíveis no &lt;em&gt;StorageSVC&lt;/em&gt;, porém não existe nenhuma
réplica/instância da função disponível. Por outro lado, quando uma função está
implantada e existe pelo menos uma réplica da função em execução, então a função
é classificada como &lt;strong&gt;Disponível&lt;/strong&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>fzf - command-line fuzzy finder</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/fzf/</link>
       <pubDate>Wed, 07 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/fzf/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Bruno Roberto Silva de Siqueira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110854&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:bruno.siqueira@ccc.ufcg.edu.br&#34;&gt;bruno.siqueira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----filtro-para-commandline&#34;&gt;Descrição Arquitetural &amp;ndash; Filtro para commandline&lt;/h1&gt;
&lt;p&gt;Este documento - feito através de texto e diagramas aos moldes do &lt;a href=&#34;https://c4model.com&#34;&gt;modelo c4&lt;/a&gt; - descreve o programa para commandline &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;fzf&lt;/a&gt;, sua interação com o shell, outros programas, e até comunicação com plugins.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Importante destacar que haverá um foco apenas no shell unix.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-fzf&#34;&gt;Descrição Geral sobre o fzf&lt;/h2&gt;
&lt;p&gt;O fzf é um programa utilizado para filtrar informações de um input no shell, de maneira interativa, inclusive com suporte a multiseleção e previews.&lt;/p&gt;
&lt;p&gt;Ao receber uma entrada qualquer de texto, invocado o comando &lt;code&gt;fzf&lt;/code&gt;, o usuário pode digitar uma string qualquer para executar uma busca do tipo &lt;a href=&#34;https://en.wikipedia.org/wiki/Approximate_string_matching&#34;&gt;fuzzy&lt;/a&gt;. Filtradas as linhas relevantes, o usuário poderá selecionar a linha desejada, a qual será devolvida ao shell.&lt;/p&gt;
&lt;p&gt;Apesar de aparentemente simplório, todas as operações acima descritas são completamente customizáveis. É possível utilizar regexes, em vez de fuzzy; selecionar múltiplas linhas; executar operações nas linhas antes de devolvê-las ao shell; expor previews; customizar a exibicão das linhas; dentre várias outras customizações.&lt;/p&gt;
&lt;p&gt;Também, por ser um programa de commandline, operando com strings puras, a integracão com outras ferramentas, via plugins, é bastante fácil de ser implementada via sub processos.&lt;/p&gt;
&lt;p&gt;Dados os pontos acima expostos, o fzf é uma ferramenta bastante poderosa para a commandline. Age em muitos casos como uma interface interativa para alguns programas de commandline, um &lt;em&gt;de facto&lt;/em&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Text-based_user_interface&#34;&gt;TUI&lt;/a&gt;, como para &lt;a href=&#34;https://github.com/bigH/git-fuzzy&#34;&gt;git&lt;/a&gt;, &lt;a href=&#34;https://github.com/ms-jpq/sad&#34;&gt;sed&lt;/a&gt;, &lt;a href=&#34;https://medium.com/@calbertts/docker-and-fuzzy-finder-fzf-4c6416f5e0b5&#34;&gt;docker&lt;/a&gt;, entre outros.&lt;/p&gt;
&lt;h2 id=&#34;a-filtragem-interativa&#34;&gt;A filtragem interativa&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um programa que opere com stdin/stdout, permitindo a busca interativa por linhas relevantes no conteúdo de entrada.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A busca e interface devem ser inteiramente customizáveis, permitindo a utilização &lt;strong&gt;com&lt;/strong&gt; e &lt;strong&gt;por&lt;/strong&gt; outros programas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de contexto e um texto curto descrevendo em mais detalhes o contexto do sistema. Isso inclui as fronteiras do sistema, os sistemas/serviços externos com os quais ele se comunica etc.&lt;/p&gt;
&lt;p&gt;Abaixo estão dois exemplos de diagramas de contexto.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;fzf&lt;/code&gt; é um processo que vive inteiramente no terminal. Este pode ser invocado pelo usuário de diversas formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via um pipe, como método de busca e seleção de output: &lt;code&gt;$ comando1 args | fzf | comando2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diretamente, invocando um comando padrão pré-configurado (por default o &lt;code&gt;find&lt;/code&gt;): &lt;code&gt;$ fzf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Via subprocesso, quando algum outro processo shell quer aproveitar seu mecanismo de busca e seleção (ou diretamente pelo usuário neste modo: &lt;code&gt;$ comando $(fzf)&lt;/code&gt;): &lt;code&gt;kill -9 &amp;lt;tab&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Via integração com o próprio shell, a exemplo do &lt;code&gt;bash&lt;/code&gt; e &lt;code&gt;zsh&lt;/code&gt;: &lt;code&gt;vim **&amp;lt;tab&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Por ser uma aplicação shell auto-contida, o &lt;code&gt;fzf&lt;/code&gt; não dispõe de muitos containeres. Apenas podemos dividir a parte gráfica da aplicação, a &lt;em&gt;tui&lt;/em&gt; (&lt;em&gt;terminal user interface&lt;/em&gt;) e sua parte &lt;em&gt;core&lt;/em&gt; - o programa de fato.&lt;/p&gt;
&lt;p&gt;Funcionalidades como argumentos passados pelo usuário, flags, dentre outros, serão geridas pelo &lt;em&gt;core&lt;/em&gt;, via a leitura do comando invocado, em interação direta com o &lt;em&gt;shell&lt;/em&gt;. A &lt;em&gt;tui&lt;/em&gt; apenas desenha gráficos já enviados pelo &lt;em&gt;core&lt;/em&gt;, bem como provê ao usuário feedback para seus filtros, aatual opção selecionada e os previews (enviados prontos pelo &lt;em&gt;core&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O &lt;code&gt;fzf&lt;/code&gt; conta com três componentes principais dentro do seu core: o &lt;em&gt;Terminal&lt;/em&gt;, &lt;em&gt;Matcher&lt;/em&gt; e o &lt;em&gt;EventBox&lt;/em&gt;, porém há muitos outros instanciados na sua execução.&lt;/p&gt;
&lt;p&gt;Apesar de ser o &lt;em&gt;Terminal&lt;/em&gt; que interpreterá os comandos do usuário, e irá expor comandos de renderização para a &lt;em&gt;tui&lt;/em&gt;, estes são intermediados pelo &lt;em&gt;EventBox&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;EventBox&lt;/em&gt; é um componente utilitário que detecta pressionamento de teclas e cliques do usuário na interface gráfica. Os eventos então são observados pelo &lt;em&gt;Terminal&lt;/em&gt; (aqui dito como o componente interno do &lt;code&gt;fzf&lt;/code&gt;), que reage quando algum comando é solicitado por exemplo. Também reage a movimentação do usuário para renderizar novos previews, executar subprocessos, dentre outros.&lt;/p&gt;
&lt;p&gt;Detectadas pressionamentos de teclas &lt;em&gt;char&lt;/em&gt; diretas, é visto que o usuário está executando uma busca, que então é enviada para o &lt;em&gt;Matcher&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;em&gt;Matcher&lt;/em&gt; é quem de fato faz a comunicação com o algoritmo de busca e devolve resultados para a interface, novamente, via eventos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./fzf_components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do OkHttp</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/okhttp/</link>
       <pubDate>Tue, 06 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/okhttp/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;OkHttp&lt;/a&gt;. É importante destacar que não será descrita toda a arquitetura do OkHttp. O foco é a descrição de como é realizado o processo de criação, inicialização e encerramento de uma requisição de rede utilizando os serviços disponibilizados por este projeto.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Adauto Ferreira de Barros Neto.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 114211302&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:adauto.neto@ccc.ufcg.edu.br&#34;&gt;adauto.neto@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----cliente-http-para-android&#34;&gt;Descrição Arquitetural &amp;ndash; Cliente HTTP para Android&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;OkHttp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do OkHttp. O foco aqui é a descrição de um serviço específico de requisições HTTP, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-okhttp&#34;&gt;Descrição Geral sobre o OkHttp&lt;/h2&gt;
&lt;p&gt;HTTP é a maneira que aplicações modernas se comunicam entre si para troca de informações, sendo dados e/ou mídias. Fazer essa conexão da maneira mais eficiente requer bastante esforço, mas traz benefícios tanto de velocidade, como de melhor uso dos recursos disponíveis para a aplicação. O OkHttp é um projeto que implementa um cliente HTTP para Android que busca a eficiência como padrão, sua API de requisições e respostas possui construtores fluidos e imutáveis, suportando chamadas síncronas e assíncronas. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://square.github.io/okhttp/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-cliente-de-requisições-http&#34;&gt;O cliente de requisições HTTP&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um cliente Android eficiente para requisições e respostas HTTP com o interesse em troca de dados e mídia, provendo carregamentos rápidos e economizando larguda de banda.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter uma forma eficiente de realizar chamadas HTTP em sistemas Android. Além disso, desejamos o suporte para chamadas síncronas bloqueantes e assíncronas com &lt;em&gt;callbacks&lt;/em&gt;. Também é de interesse do projeto que haja perseverança quando houver conexões problemáticas, se recuperando silenciosamente de problemas comuns de conexão.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema se resume a um cliente de requisições HTTP, que através de uma URL provida pelo usuário, o cliente Android realiza a conexão com um &lt;em&gt;WebServer&lt;/em&gt; que irá conter informações desejadas pela requisição. Essas informações são acessadas por meio da resposta HTTP que pode encapsular diferentes tipos de dados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.jpg&#34; alt=&#34;context&#34;&gt;&lt;/p&gt;
&lt;p&gt;Para o sistema, todo esse processo é nomeado de &lt;strong&gt;call&lt;/strong&gt; e seus estados serão mais detalhados no decorrer deste documento.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A arquitetura do OkHttp no geral se baseia basicamente na divisão de camadas, onde cada uma é responsável por lidar com uma etapa do processo de requisições HTTP. Sendo essas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interface: A camada de interface é responsável pelo recebimento das requisições fornecidas pelo usuário e realiza a inicialização do processo de requisição de rede;&lt;/li&gt;
&lt;li&gt;Protocolo: Camada que executa o processamento da lógica de protocolos, dando suporte a três tipos: HTTP1, HTTP2 e &lt;em&gt;WebSockets&lt;/em&gt;. Definidos dinamicamente através do cliente configurado;&lt;/li&gt;
&lt;li&gt;Conexão: Trata do processo de estabelecimento da conexão com o &lt;em&gt;WebServer&lt;/em&gt; a partir da URL provida pelo usuário, recuperando conexões existentes ou criando novas conexões;&lt;/li&gt;
&lt;li&gt;Cache: Essa camada opera sobre o sistema de cache de requisições. Quando a requisição de rede realizada pelo usuário possui um cache local que atende a requisição, o OkHttp retorna imediatamente o resultado encontrado no cache;&lt;/li&gt;
&lt;li&gt;Entrada/Saída: Responsável pela leitura e escrita de dados. Esta camada depende totalmente do &lt;a href=&#34;https://github.com/square/okio&#34;&gt;Okio&lt;/a&gt;, uma biblioteca que iniciou sendo apenas um componente do OkHttp para realizar o processo de acessar, guardar e processar dados;&lt;/li&gt;
&lt;li&gt;Interceptadores:  A camada de interceptadores contém vários componentes que operam sobre o sistema a qualquer momento, realizando operações lógicas relevantes para o ponto da execução em que foi chamado. Funcionando de forma semelhante a um sistema com programação orientada a aspectos (POA).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;container.jpg&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para esta seção nos apronfudaremos nos componentes da camada de Interface e de Conexão, pois são as que mais agem sobre o sistema e também sobre as &lt;strong&gt;calls&lt;/strong&gt;.&lt;/p&gt;
&lt;h5 id=&#34;interface&#34;&gt;Interface&lt;/h5&gt;
&lt;p&gt;Como dito anteriormente, essa camada é quem realiza a interação com o usuário, recebendo as inforamções necessárias para iniciar a requisição. Ela é composta por, principalmente, 4 componentes que serão descritos abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Call: A call é uma requisição de rede que foi preparada para execução, cada requisição de rede feita pelo usuário será uma &lt;em&gt;call&lt;/em&gt;. Ela pode ser cancelada, mas por se tratar de um par de requisição e resposta, chamado de &lt;strong&gt;stream&lt;/strong&gt;, não pode ser executada mais de uma vez;&lt;/li&gt;
&lt;li&gt;Request: Usada para descrever a requisição que será iniciada. De acordo com as informações providas pelo usuário, esse componente irá encapsular a URL, o método utilizado, cabeçalho e corpo. Também nesse componente é realizado o controle da cache, independente se for uma requisição HTTPS ou não;&lt;/li&gt;
&lt;li&gt;Client: Usuários podem configurar este componente de várias maneiras. Todas as requisições de rede são realizadas através do cliente, cada cliente mantém sua fila de tarefas e seu &lt;em&gt;pool&lt;/em&gt; de conexões, podendo reutilizar conexões que já foram estabelecidas;&lt;/li&gt;
&lt;li&gt;Dispatcher: Esse é o componente que contém a fila de tarefas utilizada pelo Client, mantendo um pool de &lt;em&gt;threads&lt;/em&gt; internamente. Quando uma &lt;em&gt;call&lt;/em&gt; é recebida, o Dispatcher é responsável por encontrar &lt;em&gt;threads&lt;/em&gt; que estejam ociosas e executar com a nova &lt;em&gt;call&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;conexão&#34;&gt;Conexão&lt;/h5&gt;
&lt;p&gt;Essa camada é responsável pela conexão de rede. Aqui também encontramos um &lt;em&gt;pool&lt;/em&gt; de conexões, porém que trata apenas as conexões via &lt;em&gt;socket&lt;/em&gt;. Quando o usuário inicia o processo de requisição de rede, OkHttp vai primeiramente procurar em seu &lt;em&gt;pool&lt;/em&gt; de conexões se existe alguma que atenda aos requisitos. Caso sim, irá enviar requisições diretamente pela conexão que já existe, caso não exista, uma nova conexão é estabelecida para o envio das requisições.&lt;/p&gt;
&lt;p&gt;A partir da introdução de multiplexação completa de solicitação e resposta em HTTP2, o &lt;em&gt;pool&lt;/em&gt; de conexões presente nessa camada busca fazer o mesmo com as conexões via &lt;em&gt;socket&lt;/em&gt;, mantendo várias &lt;strong&gt;RealConnection&lt;/strong&gt; que possibilitam múltiplas requisições de conexões de rede. Com isso, também houve a introdução do &lt;strong&gt;StreamAllocation&lt;/strong&gt; para descrever a carga de requisições. Uma RealConnection representa uma ou mais &lt;em&gt;StreamAllocation&lt;/em&gt;, podendo ser considerado um contador de conexões, quando esse contador alcançar zero, a &lt;em&gt;StreamAllocation&lt;/em&gt; será liberada caso não seja ocupada por novas requisições depois de muito tempo.&lt;/p&gt;
&lt;p&gt;Para a criação de novas conexões, esta camada utiliza o componente de &lt;strong&gt;DNS&lt;/strong&gt; para descobrir o endereço IP do servidor e o &lt;strong&gt;Route&lt;/strong&gt; para testar e selecionar qual deverá ser usado. Após tudo ser definido, irá utilizar o &lt;strong&gt;ConnectionSpec&lt;/strong&gt; para especificar a configuração da conexão &lt;em&gt;socket&lt;/em&gt; em que a requisição HTTP irá ser transportada, em caso de conexão HTTPS, isso também irá incluir a versão TLS e o conjunto de criptografia usada para negociação de conexão segura.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.jpg&#34; alt=&#34;components&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Uma &lt;strong&gt;call&lt;/strong&gt; é o que carrega a requisição HTTP e sua resposta dentro do OkHttp, esse elemento do sistema passa por várias etapas e algumas delas estão descritas abaixo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Usa a URL que foi provida pelo Android juntamente com o cliente configurado para criar um &lt;strong&gt;endereço&lt;/strong&gt;. Esse endereço é quem especifica como é feita a conexão com o servidor &lt;em&gt;web&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Tenta recuperar uma conexão com esse endereço que já tenha sido utilizada;&lt;/li&gt;
&lt;li&gt;Se não encontrar uma conexão reutilizável, uma rota é selecionada para a tentativa de conexão. Isso significa fazer uma requisição DNS para obter o endereço de IP do servidor;&lt;/li&gt;
&lt;li&gt;Caso seja uma nova rota, ela será conectada utilizando ou SDP, ou túnel TLS (para requisições HTTPS), ou conexão TLS direta. Também faz um TLS handshake.&lt;/li&gt;
&lt;li&gt;Envia a requisição HTTP e lê a resposta.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;info.jpg&#34; alt=&#34;info&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural do VS Code</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/vscode/</link>
       <pubDate>Tue, 06 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/vscode/</guid>
       <description>&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;
&lt;img src=&#34;logo-vscode-2.png&#34; style=&#34;border-radius: 80px&#34;/&gt;
&lt;/a&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Gabriel Almeida Azevedo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210009&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:gabriel.almeida.azevedo@ccc.ufcg.edu.br&#34;&gt;gabriel.almeida.azevedo@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/microsoft/vscode&#34;&gt;https://github.com/microsoft/vscode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural-do-vs-code&#34;&gt;Descrição Arquitetural do VS Code&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura do projeto &lt;a href=&#34;https://github.com/microsoft/vscode&#34;&gt;VS Code&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do VS Code. O foco aqui é a descrição do seu núcleo central, parte fundamental do projeto. Componentes satélites como o Chrome Debug Core, NLS Tools, CSS/LESS/SCSS Language Service e ESLint possuem seu próprio repositório e não serão abordados profundamente neste documento. Para ver a lista completa de projetos relacionados acesse o link &lt;a href=&#34;https://github.com/microsoft/vscode/wiki/Related-Projects&#34;&gt;Related Projects&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-vs-code&#34;&gt;Descrição Geral sobre o VS Code&lt;/h2&gt;
&lt;p&gt;O Visual Studio Code, ou simplesmente VS Code, é um editor de código que foi lançado em 2015 pela Microsoft. É uma ferramenta de código aberto voltada para o desenvolvimento de aplicações web, mobile e de cloud. O Visual Code se baseia no Electron (framework usada para desenvolver aplicativos Node.js). O seu conjunto de utilitários faz com que ele concorra de igual para igual com ferramentas pagas existentes no mercado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seus pontos de Destaque são:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;É Multiplataforma;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;multiplataforma.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;É Multilinguagem: Suporta mais de 30 linguagens de programação além de formatos comuns de arquivos;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;É Personalizável;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;É uma aplicação leve;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apresenta uma excelente paleta de atalhos: além da seus atalhos, é possível alterar para os atalhos reconhecidos pelo Sublime e pelo Atom;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Permite adicionar extensões;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possui o IntelliSense: Recurso de preenchimento de código que permite listar métodos, obter informações de parâmetros, completar palavras.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;intelliSense.gif&#34; alt=&#34;intelliSense&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral-do-vs-code&#34;&gt;Objetivo Geral do VS Code&lt;/h3&gt;
&lt;p&gt;Fornecer um editor de código simples que cubra as necessidades dos desenvolvedores nas 3 fases de desenvolvimento: codificação, criação do artefato e depuração.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Prover uma ferramenta poderosa para o desenvolvedor, que tenha uma edição de código abrangente, navegação e suporte de compreensão, depuração leve, um modelo de extensibilidade rico e integração leve com ferramentas existentes.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O VS Code é uma aplicação que roda em sistemas windows, macOS e Linux. Esta aplicação tem como base para sua UI(interface de usuário), o framework Electron, e interage com o sistema de versionamento do &lt;strong&gt;&lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-contexto-vscode-plat.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Através da API de extensões é possível customizar todo o VS Code. Os serviços de linguagem e de depuração são tratados como uma classe especial de Extensões.&lt;/p&gt;
&lt;p&gt;O serviço de Linguagens é dividido em 2 partes: o client (extensão VS Code) escrito em JavaScript/TypeScript e o Server (ferramenta de análise de linguagem executada em um processo separado). O Client cria uma instância do Server da linguagem correspondente e se comunica através do LSP. Este serviço permite a experiência de edição para muitas linguagens de programação. Pode-se implementar autocomplete, verificação de erros (diagnóstico), salto para definição e muitos outros recursos de linguagem suportados no VS Code.&lt;/p&gt;
&lt;p&gt;Com o serviço de depuração os autores de extensão podem integrar facilmente depuradores ao VS Code. O VS Code provê uma interface de usuário comum à todos eles.&lt;/p&gt;
&lt;p&gt;A interface de versionamento de arquivos permite criar/trocar de branch, adicionar/remover arquivos à um commit, solucionar conflitos, atualizar a branch remota, entre outras funcionalidades.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers-vscode-2.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Vale salientar que o VS Code é uma aplicação grande. Foi escolhido apenas 2 containers para serem expandidos e, ainda assim, só uma amostra dos seus componentes está no diagrama.&lt;/p&gt;
&lt;p&gt;Abrindo o container de Extensões tem-se como principais componentes o &lt;em&gt;Extension Gallery Service&lt;/em&gt; que provê a listagem de extensões disponíveis para usuário juntamente com suas descrições e changelogs. A partir dessa listagem o usuário pode escolher fazer o download de uma extensão. O componente responsável por este papel é o &lt;em&gt;Extension Downloader&lt;/em&gt; que baixa a extensão desejada e repassa os arquivos para o &lt;em&gt;Extension Management Service&lt;/em&gt; que por sua vez tem a responsabilidade de averiguar se a extensão é confiável, realizar sua instalação e registro.&lt;/p&gt;
&lt;p&gt;O container do Editor possui vários componentes mas sem dúvida o &lt;em&gt;Text Change&lt;/em&gt; faz parte do seu núcleo. Ele é responsável por realizar toda e qualquer alteração nos arquivos e interage fortemente com o componente &lt;em&gt;Diff Computer&lt;/em&gt;. Ambos componentes são utilizados pelo versionador do VS Code. Existe ainda o &lt;em&gt;Cursor Delete Operations Controller&lt;/em&gt; e o &lt;em&gt;Find Controller&lt;/em&gt; que invocam o &lt;em&gt;Text Change&lt;/em&gt; para realizar as alterações/remoções de código.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes-vscode.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O container responsável pela parte de edições e versionamento de arquivos é o &lt;em&gt;Editor&lt;/em&gt;.&lt;br&gt;
Para o diagrama de estados de um &lt;em&gt;Arquivo&lt;/em&gt; no VS Code, tem-se 3 possibilidades iniciais: criar um arquivo, editar um arquivo ou ainda remover um arquivo.&lt;/p&gt;
&lt;p&gt;Pontos que devem ser mencionados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ao criar um arquivo e definir sua extensão o VS Code invoca o Serviço de Linguagens para verificar se já existe em seu ambiente uma conexão com o server da extensão do arquivo criado;&lt;/li&gt;
&lt;li&gt;Ao editar um arquivo, pode-se alterar o código manualmente, usar atalhos de cursor, o que envolve seus respectivos controllers (ex: Cursor Delete Operations Controller) e o find/replace. Cada um desses modos invocará o componente &lt;em&gt;Text Change&lt;/em&gt; para efetivar a mudança;&lt;/li&gt;
&lt;li&gt;Sempre que tenta-se excluir um arquivo que está aberto ou em raschunho, o VS Code pergunta se essa ação deverá ser realmente realizada, se sim, ele exclui o arquivo e fecha sua janela de edição;&lt;/li&gt;
&lt;li&gt;Pode-se, ou não, usar o VS Code para versionar seu arquivo. Isto é feito através do componente &lt;em&gt;Versionador&lt;/em&gt; (trata questões de branch, diffs, commits, conflitos, pull/pushs e merges) que se integra ao &lt;strong&gt;GitHub&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-informacao-vscode.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Até o presente momento ainda não foi aberto nenhum pull request desta documentação para o &lt;a href=&#34;https://github.com/microsoft/vscode-docs/&#34;&gt;repositório&lt;/a&gt; de docs do VS Code.&lt;/em&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural para o Comunidades.tech</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/comunidadestech/</link>
       <pubDate>Mon, 05 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/comunidadestech/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autora&#34;&gt;Autora&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Raquel Ambrozio da Fonseca.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210531&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:raquel.fonseca@ccc.ufcg.edu.br&#34;&gt;raquel.fonseca@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech&#34;&gt;https://github.com/universoimpulso/comunidadestech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----comunidadestech&#34;&gt;Descrição Arquitetural &amp;ndash; Comunidades.tech&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura de parte do sistema &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech&#34;&gt;Comunidades.tech&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que será considerado apenas as principais funcionlidades do Comunidades.tech, ou seja, elementos específicos do sistema e suas implementações não serão detalhados.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-comunidadestech&#34;&gt;Descrição Geral sobre o Comunidades.tech&lt;/h2&gt;
&lt;p&gt;O Comunidades.tech é um projeto open source desenvolvido pela comunidade da &lt;a href=&#34;https://impulso.network/entrar?referral=comunidadestech&#34;&gt;Impulso.Network&lt;/a&gt;, que tem como objetivo ser um espaço de visibilidade e fortalecimento das comunidades de tecnologia. O sistema pode ser acessado &lt;a href=&#34;https://comunidades.tech/&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;comunidadestech&#34;&gt;Comunidades.tech&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um sistema para divulgar comunidades nacionais relacionadas a tecnologia, sendo essas vituais ou presenciais.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos cadastrar e publicar comunidades de tecnologia, levando em consideração suas principais caracteríticas, como tipo (Discord, Meetup, Slack, etc) e categoria (Desenvolvimento de Software, Infraestrutura, Dados, Games, etc ). Por fim, disponibilizar essas comunidades em um catálogo com seus devidos dados, para que as pessoas consigam encontrar (utilizando os filtros) comunidades de seu interesse de maneira rápida e prática.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O sistema Comunidades.tech utiliza a API do LinkedIn como login para manter o cadastro e fazer a autenticação do usuário. Esse &lt;strong&gt;usuário&lt;/strong&gt; pode ser classificado nas seguintes categorias:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pessoa que representa uma ou mais comunidades&lt;/strong&gt; e deseja cadastrar e divulgar sua(s) comunidade(s);&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pessoa que quer participar de comunidade(s)&lt;/strong&gt; e deseja buscar e visualizar comunidades do seu interesse;&lt;/li&gt;
&lt;li&gt;Ambos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As informações das comunidades cadastradas são maninpuladas pelo Back-end do sistema Comunidades.tech, e armazenadas em um Banco de Dados mantido pelo mesmo.&lt;/p&gt;
&lt;p&gt;Abaixo está o diagrama de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OBS&lt;/strong&gt;: Além do LinkedIn, também pode ser utilizada uma conta do Google para realizar o cadastro do usuário, mas, por questões de simplificação, esse detalhe não foi ilustrado.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O sistema Comunidades.tech é uma aplicação que pode ser dividida basicamente em três grandes partes (containers):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O &lt;strong&gt;Front-end&lt;/strong&gt; (implementado utilizando React.JS): é a parte que o usuário interage através do seu navergador web para acessar as funcionalidades do sistema;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;Back-end&lt;/strong&gt; (implementado utilizando Node.JS): é responsável pela lógica de negócios;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Banco de Dados&lt;/strong&gt; (MongoDB): onde os dados sobre os usuários e as comunidades cadastradas/publicadas são armazenados;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abaixo está o diagrama de containers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Os &lt;strong&gt;containers&lt;/strong&gt; estão &lt;strong&gt;executando/implantandos&lt;/strong&gt; na plataforma em núvem &lt;strong&gt;Heroku&lt;/strong&gt;. E toda comunicação é feita via API-REST em formato JSON utilizando protocolos HTTPS.&lt;/p&gt;
&lt;p&gt;Alguns serviços da API são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adicionar uma comunidade cadastrada;&lt;/li&gt;
&lt;li&gt;Recuperar informações de uma comunidade cadastrada;&lt;/li&gt;
&lt;li&gt;Deletar uma comunidade cadastrada.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Os principais componentes da API do sistema Comunidades.tech estão descritos a seguir:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Login&lt;/strong&gt;: componente responsável pelo login dos usuários no sistema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Segurança&lt;/strong&gt;: componente responsável por funcionalidades relacionadas ao login, mudança de senhas, etc;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cadastro de Usuário&lt;/strong&gt;: componente responsável pelo cadastro de um usuário no sistema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cadastro de Comunidade&lt;/strong&gt;: componente responsável pelo cadastro de uma comunidade;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Edição dos Dados da Comunidade&lt;/strong&gt;: componente responsável pela atualização dos dados das comunidades cadastradas pelo usuário;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dashboard&lt;/strong&gt;: componente responsável pela vizualização de todas as comunidades cadastradas do usuário.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A seguir está o diagrama de componentes ilustrando os componentes supracitados.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-componentes.svg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O objetivo do sistema é divulgar comunidades, por isso, entender o fluxo das informações relacionadas com o procedimento de cadastro até a divulgação dessas comunidades é muito importante.&lt;/p&gt;
&lt;p&gt;O primeiro passo para conseguir publicar uma comunidade é fazer parte do Comunidades.tech, ou seja, ter um cadastrado ativo no sistema. Após o login, é possível visualizar um botão &amp;ldquo;Casdastre uma comunidade&amp;rdquo;, clicando nele, será aberta a página de cadastro com alguns formulários que solicitam informações como: nome, localização, membros e links. Após o preenchimento dos quatro formulários, e concluída a revisão dos dados preenchidos, basta clicar no botão &amp;ldquo;Criar Comunidade&amp;rdquo;, e acomunidade será cadastrada. Logo pós o cadastro, automaticamente a comunidade será encaminhada para análise, onde  ocorre a validação dos dados. Finalmente, a depender do resultado da análise, a comunidade será aprovada e publicada no catálogo de comunidades.&lt;/p&gt;
&lt;p&gt;A seguir está o diagrama de máquina de estados para descrever os estados do procedimento de publicação de uma comunidade.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;diagrama-maquina-estados.jpeg&#34; alt=&#34;fig&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Para a realização de contribuições acessei o repositório onde está localizado o projeto Comunidades.tech, fiz o fork do projeto, clonei o reposítório, criei uma branch chamada architectural-documentation. Na raiz do projeto, criei um arquivo Markdown chamado architectural-documentationn e uma pasta (com o mesmo nome) para armazenar as imagens utilizadas no Markdown. Por fim, copiei, colei e salvei o conteúdo desse documento (exceto as seções código e contribuições concretas) no arquivo criado. Fiz o commit, o push e realizei o pull request. O pull request pode ser visualizado &lt;a href=&#34;https://github.com/universoimpulso/comunidadestech/pull/247&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Após revisão do código enviado, foi solicitado que fosse alterado o modo de contato (que estava com um e-mail acadêmico), para o link do meu perfil no GitHub. Logo depois que a alteração foi concluída e submetida, o &lt;strong&gt;pull request foi aceito&lt;/strong&gt; (16/10/2020).&lt;/p&gt;
&lt;h1 id=&#34;referências&#34;&gt;Referências&lt;/h1&gt;
&lt;p&gt;Todo conteúdo desse documento foi baseado no estudo do código do repositório do projeto, juntamente com informações adicionais adquiridas através de integrantes da &lt;a href=&#34;https://impulso.network/entrar&#34;&gt;comunidade da Impulso Network&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação da arquitetura do navegador Brave</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/brave-browser/</link>
       <pubDate>Sun, 04 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/brave-browser/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Luiggy Ferreira Dias Silva.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117211159&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:luiggy.silva@ccc.ufcg.edu.br&#34;&gt;luiggy.silva@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/brave/brave-core&#34;&gt;https://github.com/brave/brave-core&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----navegador-brave&#34;&gt;Descrição Arquitetural &amp;ndash; Navegador Brave&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do navegador &lt;a href=&#34;https://github.com/brave/brave-core&#34;&gt;Brave&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-navegador-brave&#34;&gt;Descrição Geral sobre o navegador Brave&lt;/h2&gt;
&lt;p&gt;O Brave é um navegador que tem como principal diferencial o pagamento de tokens aos usuários que visualizam as propagandas definidas pelo navegador utilizando uma moeda própria por meio da blockchain, além disso, possui um bloqueador de anúncios e rastreadores nativos que propõem mais privacidade ao usuário.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Brave é um navegador de internet que conta com um bloqueador de rastreadores e anúncios integrados e um sistema de recompensa para os usuários que visualizam suas propragandas (privadas). Essa recompensa é entregue via uma &lt;a href=&#34;https://basicattentiontoken.org/&#34;&gt;moeda virtual&lt;/a&gt; própia do navegador, e para armazenar essa moeda o navegador oferece uma conta no sistema financeiro da &lt;a href=&#34;https://uphold.com/pt/homepage&#34;&gt;Uphold&lt;/a&gt; que trabalha com criptomoedas e as principais moedas do mundo. O Brave também tem integrado o sitema da exchange &lt;a href=&#34;https://www.binance.com/en&#34;&gt;Binance&lt;/a&gt;, permitindo compra, venda de ativos e a verificação de saldos diretamente de um widget oficial dentro do navegador. O Brave também oferece nativamente a opção de usar o buscador &lt;a href=&#34;https://duckduckgo.com/about&#34;&gt;DuckDuckGo&lt;/a&gt; fruto de uma parceria com o sistema.&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Brave pode ser utilizado na sua versão Desktop e também em sua versão Mobile, compartilhando das principais funcionalidades. Ambas versões possuem um database para armazenar os dados do navegador.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O diagrama acima contém os principais componentes do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Browser:&lt;/em&gt; Responsável pela funcionalidade principal de possibilitar o acesso a internet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Search_Engines:&lt;/em&gt; Responsável por disponibilizar os buscadores para o Brave. Esse componente que se relaciona com o buscador parceiro do Brave, o &lt;a href=&#34;https://duckduckgo.com/about&#34;&gt;DuckDuckGo&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Binance:&lt;/em&gt; Responsável por se conectar com o sistema externo da Exchange &lt;a href=&#34;https://www.binance.com/en&#34;&gt;Binance&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Ads:&lt;/em&gt; Responsável por gerenciar as propagandas do navegador.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Rewards:&lt;/em&gt; Responável por gerenciar as recompensas pelas visualizações das propagandas do Brave. Esse componente se relaciona com o sistema da &lt;a href=&#34;https://uphold.com/pt/homepage&#34;&gt;Uphold&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Brave_Shields:&lt;/em&gt; Responsável por bloquear anúncios e rastreadores dos sites que o usuário visita.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;brave-diagrama-maquina_de_estados_extens%C3%B5es.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;p&gt;A máquina de estados acima representa os possíveis estados que as &lt;em&gt;extensões&lt;/em&gt; do navegador podem assumir. Uma &lt;em&gt;extensão&lt;/em&gt;, após ser instalada, é automaticamente habilitada e o usuário pode desabilitar ou desinstalar a extensão.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Serenata de Amor - Documentação arquitetural </title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/serenata-de-amor/</link>
       <pubDate>Sun, 04 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/serenata-de-amor/</guid>
       <description>&lt;hr&gt;
&lt;img src=&#34;./logo.png&#34; style=&#34;width: 50%; display: flex; margin: 0 auto;&#34;/&gt;
&lt;p&gt;Projeto de auditoria automática para a cota de auxílio parlamentar de reembolsos para gastos.&lt;/p&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Nicácio Oliveira de Sousa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115111897&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:nicacio.sousa@ccc.ufcg.edu.br&#34;&gt;nicacio.sousa@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor&#34;&gt;https://github.com/okfn-brasil/serenata-de-amor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor&#34;&gt;Serenata de Amor&lt;/a&gt; e tem como base o modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que este documento visa expor de forma mais abstrata como funciona o conjunto de ferramentas da aplicação e não necessariamente explicará em detalhes a sua implementação.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-serenata-de-amor&#34;&gt;Descrição Geral sobre o Serenata de Amor&lt;/h2&gt;
&lt;p&gt;O serenata de amor é um projeto que visa &lt;a href=&#34;https://brasil.elpais.com/brasil/2017/01/23/politica/1485199109_260961.html&#34;&gt;auditar gastos públicos&lt;/a&gt; relacionados a cota de auxílio parlamentar a qual é utilizada pelos parlamentares para requerirem reembolsos dos gastos que são relacionados a função parlamentar. Um reembolso pela cota parlamentar pode ser requerido para qualquer tipo de atividade do parlamentar como o gasto com alimentação, passagens aéreas, combustível, aluguéis, assinaturas etc.&lt;/p&gt;
&lt;p&gt;A função de auditar a veracidade dos pedidos de reembolso pode ser uma tarefa inumana pela quantidade de pedidos todos os meses e a quantidade de variáveis envolvidas. O Serenata de Amor automatiza esse procedimento de auditoria para criar alertas sobre notas fiscais com valores duvidosos e auxiliar esse trabalho de forma muito mais barata e rápida.&lt;/p&gt;
&lt;h4 id=&#34;mas-como-isso-é-feito&#34;&gt;Mas como isso é feito?&lt;/h4&gt;
&lt;p&gt;O projeto possui dois grandes módulos. Um &lt;a href=&#34;https://twitter.com/RosieDaSerenata&#34;&gt;(Rosie)&lt;/a&gt; para auditar notas fiscais de pedidos de reembolsos e outro &lt;a href=&#34;https://jarbas.serenata.ai/&#34;&gt;(Jarbas)&lt;/a&gt; para listar os dados auditados de forma fácil.&lt;/p&gt;
&lt;p&gt;Em geral, um usuário precisa acionar a Rosie para que, com base em dados anteriores e já avaliados, ela classifique dados entregues pelo governo federal a cada mês e em seguida insira o conjunto de dados classificados no banco de dados do Jarbas para que ele exiba-os e também crie alertas no twitter sobre casos suspeitos.&lt;/p&gt;
&lt;h4 id=&#34;rosie&#34;&gt;Rosie&lt;/h4&gt;
&lt;p&gt;Robô que tem sua construção baseada na &lt;a href=&#34;https://github.com/okfn-brasil/serenata-toolbox&#34;&gt;toolbox do serenata de amor&lt;/a&gt;.
A Rosie faz auditoria em notas fiscais que são cadastradas na base de dados do governo federal e classifica cada nota com uma flag de suspeita ou não.&lt;/p&gt;
&lt;p&gt;A classificação das notas é feita com base em diversas de variáveis como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gastos exagerados com alimentação, combustível, passagens etc&lt;/li&gt;
&lt;li&gt;Estar em dois lugares ao mesmo tempo&lt;/li&gt;
&lt;li&gt;Valores exorbitantes em localidades que cobram um valor diferente do que a nota fiscal diz&lt;/li&gt;
&lt;li&gt;Valores superfaturados&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O processo, em uma visão modular, é simples. A Rosie é alimentada com dados previamente classificados em mêses e anos anteriores, é feito um treinamento em um modelo para que ele seja utilizado para classificar dados futuros.&lt;/p&gt;
&lt;h4 id=&#34;jarbas&#34;&gt;Jarbas&lt;/h4&gt;
&lt;p&gt;Painel de controle que exibe os dados auditados pela Rosie de forma organizada.
O Jabas também é responsável por criar posts de alerta no twitter, indicando pedidos de reembolso suspeitos.&lt;/p&gt;
&lt;h2 id=&#34;serviço-de-auditoria-de-cotas-parlamentares&#34;&gt;Serviço de auditoria de cotas parlamentares&lt;/h2&gt;
&lt;h3 id=&#34;objetivo&#34;&gt;Objetivo&lt;/h3&gt;
&lt;p&gt;Implementar um serviço que possa auditar notas fiscais cadastradas na base de dados do governo federal que sejam relacionadas a cota de gastos parlamentares e relacionar cada nota à variáveis que indiquem se cada uma delas é suspeita de fraude ou não.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Treinar modelos, com base em dados auditados anteriormente, para classificação de cada nota fiscal que for utilizada para pedidos de reembolso para indicar se cada nota pode ser considerada suspeita e interagir em rede social criando alertas sobre gastos suspeitos através do módulo Jarbas.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;A comunicação e contexto gerais dos sitema acontecem entre os dois elementos principais (Rosie e Jarbas) em conjunto com a publicação de mensagens com alertas no twitter.&lt;/p&gt;
&lt;p&gt;Os dados devem ser lidos da base de dados do governo federal referente a dados de cota parlamentar. Em seguida, a Rosie deve ser ativada para classificar os dados de acordo com as regras que conhece e indicar se a nota fiscal atrelada ao pedido de reenbolso é suspeita. Por fim, o banco de dados do Jarbas deve ser alimentado com os novos dados classificados pela Rosie e então o Jarbas irá lista-los e criar posts de tempos em tempos para todas as suspeitas encontradas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.svg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A Rosie é constituída por um conjunto de classificadores de notas fiscais de pedidos de reembolso. É basicamente um módulo python que utiliza Scikit para criar classificadores.&lt;/p&gt;
&lt;p&gt;Classificadores:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Despesas eleitorais&lt;/li&gt;
&lt;li&gt;Empresas irregulares no lançamento das notas fiscais&lt;/li&gt;
&lt;li&gt;Despesas com refeições&lt;/li&gt;
&lt;li&gt;Limite de subcota parlamentar mensal&lt;/li&gt;
&lt;li&gt;Gastos com combustível&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Em uma visão mais detalhada dos containers, podemos entender como se dá a comunicação dos dois módulos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers-rosie-jarbas.svg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;A implantação do sistema é feita em &lt;a href=&#34;https://www.digitalocean.com/products/droplets/&#34;&gt;Droplets da Digital Ocean&lt;/a&gt; e não há muitos detalhes aqui a não ser observar os arquivos de configuração docker-compose que definem quais serviços serão instanciados no Droplet da Digital Ocean.&lt;/p&gt;
&lt;p&gt;Apenas o jarbas deve permanece online 24 horas por dia. Por simplicidade, a Rosie é acionada apenas algumas vezes ao mês de forma manual e a base de dados do Jarbas é atualizada com os dados novos também manualmente.&lt;/p&gt;
&lt;p&gt;O Jarbas é apenas um dashboard que expõe os dados classificados e que não chegam na casa dos milhões. Logo, a arquitetura de implantação deve-se manter simples pois traz baixo custo e facilidade de implantação.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A Rosie utiliza como base o conjunto de ferramentas da Toolbox e é organizada em pacotes relativos a cada tipo de classificação que será feita.
No momento atual, a câmara dos deputados é o principal ponto de análise e todos os outros módulos que venham a ser criados devem seguir o mesmo padrão, então vamos focar apenas no módulo de classificação da câmara dos deputados.&lt;/p&gt;
&lt;p&gt;Cada pacote de classificadores utiliza o sklearn para treinar um modelo utilizando como base dados que foram classificados e resolvidos anteriormente. Assim, quanot mais o tempo passar, cada vez mais a Rosie irá criar modelos para classificação mais aprimorados.&lt;/p&gt;
&lt;p&gt;A Visão mais abstrata dos componentes da Rosie pode ser visualizada em seguida:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes-rosie.svg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;O Jarbas, por simplicidade é apenas um serviço Python-Django que lê a lista de dados de reembolso e expõe uma ai simples para busca e filtro dessa listagem.
Além de sua função de listagem e filtro, o jarbas cria posts no twitter para denunciar pedidos que estejam classificados como suspeitos e marca-os como denunciados.&lt;/p&gt;
&lt;p&gt;O único caso particular que teremos aqui é a limitação da quantidade de posts por hora da api do Twitter que é utilizada pelo jarbas. Há um &lt;a href=&#34;https://developer.twitter.com/en/docs/twitter-api/v1/rate-limits#:~:text=Standard%20API%20v1.&amp;amp;text=You%20can%20only%20post%20300,id%20endpoint%20during%20that%20period.&#34;&gt;limite&lt;/a&gt; e ele é considerado na criação dos posts.&lt;/p&gt;
&lt;p&gt;Cada dado de reembolso carrega a informação do ID do requerente e links para detalhes que são apontados para o sistema do governo federal.&lt;/p&gt;
&lt;p&gt;A API exposta pelo Jarbas é apenas uma rota com opcionais de filtragem para visualização dos dados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement/&amp;lt;document_id&amp;gt;/receipt/&lt;/li&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement/&amp;lt;document_id&amp;gt;?&lt;filtros&gt;&lt;/li&gt;
&lt;li&gt;GET /api/chamber_of_deputies/reimbursement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Os filtros em forma de query que podem ser utilizados podem ser visualizados no &lt;a href=&#34;https://github.com/okfn-brasil/serenata-de-amor/tree/main/jarbas#json-api-endpoints&#34;&gt;repositório oficial do projeto&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Os componentes do jarbas são os seguintes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes-jarbas.svg&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;As informações mais importantes para o funcionamento do Serenata de Amor são basicamente todas as informações ligadas à um pedido de reembolso:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pedido de Reembolso&lt;/li&gt;
&lt;li&gt;Nota Fiscal&lt;/li&gt;
&lt;li&gt;Empresa (CNPJ, Endereço etc)&lt;/li&gt;
&lt;li&gt;Parlamentares&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abaixo podemos entender alguns pontos idispensáveis para a compreensão do uso da informação no sistema.&lt;/p&gt;
&lt;h4 id=&#34;dados-de-estabelecimentos-com-localização-e-dados-relacionados-ao-cadastro-de-pessoa-jurídica-no-governo-federal&#34;&gt;Dados de estabelecimentos com localização e dados relacionados ao cadastro de pessoa jurídica no governo federal.&lt;/h4&gt;
&lt;p&gt;A Rosie precisa entender qual tipo de estabelecimento, se ele está cadastrado na base de dados do governo federal e qual a região onde se localiza para aprender sobre qual valor de despesa é considerado normal.&lt;/p&gt;
&lt;h4 id=&#34;dados-de-cada-parlamentar-ligado-a-cada-pedido-de-reembolso&#34;&gt;Dados de cada parlamentar ligado a cada pedido de reembolso&lt;/h4&gt;
&lt;p&gt;Além da importâcia de entender qual o parlamentar requerente, é interessante que o Jarbas conheça esse dado para criar alertas e faça associação ao parlamentar no twitter.&lt;/p&gt;
&lt;h4 id=&#34;dados-que-foram-auditados-anteriormente&#34;&gt;Dados que foram auditados anteriormente&lt;/h4&gt;
&lt;p&gt;Para o passo inicial do sistema a Rosie necessita de um conjunto de dados previamente classificados/auditados que indique os dois estados de um pedido de reembols. Logo, os dados gerados até o momento do iníio da rosie servem de base de treinamento para o modelo de classificação e posteriormente serão somados a esse conjunto de dados os dados auditados pela prória Rosie para continuar aumentando a acurácia das classificações da Rosie.&lt;/p&gt;
&lt;h4 id=&#34;fluxo-da-informação-no-jarbas-para-postagem-de-alertas-no-twitter&#34;&gt;Fluxo da informação no Jarbas para postagem de alertas no twitter&lt;/h4&gt;
&lt;p&gt;Por mais que seja simples, um diagrama de estados nos ajuda a manter claro como isso deve ser feito no twitter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;fluxo-de-alerta-jarbas.svg&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural do Jenkins</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/jenkins/</link>
       <pubDate>Fri, 02 Oct 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/jenkins/</guid>
       <description>&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Cássio Cordeiro.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116210038&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:cassio.cordeiro@ccc.ufcg.edu.br&#34;&gt;cassio.cordeiro@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/jenkinsci/jenkins&#34;&gt;https://github.com/jenkinsci/jenkins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do &lt;a href=&#34;https://github.com/jenkinsci/jenkins&#34;&gt;Jenkins&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição&#34;&gt;Descrição&lt;/h2&gt;
&lt;p&gt;O Jenkins é projeto focado em ser expansível às necessidades dos usuários, contendo um vasto acervo de plugins criados e permitindo configurações personalizadas, suas principais usos são para atividades de  CI (continuous integration) e CD (continuous delivery). Ele automatiza as partes do processo de desenvolvimento de software relacionadas ao build, testes, deploy e entrega. Outras informações podem ser encontradas no site oficial do sistema.&lt;/p&gt;
&lt;h3 id=&#34;objetivos&#34;&gt;Objetivos&lt;/h3&gt;
&lt;p&gt;Oferecer um serviço que seja customizável e expansível aos requisitos dos projetos e de cada usuário, automatizando tarefas repetitivas no processo de desenvolvimento de software.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Os principais sistemas que o Jenkins se comunica são seus plugins, que quando instalados, acrescentam mais funcionalidades ao sistema e a possibilidade de comunicação com outros sistemas; o Git, podendo realizar processos com projetos hospedados nele; e serviços de comunicação, sendo capaz de enviar mensagens, contento, principalmente, o resultado de operações de build.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;contexto.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O sistema é composto basicamente por dois containers: a interface web e a aplicação (API). O primeiro, possibilita interação com o usuário, é feito usando Jelly e renderizado do lado do servidor. Já o segundo, gerencia toda a parte de projetos, de dados e comunicação externa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Abaixo estão alguns exemplos de como são processados os paths:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get: /log/… → Jenkins#getLog()
&lt;ul&gt;
&lt;li&gt;Busca o arquivo log do sistema.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Get com argumentos: /job/foo/… → Hudson#getJob(“foo”)
&lt;ul&gt;
&lt;li&gt;Busca um job chamado foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Get dinâmico: /job/foo/1/… → Job#getDynamic(“1” &amp;hellip;)
&lt;ul&gt;
&lt;li&gt;Busca o build 1 do job foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Método de ação: /job/foo/1/artifact → Run#doArtifact(&amp;hellip;)
&lt;ul&gt;
&lt;li&gt;Executa o método doArtifact no build 1 do job foo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quanto à implantação, o Jenkins pode ser instalado em qualquer máquina. Ele possui compatibilidade com os principais sistemas operacionais, Linux, MacOS e Windows, além de poder ser instalado usando o Docker ou na nuvem.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O sistema é composto por 6 componentes principais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Componente de segurança: seu principal papel é prover autenticação e controle de acesso aos recursos. Ele recebe do gerenciador de usuários as informações necessárias para prover seus serviços.&lt;/li&gt;
&lt;li&gt;Gerenciador de usuários: realiza todo o controle de usuário, como cadastro, atualização e controle de permissões. Os dados são lidos e escritos usando o controlador de dados.&lt;/li&gt;
&lt;li&gt;Gerenciador de plugins: controla tudo relacionado aos plugins.&lt;/li&gt;
&lt;li&gt;Gerenciador de projetos: responsável pelo gerenciamento das ações relacionadas aos projetos, por conectar com o git e enviar notificações.&lt;/li&gt;
&lt;li&gt;Controlador de dados: escreve e lê os dados do sistema de arquivos, utilizando o XStream. Fornece dados para outros componentes.&lt;/li&gt;
&lt;li&gt;Componente de estatísticas: utiliza o histórico das builds dos projetos para criar estatísticas e indicar tendências.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Todas as informações giram em torno dos projetos. Os usuários recebem permissões para visualizar, editar e realizar ações neles. Durante o build são executadas as pipelines, caso ocorra algum erro, a build entra no estado de erro, caso contrário, de sucesso. Cada resultado é armazenado no histórico e utilizado para gerar informações estatísticas dos projetos.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Fila da Creche - Documento arquitetural</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/sme-fila-da-creche/</link>
       <pubDate>Wed, 15 Apr 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/sme-fila-da-creche/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Mateus de Lima Oliveira.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110219&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:mateus.oliveira@ccc.ufcg.edu.br&#34;&gt;mateus.oliveira@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/prefeiturasp/SME-FilaDaCreche&#34;&gt;https://github.com/prefeiturasp/SME-FilaDaCreche&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural&#34;&gt;Descrição Arquitetural&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/prefeiturasp/SME-FilaDaCreche&#34;&gt;Fila de Creche&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.
É importante destacar que este documento visa expor de forma mais abstrata como funciona o conjunto de ferramentas da aplicação e não necessariamente explicará em detalhes a sua implementação.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-fila-de-creche&#34;&gt;Descrição Geral sobre o Fila de Creche&lt;/h2&gt;
&lt;p&gt;O Fila da Creche é um projeto com iniciativa da Secretaria Municipal de Educação de São Paulo que busca facilitar o acompanhamento de geração de vagas na educação infantil de acordo com localização e faixa etária informadas. Mais detahes sobre o projeto podem ser vistos &lt;a href=&#34;https://educacao.sme.prefeitura.sp.gov.br/entenda-como-funciona-a-plataforma-vaga-na-creche/&#34;&gt;nesse link&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar, com transparência ativa, em linguagem simples e com acessibilidade digital, uma ferramenta para que os pais e famílias possam se programar e acompanhar a geração de vagas na educação infantil pela Secretaria Municipal de Educação de São Paulo.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Permitir que a qualquer pessoa saber como está a espera por atendimento nos Centros de Educação Infantil (CEIs), de acordo com o endereço fornecido e a faixa etária informada. Ela pode ser acessada por qualquer dispositivo móvel (como celular) ou computador com acesso à internet, sem precisar de instalação (download), assim evitando desinformações e locomoção dos responsáveis.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Como vemos no diagrama abaixo, o Fila da Creche é composto pelo frontend e uma API que fornece acessa os dados disponíveis em uma base de dados das matrículas na cidade de São Paulo, que são requisitados utilizando o protocolo HTTP.
De modo geral, o sistema funciona como um facilitador, entre o usuário e as bases de dados citadas, em que simplifica e filtra a obtenção de determinada informação de acordo com as informações passadas.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;fig1-contexto.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Visão da informação do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O Fila da Creche é composto pelos três containers que serão descritos a seguir.&lt;/p&gt;
&lt;p&gt;O primeiro deles é a Web Page, feita em React, que é responsável por pela interação com os usúarios do sistema e pela representação gráfica do sistema, ou seja, todo o HTML que o browser irá interpretar e renderizar para o usuário final.&lt;/p&gt;
&lt;p&gt;O Banco de Dados é o container responsável por armazenar, de forma estruturada, todas as informações extraídas por meio do Airflow do banco de dados do Sistema Escola Online - EOL, onde tem as informações sobre o sistema de matricula múnicipal. Ele foi implementado em PostgreSQL e outros containers utilizam Psycopg.&lt;/p&gt;
&lt;p&gt;O container API, é um conjunto de rotinas e padrões de programação para acesso das bases de dados do Fila da Creche. Ela foi implementada em Python juntamente com o framework Flask. Foram utilizados padrões REST e o acesso a esta API se dá por meio de requisições HTTP em formato JSON. Alguns dos endpoints disponíveis estão descritos a seguir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; /v1/schools/radius/&lt;a href=&#34;string:lon&#34;&gt;string:lon&lt;/a&gt;/&lt;a href=&#34;string:lat&#34;&gt;string:lat&lt;/a&gt;&#39;&lt;/p&gt;
&lt;p&gt;Descrição: Retorna as escolas/creches em um raio de distância (1,5 KM) do ponto passado pela latitude &lt;strong&gt;(lat)&lt;/strong&gt; e longitude &lt;strong&gt;(lon)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; /v1/schools/radius/wait/&lt;a href=&#34;string:lon&#34;&gt;string:lon&lt;/a&gt;/&lt;a href=&#34;string:lat&#34;&gt;string:lat&lt;/a&gt;/&lt;a href=&#34;int:groupCode&#34;&gt;int:groupCode&lt;/a&gt;&#39;&lt;/p&gt;
&lt;p&gt;Descrição: Retorna as escolas/creches em um raio de distância (1,5 KM) do ponto passado pela latitude &lt;strong&gt;(lat)&lt;/strong&gt; e longitude &lt;strong&gt;(lon)&lt;/strong&gt; com o tamanho das filas de espera para matrículas baseado no grupo da criança (definido a partir da idade).&lt;/p&gt;
&lt;p&gt;O diagrama apresentado abaixo descreve os containers que compõem o Fila de Creche.&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;fig2-containers.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Visão da informação do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;A fim de detalhamento, podemos dividir o container Frontend outros dois componentes: Utils e Pages.&lt;/p&gt;
&lt;p&gt;O componente Utils, que usa Javascript, é composto por ações de verificação de registros, responsabilidade de fazer requests a API e calculos internos que são utilizados em páginas HTML, compondo de forma fragmentada, funcionalidades para interação do usuário no sistema. Pages, que usa React, faaz o recebimento dos dados dos usuários e fornece os dados solicitados sobre as vagas e creches em mapas.
Outro componente incluido para maior detalhamento é o Airflow, que contém DAGs (Directed Acyclic Graph) internas para trazer dados de do banco de dados municipal para o do Fila da Creche.&lt;/p&gt;
&lt;p&gt;Logo abaixo, temos o diagrama de componentes para o Fila da Creche:&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;fig3-componentes.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Visão da informação do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como sabemos, a principal funcionalidade do projeto Fila da Creche é apresentar informações sobre o preenchimento de vagas em creches de São Paulo. Dessa forma, nesta seção abordaremos de maneira simplificada, o percurso habitual que os usuários percorrem na busca das informações disponibilizadas pela aplicação em estudo.&lt;/p&gt;
&lt;p&gt;Na página inicial, o usuário se encontra uma breve apresentação da plataforma e, logo em seguida, duas caixas de seleção para mês e ano de nascimento da criança e um campo para digitar a rua e número de residência. A contulta pose ser feita quando os três campos forem preenchidos.&lt;/p&gt;
&lt;p&gt;Após ser clicado no botão de consultar, é feito o recebimento dos dados e ,se bem-sucedida, mostrada as informações ao usuário, que pode voltar a página inicial e refazer a consulta. Caso o recebimento de dados não seja de sucesso, como por exemplo ocorra algum problema com conexão/internet, a mesma página de sucesso é exibida porém sem nenhum dos dados de vagas e creches requisitados.&lt;/p&gt;
&lt;p&gt;Vejamos abaixo, uma máquina de estados que ilustra fluxo da informação da aplicação estudada, para principais interações de um usuário:&lt;/p&gt;
&lt;div align=&#34;center&#34; style=&#34;margin: 2rem 0;&#34;&gt;
    &lt;img src=&#34;fig4-estados.png&#34;&gt;
    &lt;span style=&#34;display:block;&#34;&gt;
        Visão da informação do Dispatch
    &lt;/span&gt;
&lt;/div&gt;
</description>
     </item>
   
     <item>
       <title>Instruções para escrever o post</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/instrucoes/</link>
       <pubDate>Tue, 07 Apr 2020 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/instrucoes/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Por favor, leia com cuidado as instruções abaixo.&lt;/p&gt;
&lt;h1 id=&#34;o-que-você-deve-produzir&#34;&gt;O que você deve produzir?&lt;/h1&gt;
&lt;p&gt;Um documento de descrição arquitetural. &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/&#34;&gt;Neste link&lt;/a&gt; estão as instruções sobre formato e sobre o que é preciso em cada seção do documento. Por favor, mantenha o formato que estabeleci.&lt;/p&gt;
&lt;h1 id=&#34;como-escrever-o-documento&#34;&gt;Como escrever o documento?&lt;/h1&gt;
&lt;p&gt;Você vai escrever em Markdown, que é uma linguagem simples de marcação. Não se preocupe se não souber a sintaxe, pois você pode, por exemplo, basear a escrita no Markdown que gerou este post (&lt;a href=&#34;https://raw.githubusercontent.com/joaoarthurbm/arqsoft-blog/master/content/posts/documento-guia.md&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Markdown é bem simples de entender e há muito material sobre markdown na web.&lt;/p&gt;
&lt;h1 id=&#34;onde-escrever&#34;&gt;Onde escrever?&lt;/h1&gt;
&lt;p&gt;Nós vamos usar este repositório: &lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog&#34;&gt;https://github.com/joaoarthurbm/arqsoft-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Você terá que submeter o markdown (e as figuras que produziu) como Pull Requests.&lt;/p&gt;
&lt;p&gt;Este pull request que você fará, será revisado por mim e, quando aceito, automaticamente vira um post em &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog/&#34;&gt;https://joaoarthurbm.github.io/arqsoft-blog/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;como-fazer&#34;&gt;Como fazer?&lt;/h1&gt;
&lt;h2 id=&#34;pré-quisitos&#34;&gt;Pré-quisitos&lt;/h2&gt;
&lt;p&gt;Você precisa instalar o hugo na sua máquina. Veja este link: &lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;https://gohugo.io/getting-started/installing/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;passo-a-passo&#34;&gt;Passo a passo&lt;/h2&gt;
&lt;h3 id=&#34;setup-gitgithub&#34;&gt;Setup git/github&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Faça um fork do projeto &lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog&#34;&gt;https://github.com/joaoarthurbm/arqsoft-blog&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Faça clone do repositório e dos submodulos &lt;a href=&#34;https://github.com/SEU-USUARIO/arqsoft-blog/&#34;&gt;https://github.com/SEU-USUARIO/arqsoft-blog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone --recurse-submodules https://github.com/SEU-USUARIO/arqsoft-blog.git&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crie uma branch cujo nome será o seu login @ccc&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch NOME.SOBRENOME&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mude para a branch que você acabou de criar&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout NOME.SOBRENOME&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;produzindo-conteúdo&#34;&gt;Produzindo conteúdo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Entre na pasta &lt;code&gt;content/posts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd content/posts&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nesta pasta estarão os documentos de vocês. Aqui você deve criar um arquivo e um diretório:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O markdown do seu documento.
Use o nome do projeto que você está documentando. Por exemplo: &lt;code&gt;instagram.md&lt;/code&gt;. Este documento é onde você vai escrever o conteúdo da sua descrição arquitetural. Veja um exemplo de markdown que eu gerei (&lt;a href=&#34;https://github.com/joaoarthurbm/arqsoft-blog/blob/master/content/posts/documento-guia.md&#34;&gt;link&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;um diretório com o mesmo nome que você deu ao markdown (exceto pela extensão). No exemplo que tratei, seria um diretório chamado &lt;code&gt;instagram&lt;/code&gt;. Neste diretório estarão as imagens que você usará no seu documento (as que são referenciadas no markdown).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Verifique se o seu post está bem formatado.&lt;/p&gt;
&lt;p&gt;2.1 Vá para a raiz do projeto.&lt;/p&gt;
&lt;p&gt;2.2 execute &lt;code&gt;hugo server&lt;/code&gt; ou &lt;code&gt;docker compose up -d&lt;/code&gt;. A versão do hugo que uso é a v0.75.1.&lt;/p&gt;
&lt;p&gt;2.3 Verifique o seu post em &lt;code&gt;http://localhost:1313/arqsoft-blog/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Observe que agora você pode mudar o markdown e ver o resultado sempre. O hugo fica monitorando atualizações nos arquivos e atualiza sempre que um arquivo for modificado.&lt;/p&gt;
&lt;h1 id=&#34;como-entregar&#34;&gt;Como entregar?&lt;/h1&gt;
&lt;p&gt;Simples. Faça um Pull Request do markdown e do diretório de figuras que você criou. Eu revisarei e, assim que for aceito, seu post estará publicado em &lt;a href=&#34;https://joaoarthurbm.github.io/arqsoft-blog&#34;&gt;https://joaoarthurbm.github.io/arqsoft-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Importante.&lt;/strong&gt; Faça apenas um Pull Request com todo o conteúdo do seu post.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação arquitetural para a plataforma freeCodeCamp</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/free-code-camp/</link>
       <pubDate>Tue, 29 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/free-code-camp/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Arthur Silva Lima Guedes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 118110410&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:arthur.guedes@ccc.ufcg.edu.br&#34;&gt;arthur.guedes@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/freeCodeCamp/freeCodeCamp&#34;&gt;https://github.com/freeCodeCamp/freeCodeCamp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----freecodecamp&#34;&gt;Descrição Arquitetural &amp;ndash; freeCodeCamp&lt;/h1&gt;
&lt;p&gt;Este documento descreve a arquitetura da plataforma &lt;a href=&#34;https://github.com/freeCodeCamp/freeCodeCamp&#34;&gt;freeCodeCamp&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que o foco nessa descrição são os módulos &lt;em&gt;api-server&lt;/em&gt;, &lt;em&gt;client&lt;/em&gt; e parte do módulo &lt;em&gt;tools&lt;/em&gt;, mais especificamente o &lt;em&gt;search-index&lt;/em&gt;, do repositório acima.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-freecodecamp&#34;&gt;Descrição Geral sobre o freeCodeCamp&lt;/h2&gt;
&lt;p&gt;freeCodeCamp é uma comunidade sem fins lucrativos com o propósito de ajudar no processo de aprendizagem de desenvolvimento de software. Através de uma plataforma web de aprendizagem interativa (e outros meios como fóruns e posts), milhares de pessoas tem a oportunidade de aprender sobre desenvolvimento web, análise de dados, &lt;em&gt;machine learning&lt;/em&gt;, entre diversos outros assuntos, tudo isso de forma 100% gratuita. Algumas respostas para perguntas frequentes podem ser encontradas &lt;a href=&#34;https://www.freecodecamp.org/news/about/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;a-plataforma-de-freecodecamp&#34;&gt;A plataforma de freeCodeCamp&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar uma plataforma de aprendizagem interativa que torne acessível aos usuários assuntos das mais diversas áreas da computação.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;É de extremo interesse acompanhar o progresso do aluno em relação ao &lt;em&gt;curriculum&lt;/em&gt; (similar a um guia de conteúdos), o quanto o mesmo está progredindo nas lições e nos desafios.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de contexto do sistema. Nele, temos um usuário que, em nosso contexto, é descrito como o estudante (ou potencial estudante) da área de programação. A plataforma freeCodeCamp usa o AWS SES (um dos sistemas externos) para o envio de emails para os estudantes, além de um sistema de pagamentos (o PayPal) para os usuários que desejam realizar doações para ajudar a comunidade.&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;contexto.png&#34; alt=&#34;Diagrama de contexto - freeCodeCamp&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Abaixo, observamos o diagrama de container para a plataforma freeCodeCamp:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;container.png&#34; alt=&#34;Diagrama de container - freeCodeCamp&#34;&gt;&lt;/p&gt;
&lt;p&gt;A partir da imagem acima, infere-se que o container &lt;strong&gt;freeCodeCamp-Client&lt;/strong&gt; (parte da aplicação que é executada no lado do cliente; o frontend) é acessado diretamente pelo usuário do sistema. O container &lt;strong&gt;API-Server&lt;/strong&gt; expõe uma &lt;em&gt;API REST&lt;/em&gt; que será usada pelo &lt;em&gt;client&lt;/em&gt; para ter acesso a toda parte executada no servidor. A API ainda usa um banco de dados NoSQL, para operações de escrita e leitura (em relação aos schemas). Abaixo, tem-se uma descrição mais detalhada dos containers explicitados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;freeCodeCamp-Client: Nesse container, são executadas funções solicitadas pelo cliente. É responsável também por lidar com os eventos desencadeados pelas ações do usuário. Além disso, renderiza os componentes que, juntos, constroem as páginas da plataforma e fornecem para o usuário um ambiente interativo e prático. Comunica-se com a API usando o protocolo &lt;em&gt;HTTP&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;API-Server: Container que engloba toda a parte do servidor da aplicação. Define os models, rotinas de inicialização do sistema, templates para emails, etc. Além disso, preocupa-se com a lógica de aspectos como autenticação (usando &lt;em&gt;OAuth&lt;/em&gt;) e doações. Como dito acima, esse container fornece uma API REST para ser, consequentemente, consumida pelo container do Client.&lt;/li&gt;
&lt;li&gt;search-indexing: Container responsável por fazer o &lt;em&gt;fetch&lt;/em&gt; de dados como &lt;em&gt;challenges&lt;/em&gt;, &lt;em&gt;posts&lt;/em&gt; da comunidade e &lt;em&gt;playlists&lt;/em&gt; do YouTube. Expõe uma API REST que é usada pelo container da API-Server, o qual manipula de fato os dados extraídos.&lt;/li&gt;
&lt;li&gt;Database: Container que provê um armazenamento para os dados do sistema, como as informações dos usuários. A aplicação usa o &lt;em&gt;Compose&lt;/em&gt;, uma plataforma &lt;em&gt;cloud database&lt;/em&gt;, que torna o gerenciamento da DB mais prático e fácil. O banco de dados usado aqui é o Mongo, um banco de dados não relacional (NoSQL). O MongoDB no compose é oferecido através do serviço de &lt;em&gt;cloud&lt;/em&gt; da IBM.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sobre a implantação do sistema, os containers freeCodeCamp-Client, API-Server e search-indexing traduzem-se em máquinas virtuais na núvem, providas pela plataforma Azure. Detalhes dos pipelines de testes de aceitação e CI podem ser vistos com mais detalhes através dos seguintes links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.azure.com/freeCodeCamp-org/freeCodeCamp/_build&#34;&gt;Azure DevOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/github/freeCodeCamp/freeCodeCamp/branches&#34;&gt;Travis CI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Abaixo, é possível observar o diagrama de componentes do sistema:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;Diagrama de componentes - freeCodeCamp&#34;&gt;&lt;/p&gt;
&lt;p&gt;No diagrama, tem-se a expansão de três containers do sistema:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No freeCodeCamp-Client, temos um componente responsável por renderizar os dados que formam as páginas, o Renderizador, além do Controlador de Pesquisa, responsável por implementar uma lógica para pesquisa de posts a partir do que foi digitado pelo usuário no campo de busca;&lt;/li&gt;
&lt;li&gt;No container API-Server, tem-se diversos componentes:
&lt;ul&gt;
&lt;li&gt;Inicializador de Sessão e Controlador de Autenticação: os componentes responsáveis pelo &lt;em&gt;Sign in&lt;/em&gt; do usuário no sistema. Como descrito no diagrama, os usuários são aptos, caso não queiram fazer um cadastro completo, a acessarem a plataforma usando suas contas do Google, por exemplo (OAuth). O controlador de autenticação é responsável por realizar as verificações dos dados fornecidos pelos usuários;&lt;/li&gt;
&lt;li&gt;Buscador do Currículo: componente responsável por buscar o guia de conteúdos da plataforma (currículo, como é chamado);&lt;/li&gt;
&lt;li&gt;Extrator de Challenges: componente que extrai os challenges propostos no currículo;&lt;/li&gt;
&lt;li&gt;Gerador de Certificado: componente que gera o certificado do usuário após o mesmo concluir os desafios propostos em determinado módulo do curso;&lt;/li&gt;
&lt;li&gt;Controlador de Doações: componente que comunica-se com o sistema externo explicitado para que os usuários possam fazer doações, caso desejem;&lt;/li&gt;
&lt;li&gt;Controlador de envio de emails: Componente que, usando um serviço externo, implementa a lógica para envio dos emails da plataforma;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;O container search-indexing possui componentes que, em síntese, funcionam como um &lt;em&gt;fetcher&lt;/em&gt;, responsáveis por buscar os dados do canal do YouTube, guias de lições, posts e challenges;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;As lições, juntamente com os desafios que as acompanham, são parte fundamental da aplicação. A partir dessas que os usuários podem ter uma ideia de como estão se saindo no curso e como está a curva de aprendizado. Abaixo, temos uma descrição textual e um diagrama que representa os estados dessa informação.&lt;/p&gt;
&lt;p&gt;Após a lição ser postada, ela pode ser selecionada pelo usuário e então, entra em um estado de resolução. Quando o usuário julga que conseguiu resolver o desafio proposto, ele solicita a execução dos testes automáticos, o que leva a lição para um estado de teste. Se o teste falha, o usuário entende que precisa rever a resolução e tentar uma nova abordagem, ou seja, a lição volta para o estado de resolução. Caso a resolução passe pelos testes, a lição é marcada automaticamente como concluída.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;informacao.png&#34; alt=&#34;Máquina de estados - freeCodeCamp&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Documentação Arquitetural - Beats</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/beats/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/beats/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este documento tem por finalidade descrever a plataforma &lt;a href=&#34;https://www.elastic.co/pt/beats/&#34;&gt;&lt;em&gt;Beats&lt;/em&gt;&lt;/a&gt; sob diversos níveis (visões) arquiteturais. Em verdade, &lt;em&gt;Beats&lt;/em&gt; descreve um conjunto de serviços ou &lt;em&gt;agentes&lt;/em&gt; para exportação de dados em alta escala de fontes heterogêneas.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Emanuel Joívo Bezerra Martins.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 116110919&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:emanuel.martins@ccc.ufcg.edu.br&#34;&gt;emanuel.martins@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/elastic/beats&#34;&gt;https://github.com/elastic/beats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----data-shippers&#34;&gt;Descrição Arquitetural &amp;ndash; Data shippers&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura da plataforma &lt;a href=&#34;https://www.elastic.co/pt/beats/&#34;&gt;&lt;em&gt;Beats&lt;/em&gt;&lt;/a&gt;, atentando o olhar nos core &lt;a href=&#34;https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html&#34;&gt;&lt;em&gt;shippers&lt;/em&gt;&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-beats&#34;&gt;Descrição Geral sobre o Beats&lt;/h2&gt;
&lt;p&gt;O Beats é uma plataforma que tem como objetivo &amp;ldquo;capturar todo tipo de dado operacional tais quais logs, métricas ou dados de pacote de rede&amp;rdquo; e assim criar um workflow padronizado de envio para plaformas de agregação e indexação de dados como, respectivamente, o &lt;a href=&#34;https://www.elastic.co/pt/logstash&#34;&gt;&lt;em&gt;logstash&lt;/em&gt;&lt;/a&gt; e o &lt;a href=&#34;https://www.elastic.co/pt/what-is/elasticsearch&#34;&gt;&lt;em&gt;elasticsearch&lt;/em&gt;&lt;/a&gt; podendo, posteriormente, obter uma visualização de tais dados via um dashboard como o &lt;a href=&#34;https://www.elastic.co/pt/kibana&#34;&gt;&lt;em&gt;kibana&lt;/em&gt;&lt;/a&gt;. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://github.com/elastic/beats&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;data-shippers---agentes-de-dados-de-finalidade-única&#34;&gt;Data shippers - Agentes de dados de finalidade única&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementação de uma plataforma para coleta e envio automáticos de dados a partir de fontes de dados específicas e heterogêneas. Tais dados são comumente gerados por outros sistemas, ou seja, são dados operacionais tais quais logs, métricas, informações de tráfego de rede, eventos de sistema etc.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;A intenção parece ser a de abstrair a extração de dados através de agentes com interfaces padronizadas para a coleta de dados de sistemas heterogêneos e envio desses em larga escala para plataformas de agregação tais quais o logstash e o elasticsearch para análise e pesquisa centralizada e simplificada.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Em linhas gerais, esse sistema pretende estruturar uma plataforma para coleta e envio de dados de fontes específicas tais quais métricas de sistemas e serviços, eventos, logs, etc. O core do sistema está no componente libbeat que descreve uma interface de mais alto nível os quais os &lt;em&gt;beats&lt;/em&gt; têm de satisfazer, além de prover canais de comunicação e protocolos de recuperação de falha na troca de mensagens. Por essa arquitetura quase como um Lego, ou &lt;em&gt;building blocks&lt;/em&gt; novos &lt;em&gt;Data Shippers&lt;/em&gt; podem ser criados ou os existentes customizados, tendo em vista que é um projeto Open Source, de modo a satisfazer um caso de uso não esperado pelos &lt;em&gt;Data Shippers&lt;/em&gt; core. Todo o input do sistema é gerado através das coletas dos dados via os &lt;em&gt;beats&lt;/em&gt;, enviados para a libbeat que por sua vez redireciona tanto para o logstash quanto para o elasticsearch, no segundo caso, ficando assim disponível para consulta/buscas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Cada Beat é simplesmente um binário Go que é instalado no servidor alvo de onde se quer exportar dados. Por exemplo,o &lt;a href=&#34;https://www.elastic.co/beats/winlogbeat&#34;&gt;WinlogBeat&lt;/a&gt;, &lt;em&gt;Shipper&lt;/em&gt; que coleta logs de eventos de sistemas Microsoft Windows precisa estar instalado no server. Cada Beat se comunica com um cluster Elasticsearch e/ou Logstash para exportação dos dados e, por conseguinte, a visualização dos mesmos via chamadas HTTP/REST como segue no diagrama abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Para esta sessão, escolheu-se o &lt;em&gt;zoom&lt;/em&gt; em um Beat em específico para detalhamento de seus componentes internos. Filebeat é um &lt;em&gt;shipper&lt;/em&gt; para coleta e exportação de logs de sistema ou de serviços.
Segue abaixo diagrama de componente do Filebeat.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;components.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Retomando o caso do Filebeat, a informação em questão são logs produzidos por sistemas e/ou serviços.
Após a especificação dos arquivos de logs no Input, o Filebeat vai manter seus Harvesters assistindo a mudanças nos arquivos e coletando as atualizações. Após isso, cada Harvester publica as mudanças no Spooler que por sua vez envia os eventos dos logs em batch numa única transação por vez.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;information.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Exemplo de documento a ser produzido</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/documento-guia/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento guia para os alunos de Arquitetura de Software. A ideia é apresentar o modelo de documentação arquitetural que espero que seja produzido por eles. Esse guia foi baseado em um projeto chamado Parlametria, cujos detalhes arquiteturais estão descritos &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;O documento que você, aluno, deve produzir, deve seguir às diretrizes abaixo. Naturalmente, você pode adicionar, remover e alterar o formato, mas minha sugestão é que você mantenha o padrão que estou apresentando, inclusive, a mesma ordem e nomes de seções. Isso facilitará não só a padronização da documentação produzida por vocês.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por João Arthur Brunet.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 857394857&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:joao.arthur@computacao.ufcg.edu.br&#34;&gt;joao.arthur@computacao.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/analytics-ufcg/parlametria-site&#34;&gt;https://github.com/analytics-ufcg/parlametria-site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-análise-do-twitter&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de análise do twitter&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/analytics-ufcg/parlametria-site&#34;&gt;Parlametria&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar não será descrita toda a arquitetura do Parlametria. O foco aqui é a descrição de um serviço específico de análise do twitter, que é parte fundamental do projeto.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-parlametria&#34;&gt;Descrição Geral sobre o Parlametria&lt;/h2&gt;
&lt;p&gt;O parlametria é um projeto que tem como objetivo &amp;ldquo;permitir o acompanhamento do posicionamento de cada deputado e senador nas votações, quais os seus vínculos e afinidades políticas e econômicas dentro e fora do Legislativo.&amp;rdquo; Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://portal.ufcg.edu.br/ultimas-noticias/1706-plataforma-desenvolvida-na-ufcg-monitora-acoes-do-legislativo-federal.html&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-monitoramento-do-twitter&#34;&gt;O Serviço de monitoramento do twitter&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para capturar automaticamente o que é dito no twitter sobre as proposições que acompanhamos e prover indicadores sobre as publicações para serem usados no parlametria.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter acesso ao grau de atividade no twitter de parlamentares e de influenciadores do debate no twitter. Além disso, queremos saber quanto essas pessoas tuítam sobre cada proposição ou tema e a indicadores sobre sua atividade. Para parlamentares também queremos indicadores a partir dos léxicos de discurso desenvolvidos pelos nossos parceiros.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de contexto e um texto curto descrevendo em mais detalhes o contexto do sistema. Isso inclui as fronteiras do sistema, os sistemas/serviços externos com os quais ele se comunica etc.&lt;/p&gt;
&lt;p&gt;Abaixo estão dois exemplos de diagramas de contexto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;img class=&#34;center&#34; src=&#34;parlametria-contexto.png&#34; style=&#34;width:60%&#34;&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de containers e  texto descrevendo os containers. Detalhe no nível que achar necessário, mas é importante saber do que se trata cada container, suas tecnologias, APIs expostas, protocolos, onde são executados/implantados etc. Você pode criar um diagrama de implantação para dar mais detalhes sobre o ambiente em que os containers são implantados e executam. Essa parte de implantação pode ser uma subseção desta seção.&lt;/p&gt;
&lt;p&gt;Importante, se um componente expor, por exemplo, uma API REST. Seria importante descrever os principais serviços. Talvez até com exemplos de payloads (jsons) para os serviços mais importantes. Ver seção endpoints &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;deste documento&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Importante, se um container expuser, por exemplo, uma API REST, seria importante descrever os principais serviços. Talvez até com exemplos de payloads (jsons) para os serviços mais importantes. Ver seção endpoints &lt;a href=&#34;https://docs.google.com/document/d/1OGPN7crENY5u9AiR_AE7Cb9rT92T-U-YppZL0m4TT2s/edit?usp=sharing&#34;&gt;deste documento&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Abaixo estão exemplos de diagramas de containers e de implantação.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-containers.png&#34; alt=&#34;fig3&#34;&gt;
&lt;img src=&#34;parlametria-container.png&#34; alt=&#34;fig4&#34;&gt;
&lt;img src=&#34;c4-implantacao.png&#34; alt=&#34;fig5&#34;&gt;
&lt;img src=&#34;parlametria-implantacao.png&#34; alt=&#34;fig6&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;Nesta seção eu espero duas coisas: o diagrama de componentes e texto descrevendo os componentes. Detalhe no nível que achar necessário, mas é importante saber do que se trata cada componente, seus relacionamentos, tecnologias, APIs expostas, protocolos, estilos, padrões etc.&lt;/p&gt;
&lt;p&gt;Abaixo um exemplo de diagrama de componente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;c4-componentes.png&#34; alt=&#34;fig7&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Aqui você deve descrever as informações importantes que são coletadas, manipuladas, armazenadas e distribuídas pelo sistema. Você não precisa descrever todas as informações, somente uma parte que seja essencial para o sistema. Por exemplo, se eu estivesse tratando do instagram, faria algo relacionado aos posts.&lt;/p&gt;
&lt;p&gt;Além da descrição gostaria de ver aqui um diagrama para descrever os estados (ex: máquina de estados) de uma informação de acordo com as ações do sistema.&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Descreva&lt;/em&gt; aqui os PRs enviados para o projeto e o status dos mesmos. Forneça os links dos PRs.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Mini-projeto 1</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/monitor-cidadao/</link>
       <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/monitor-cidadao/</guid>
       <description>&lt;hr&gt;
&lt;h1 id=&#34;autor&#34;&gt;Autor&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Beatriz Bezerra de Souza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117110233&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:beatriz.souza@ccc.ufcg.edu.br&#34;&gt;beatriz.souza@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----serviço-de-predição-de-risco-de-contratos-públicos&#34;&gt;Descrição Arquitetural &amp;ndash; Serviço de predição de risco de contratos públicos&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;Monitor Cidadão&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É importante destacar que não será descrita toda a arquitetura do Monitor Cidadão. O foco aqui é a descrição de um serviço específico de predição de risco de contratos públicos.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-monitor-cidadão&#34;&gt;Descrição Geral sobre o Monitor Cidadão&lt;/h2&gt;
&lt;p&gt;O Monitor Cidadão é um projeto que tem como objetivo &amp;ldquo;possibilitar aos cidadãos o acompanhamento dos contratos realizados pelos municípios dos estados da Paraíba e do Rio Grande do Sul&amp;rdquo;. Mais detalhes sobre o projeto podem ser vistos &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-predição-de-risco-de-contratos-públicos&#34;&gt;O Serviço de predição de risco de contratos públicos&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Implementar um serviço para receber dados e realizar predição de risco de contratos públicos para serem usados no Monitor Cidadão.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Queremos ter acesso a dados, provenientes de diferentes fontes, relacionados a contratos públicos. Além disso, queremos estimar o risco associado a contratos públicos. Para nós, o conceito de risco está associado a chance que um contrato possui de ser &lt;em&gt;rescindido&lt;/em&gt;, &lt;em&gt;paralisado&lt;/em&gt;, &lt;em&gt;sustado&lt;/em&gt; ou &lt;em&gt;impedido&lt;/em&gt;. E as características dos contratos são construídas a partir do comportamento passado e dados cadastrais das empresas responsáveis pelos contratos.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O Monitor Cidadão é composto por três camadas: dados, back-end, e front-end, como apresentado no diagrama de contexto abaixo.&lt;/p&gt;
&lt;p&gt;A camada de dados recebe dados de serviços externos, trata os dados recebidos, e realiza previsões sobre os riscos associados a contratos. Atualmente, os provedores de dados para o Monitor Cidadão são Sagres, TCE-RS, IBGE, e Tramita.&lt;/p&gt;
&lt;p&gt;O back-end recebe os dados tratados e as previsões e os repassa para o front-end, que exibe as informações em um formato mais compreensível para os usuários.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;context.png&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os containers do Monitor Cidadão. A camada de dados, que contém o serviço de predição que queremos descrever, é composta por cinco componentes: um fetcher, um transformador, um preditor, e dois bancos de dados.&lt;/p&gt;
&lt;p&gt;O fetcher, o transformador, e o preditor são sistemas desenvolvidos em R. Os dois bancos de dados são relacionais, fazem uso do postgres. O fetcher é responsável por buscar os dados em suas fontes. O transformador utiliza o tradutor, um serviço interno responsável por traduzir os dados para um formato tabular, e em seguida realiza manipulações, como joins, nos dados. O preditor encapsula diversas funções para a realização das predições em torno dos contratos públicos.&lt;/p&gt;
&lt;p&gt;Note que acessos aos bancos de dados são realizados por meio de objetos de acesso a dados (DAO).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containers.png&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;implantação&#34;&gt;Implantação&lt;/h4&gt;
&lt;p&gt;O diagrama abaixo mostra onde os containers do Monitor Cidadão estão implantados. As fontes de dados são serviços externos. O banco de dados SAGRES está implantado em uma máquina virtual chamada data-lake-mc. Os demais componentes estão implantados em outra máquina virtual chamada monitor-cidadão.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;implantacao.png&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo apresenta os componentes do preditor do Monitor Cidadão: um gerador de features, um seletor de features, um pré-processador, um treinador e um avaliador. Todos estes componentes são desenvolvidos em R.&lt;/p&gt;
&lt;p&gt;O gerador de features recebe dados do AL_DB e cria novas features com base em manipulações dos dados existentes. O seletor de features seleciona as features mais recentemente adicionadas no banco de dados MC_DB. O pré-processador recebe as features selecionadas e realiza pré-processamento nos dados: divide os dados em treino e teste e realiza conversões de tipo. O treinador é responsável por treinar modelos do tipo regressão logística e floresta aleatória. O avaliador calcula métricas para os modelos treinados.&lt;/p&gt;
&lt;p&gt;Note que as informações referentes à predição: conjunto de features utilizadas, modelos, métricas, são salvos no MC_DB. Acessos aos bancos de dados são realizados por meio de objetos de acesso a dados (DAO).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;componentes.png&#34; alt=&#34;fig4&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;O diagrama abaixo descreve a máquina de estados dos dados do preditor do Monitor Cidadão. Se formos gerar novas features, saímos do estado inicial (1) para o estado (2), onde os dados estão armazenados no AL_DB. Então executamos o DAO e vamos para o estado (3), onde os dados foram carregados para manipulação. Depois, executamos o gerador de features e vamos para o estado (4), onde temos os dados com as novas features. Executamos o DAO e vamos para o estado (5), onde as features foram armazenadas no MC_DB. Se não formos gerar novas features, saímos do estado inicial (1) para o estado (5), onde as features estão armazenadas no MC_DB.&lt;/p&gt;
&lt;p&gt;Do estado (5), executamos o seletor de features e vamos para o estado (6), onde os dados com as features mais recentes foram escolhidos. Depois, executamos o DAO e vamos para o estado (7), onde os dados para manipulação foram carregados. Então executamos o pré-processador e vamos para o estado (8), onde temos os dados balanceados e com tipos adequados. Em seguida, executamos o treinador e vamos para o estado (9), onde temos os modelos treinados. Executamos o avaliador e vamos para o estado (10), onde temos os modelos avaliados. Por fim, executando o DAO, vamos para o estado (11), que é o estado de aceitação, onde os dados do experimento estão armazenados no MC_DB.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;estados-preditor.png&#34; alt=&#34;fig5&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;contribuições-concretas&#34;&gt;Contribuições Concretas&lt;/h1&gt;
&lt;p&gt;Ao produzir o conteúdo deste post, abri dois PRs para o repositório da camada de dados do Monitor Cidadão. O primeiro PR foi para atualizar o diagrama do fluxo de dados, que se encontra desatualizado no README do repositório. Em 12 de Outubro de 2020, o PR está aberto: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/73&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/73&lt;/a&gt;. O segundo PR foi para adicionar um documento de descrição da arquitetura do preditor do Monitor Cidadão de acordo com o modelo C4. Tal documento não existia no projeto. Em 12 de Outubro de 2020, o PR está aberto: &lt;a href=&#34;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/74&#34;&gt;https://github.com/analytics-ufcg/monitor-cidadao-dados/pull/74&lt;/a&gt;.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Moment Js</title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/momentjs/</link>
       <pubDate>Thu, 10 Oct 2019 00:00:00 -0300</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/momentjs/</guid>
       <description>&lt;hr&gt;
&lt;p&gt;Este é um documento explica aspectos da arquitetura de uma das mais conhecidas bibliotecas JavaScript para manipulação de data e hora. O Moment
torna a tarefa de manipulçação de data mais simples para o desenvolvedor.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Paulo Dantas.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 115211312&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:paulo.dantas@ccc.ufcg.edu.br&#34;&gt;paulo.dantas@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/moment/moment/&#34;&gt;https://github.com/moment/moment/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-arquitetural----moment&#34;&gt;Descrição Arquitetural &amp;ndash; Moment&lt;/h1&gt;
&lt;p&gt;Este documento descreve parte da arquitetura do projeto &lt;a href=&#34;https://github.com/moment/moment/&#34;&gt;Moment&lt;/a&gt;. Essa descrição foi baseada principalmente no modelo &lt;a href=&#34;https://c4model.com/&#34;&gt;C4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;descrição-geral-sobre-o-moment&#34;&gt;Descrição Geral sobre o Moment&lt;/h2&gt;
&lt;p&gt;O &lt;em&gt;Moment&lt;/em&gt; tem como objetivo disponibilizar ao desenvolvedor ferramentas para a criação e manipulação de datas em projetos JavaScript.
Ele dispõe de um conjunto de funções que tem como objetivo auxiliar o trabalho do desenvolvedor, fazendo com que o trabalho com objetos do tipo Date se torne mais simples.&lt;/p&gt;
&lt;h2 id=&#34;o-serviço-de-manipulação-de-datas-do-moment&#34;&gt;O Serviço de manipulação de datas do Moment&lt;/h2&gt;
&lt;h3 id=&#34;objetivo-geral&#34;&gt;Objetivo Geral&lt;/h3&gt;
&lt;p&gt;Criar objetos do tipo Date que são facilmente convertidos, formatados e manipulados. Proporcionando, deste modo, que o desenvolvedor escreva códigos mais simples e concisos.&lt;/p&gt;
&lt;h3 id=&#34;objetivos-específicos&#34;&gt;Objetivos Específicos&lt;/h3&gt;
&lt;p&gt;Auxiliar no desenvolvimento de projetos que manipulam datas, a partir da criação de objetos mutáveis que são simples de serem trabalhados.&lt;/p&gt;
&lt;h3 id=&#34;contexto&#34;&gt;Contexto&lt;/h3&gt;
&lt;p&gt;O &lt;em&gt;Moment&lt;/em&gt; é um pacote que possui diversas ferramentas para manipulação de datas. Tornando mais simples a construção de datas e a sua conversão para diferentes formatos. Deste modo, ele não utiliza nenhuma API externa, fazendo utilização apenas do sistema operacional na qual está sendo utilizado.&lt;/p&gt;
&lt;p&gt;Na criação de um objeto moment, o construtor extrai a data do sistema operacional na qual está inserido. Deste modo, permite a utilização do moment em sistemas offline e em qualquer plataforma.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-context-diagram.png&#34; alt=&#34;contexto&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;containers&#34;&gt;Containers&lt;/h3&gt;
&lt;p&gt;A principal funcionalidade do Moment Js é a criação e manipulação de datas, mas, além disso, ele também apresenta um módulo para internacionalização e um módulo que é responsável pela criação de objetos de duração, que são representantes de períodos de tempo. Tais containers são mostrados no diagrama de container abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-container-diagram.png&#34; alt=&#34;container&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;analisador-de-objetos-de-data-e-hora&#34;&gt;Analisador de objetos de data e hora&lt;/h5&gt;
&lt;p&gt;O container analisador de objetos de data e hora é responsável por criar um objeto que empacota uma data. Além disso, ele possui diversas ferramentas para incrementar, decrementar ou converter este objeto, tendo em vista que estes objetos do moment são mutáveis.&lt;/p&gt;
&lt;h5 id=&#34;i18n&#34;&gt;i18n&lt;/h5&gt;
&lt;p&gt;O container de internacionalização é responsável por configurar o ambiente para a qual o moment será utilizado. Com ele é possível estabelecer qual a localização geográfica do sistema e o idioma default utilizado, além de permitir a visualização de meses e dias da semana no idioma estabelecido.&lt;/p&gt;
&lt;h5 id=&#34;analisador-de-objetos-de-duração&#34;&gt;Analisador de objetos de duração&lt;/h5&gt;
&lt;p&gt;Já o container representante da análise de objetos do tipo duração possui a função de criar objetos que representam períodos de tempo. Com eles é possível realizar conversões entre diferentes unidades de tempo (exemplo: minutos, segundos, horas) e manipular estes objetos.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;
&lt;p&gt;O principal container do moment é o de análise de objetos de data e hora, por este motivo ele terá um foco maior e seus componentes estão representados na imagem abaixo. Neste container é onde ocorre a criação dos objetos de data e a manipulação dos mesmos. O container de análise de data é composto por 5 módulos, são eles: Parser, Get and Set, Manipulate, Display e Compare. Estes serão descritos a seguir.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-component-diagram.png&#34; alt=&#34;componente&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;parser&#34;&gt;Parser&lt;/h5&gt;
&lt;p&gt;O componente de Parser é responsável por criar os objetos que representam data e hora. A partir dele que os métodos de manipulação e conversão são disponibilizados.&lt;/p&gt;
&lt;h5 id=&#34;get-and-set&#34;&gt;Get and Set&lt;/h5&gt;
&lt;p&gt;O componente Get and Set é composto por um conjunto de métodos que possibilita a modificação e obtenção de parâmetros pontuais de um objeto. Por exemplo, é através deste componente que pode-se modificar data ou hora de um objeto moment, assim como obter essas informações do mesmo objeto.&lt;/p&gt;
&lt;h5 id=&#34;manipulate&#34;&gt;Manipulate&lt;/h5&gt;
&lt;p&gt;Semelhante ao componente de Get and Set, o componente Manipulate também é responsável por realizar modificações em objetos criados pelo Parser. A diferença é que os métodos disponibilizados pelo Manipulate não realizam modificações nos objetos de forma direta. O Manipulate pode adicionar ou remover horas, minutos, dias, meses, de forma muito mais prática. O desenvolvedor pode deixar a cargo do componente o cálculo de conversão de data ao ser retirado 1 mês, por exemplo, do dia informado.&lt;/p&gt;
&lt;h5 id=&#34;display&#34;&gt;Display&lt;/h5&gt;
&lt;p&gt;O componente Display é responsável pelas conversões dos objetos moment para diferentes formatos, como por exemplo: String, JSON, Date, dentre outros. Com ele o moment pode converter seus objetos para o formato Date, para assim serem salvos em um banco de dados. Além disso, pode converter datas para o formato String, para ser apresentado ao usuário.&lt;/p&gt;
&lt;h5 id=&#34;compare&#34;&gt;Compare&lt;/h5&gt;
&lt;p&gt;Por fim, o componente Compare é responsável por fazer comparações entre diferentes datas. Assim, ele disponibiliza mecanismos para informar se uma data está a frente de outra e se duas datas, construídas a partir de diferentes formatos, são iguais. Além disso, é com esse componente que é possível verificar se uma String pode ser utilizada para construir um objeto moment.&lt;/p&gt;
&lt;h3 id=&#34;código&#34;&gt;Código&lt;/h3&gt;
&lt;pre&gt;
Nesta etapa não faremos diagramas que apresentam detalhes da
implementação. Faremos isso mais adiante.
&lt;/pre&gt;
&lt;h3 id=&#34;visão-de-informação&#34;&gt;Visão de Informação&lt;/h3&gt;
&lt;p&gt;Como mencionado anteriormente os objetos de data moment são mutáveis, e é este princípio que o diagrama de estados abaixo apresenta.
Inicialmente o objeto moment recebe como parâmetro uma String ou uma data, e a partir deste ponto ele se encontra em estado de análise.
Logo após a análise dos parâmetros o moment vai decidir se os parâmetros informados podem representar uma data, se sim o objeto vai para o estado de criado, caso contrário ele se torna inválido e não poderá mais ser utilizado.
Com o objeto em estado de criado ele pode ser modificado, através dos componentes Setter, Compare e Manipulate. Neste ponto ele se encontra no estado de &amp;ldquo;Em modificação&amp;rdquo;, caso os parâmetros informados para a sua modificação sejam válidos ele retorna para o estado de Criado e estará disponível para utilização futura, caso contrário ele se tornará inválido e sua vida útil irá acabar.
Por fim este objeto pode ser formatado, a partir do componente Display, e assim convertido para um objeto do tipo String ou Date, acabando, deste modo, sua vida como objeto moment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;momentjs-visao-informacao.png&#34; alt=&#34;informacao&#34;&gt;&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title></title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/consoleme/readme/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/consoleme/readme/</guid>
       <description></description>
     </item>
   
     <item>
       <title></title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/docker/readme/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/docker/readme/</guid>
       <description></description>
     </item>
   
     <item>
       <title></title>
       <link>https://joaoarthurbm.github.io/arqsoft-blog/posts/tesseract-ocr/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://joaoarthurbm.github.io/arqsoft-blog/posts/tesseract-ocr/</guid>
       <description>&lt;h1 id=&#34;autores&#34;&gt;Autores&lt;/h1&gt;
&lt;p&gt;Este documento foi produzido por Flávio Roberto Pires Quirino Farias.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Matrícula: 117111444&lt;/li&gt;
&lt;li&gt;Contato: &lt;a href=&#34;mailto:flavio.farias@ccc.ufcg.edu.br&#34;&gt;flavio.farias@ccc.ufcg.edu.br&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Projeto documentado: &lt;a href=&#34;https://github.com/tesseract-ocr/tesseract&#34;&gt;https://github.com/tesseract-ocr/tesseract&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;descrição-geral&#34;&gt;Descrição geral&lt;/h1&gt;
&lt;p&gt;O tesseract-ocr &lt;a href=&#34;https://github.com/tesseract-ocr/tesseract&#34;&gt;(github)&lt;/a&gt; é uma engine de reconhecimento ótico de caracteres a partir de um arquivo de imagem ou de mapa de bits.
Tesseract tem suporte a unicode (UTF-8) e é capaz reconhecer mais de 100 idiomas. Também pode ser treinado para reconhecer outros idiomas.&lt;/p&gt;
</description>
     </item>
   
 </channel>
</rss>
